<!DOCTYPE html>
<html lang="en">
<head>
<script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DeFi Operations</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(45deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 300;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }

        .nav-tabs {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(2, 1fr);
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
            gap: 1px;
        }

        .nav-tab {
            padding: 20px 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border: none;
            background: transparent;
            font-size: 1em;
            font-weight: 500;
            color: #6c757d;
            white-space: nowrap;
        }

        .nav-tab:hover {
            background: #e9ecef;
            color: #495057;
        }

        .nav-tab.active {
            background: white;
            color: #007bff;
            border-bottom: 3px solid #007bff;
        }

        @media (max-width: 768px) {
            .nav-tabs {
                grid-template-columns: repeat(2, 1fr);
                grid-template-rows: repeat(4, 1fr);
            }
        }
        .content {
            padding: 40px;
            min-height: 500px;
        }

        .page {
            display: none;
            animation: fadeIn 0.3s ease-in;
        }

        .page.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .form-group {
            margin-bottom: 25px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }

        .form-group input, .form-group select {
            width: 100%;
            padding: 15px;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            font-size: 1em;
            transition: all 0.3s ease;
        }

        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);
        }






















        .form-group2 {
            margin-bottom: 25px;
        }

        .form-group2 label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }

        .form-group2 input, .form-group2 select {
            width: 100%;
            padding: 15px;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            font-size: 1em;
            transition: all 0.3s ease;
        }

        .form-group2 input:focus, .form-group2 select:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .btn-primary, .btn-success, .btn-warning {
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;#
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            margin-top: 20px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #007bff, #0056b3);
        }

        .btn-success {
            background: linear-gradient(45deg, #28a745, #1e7e34);
        }

        .btn-warning {
            background: linear-gradient(45deg, #ffc107, #e0a800);
        }

        .btn-primary:hover, .btn-success:hover, .btn-warning:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0, 123, 255, 0.3);
        }

        .btn-row {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
        }

        .swap-direction {
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 20px 0;
        }

        .percentage-container {
            position: relative;
            display: inline-block;
            width: 100%;
        }
        
        .percentage-symbol {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            color: #666;
            pointer-events: none;
            font-size: 16px;
        }

        .swap-arrow {
            background: #007bff;
            color: white;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 1.5em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .swap-arrow:hover {
            transform: rotate(180deg);
            background: #0056b3;
        }

        .token-selector {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .token-icon {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: linear-gradient(45deg, #ffd700, #ffed4a);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #333;
        }

        .info-card {
            background: #f8f9fa;
            border-left: 4px solid #007bff;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .info-card h3 {
            color: #007bff;
            margin-bottom: 10px;
        }

        .info-card2 {
            background: #f8f9fa;
            border-left: 4px solid #007bff;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .info-card2 h3 {
            color: #007bff;
            margin-bottom: 10px;
        }


        .info-card3 {
            background: #f8f9fa;
            border-left: 4px solid #007bff;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .info-card3 h3 {
            color: #007bff;
            margin-bottom: 10px;
        }

        .rewards-card {
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 25px;
            text-align: center;
        }

        .rewards-card h3 {
            font-size: 1.8em;
            margin-bottom: 15px;
        }

        .rewards-amount {
            font-size: 2.5em;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .rewards-usd {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .staking-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 25px;
        }

        .stat-card {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #007bff;
            margin-bottom: 5px;
        }

        .stat-label {
            color: #6c757d;
            font-size: 0.9em;
        }

        .slider-container {
            margin: 20px 0;
        }

        .slider {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
        }

        .percentage-display {
            text-align: center;
            font-size: 1.2em;
            font-weight: bold;
            color: #007bff;
            margin-top: 10px;
        }

        @media (max-width: 768px) {
            .nav-tabs {
                flex-wrap: wrap;
            }
            
            .nav-tab {
                flex: 1 1 150px;
                min-width: 100px;
            }
            
            .form-row, .staking-stats {
                grid-template-columns: 1fr;
            }

            .btn-row {
                grid-template-columns: 1fr;
            }
            
            .container {
                margin: 10px;
            }
        }

            #connectBtn {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                border: none;
                padding: 12px 24px;
                border-radius: 8px;
                font-size: 28px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.3s ease;
                box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
                }

                #connectBtn:hover {
                transform: translateY(-2px);
                box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
                background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
                }

                #connectBtn:active {
                transform: translateY(0);
                }

                /* Connected state */
                #connectBtn.connected {
                background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
                box-shadow: 0 4px 15px rgba(17, 153, 142, 0.3);
                }

                #connectBtn.connected:hover {
                background: linear-gradient(135deg, #38ef7d 0%, #11998e 100%);
                box-shadow: 0 6px 20px rgba(17, 153, 142, 0.4);
                }

                /* Disconnect Button */
                #walletInfo button {
                background: #ff4757;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 6px;
                font-size: 22px;
                cursor: pointer;
                margin-left: 10px;
                transition: all 0.3s ease;
                }

                #walletInfo button:hover {
                background: #ff3742;
                transform: translateY(-1px);
                }

#walletAddress {
  font-size: 16px;
  font-weight: 600;
  font-family: 'Courier New', monospace;
  padding: 12px 16px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  border-radius: 10px;
  display: inline-block;
  margin-right: 12px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  border: none;
  letter-spacing: 0.5px;
}



#walletAddress:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
}

#walletAddress a {
  color: white;
  text-decoration: none;
  display: block;
  width: 100%;
  height: 100%;
}







.token-list {
    list-style: none;
    padding: 0;
    margin: 0;
}

.token-list li {
    display: flex;
    justify-content: space-between;
    padding: 8px 12px;
    border-bottom: 1px solid #eee;
}

.token-symbol {
    font-weight: bold;
    color: #333;
}

.token-address {
    font-family: monospace;
    font-size: 0.9em;
    color: #666;
}

.periods-table {
    width: 100%;
    border-collapse: collapse;
}

.periods-table th, .periods-table td {
    padding: 10px;
    text-align: left;
    border-bottom: 1px solid #eee;
}

.periods-table th {
    background-color: #f8f9fa;
}










.wallet-balances {
    margin-bottom: 20px;
}

.balances-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
    gap: 15px;
    margin-top: 15px;
}

.balance-item {
    background: #f8f9fa;
    border-radius: 8px;
    padding: 12px;
    display: flex;
    flex-direction: column;
}

.token-name {
    font-weight: bold;
    color: #333;
    margin-bottom: 5px;
}

.token-amount {
    font-size: 1.1em;
    color: #212529;
}
        















        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 24px;
            margin-bottom: 24px;
        }

        .settings-form {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .settings-form h3 {
            color: #2d3748;
            margin-bottom: 8px;
            font-size: 1.25rem;
        }

        .settings-form p {
            color: #4a5568;
            margin-bottom: 20px;
            line-height: 1.5;
            font-size: 0.9rem;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: #2d3748;
            font-weight: 500;
        }

        .input-group {
            display: flex;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            overflow: hidden;
            transition: border-color 0.3s;
        }

        .input-group:focus-within {
            border-color: #667eea;
        }

        .input-group input {
            flex: 1;
            padding: 12px 16px;
            border: none;
            outline: none;
            font-size: 1rem;
        }

        .input-group .unit {
            background: #f7fafc;
            padding: 12px 16px;
            color: #4a5568;
            font-weight: 500;
            border-left: 1px solid #e2e8f0;
        }

        textarea {
            width: 100%;
            padding: 16px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
            resize: vertical;
            min-height: 120px;
            transition: border-color 0.3s;
        }

        textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .btn-secondary {
            background: #e2e8f0;
            color: #2d3748;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s;
            margin-right: 12px;
        }

        .btn-secondary:hover {
            background: #cbd5e0;
            transform: translateY(-1px);
        }

        .button-group {
            display: flex;
            gap: 12px;
            margin-top: 16px;
        }

        .address-config {
            grid-column: 1 / -1;
        }

        .success-message {
            background: #c6f6d5;
            color: #22543d;
            padding: 12px 16px;
            border-radius: 8px;
            margin-top: 12px;
            display: none;
        }


               /* Loading Screen Styles */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            color: white;
            font-family: Arial, sans-serif;
        }

        .loading-content {
            text-align: center;
        }

        .loader {
            width: 60px;
            height: 60px;
            border: 6px solid rgba(255,255,255,0.3);
            border-top: 6px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 30px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-title {
            font-size: 2.5em;
            font-weight: bold;
            margin-bottom: 10px;
            opacity: 0;
            animation: fadeIn 0.8s ease forwards 0.5s;
        }

        .loading-subtitle {
            font-size: 1.2em;
            opacity: 0.8;
            margin-bottom: 20px;
            opacity: 0;
            animation: fadeIn 0.8s ease forwards 1s;
        }

        .loading-status {
            font-size: 1em;
            opacity: 0.7;
            opacity: 0;
            animation: fadeIn 0.8s ease forwards 1.5s;
        }












               .toggle-container {
            display: inline-block;
            margin: 10px;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: #2196F3;
        }

        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }

        .toggle-label {
            margin-left: 10px;
            vertical-align: middle;
            font-size: 16px;
        }










        .wallet-balances {
            margin-bottom: 20px;
        }

        .wallet-balances h3 {
            font-size: 1.5em;
            font-weight: 600;
            color: #333;
            margin-bottom: 20px;
            text-align: center;
        }

        .balances-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 16px;
            margin-top: 15px;
        }

        .balance-item {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 16px;
            display: flex;
            flex-direction: column;
            transition: all 0.2s ease;
            position: relative;
        }

        .balance-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            border-color: #667eea;
        }

        .balance-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #667eea, #764ba2);
            border-radius: 8px 8px 0 0;
        }

        .token-name {
            font-weight: 600;
            color: #495057;
            margin-bottom: 8px;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .token-amount {
            font-size: 1.3em;
            font-weight: 600;
            color: #212529;
            word-break: break-all;
        }

        .loading-text {
            color: #6c757d;
            font-style: italic;
            text-align: center;
            padding: 40px 20px;
        }

        @media (max-width: 768px) {
            .balances-grid {
                grid-template-columns: 1fr;
                gap: 12px;
            }
            
            .container {
                padding: 20px;
            }
        }

    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading-screen">
        <div class="loading-content">
            <div class="loader"></div>
            <div class="loading-title">DeFi Operations</div>
            <div class="loading-subtitle">Initializing your DeFi experience</div>
            <div class="loading-status" id="loading-status">Loading contracts...</div>
        </div>
    </div>

    <!-- Main Content (hidden initially) -->
    <div id="main-content">
        <div class="container">
            <div class="header">
                <h1>DeFi Operations</h1>
                <p>Swap, Stake, and Manage Your Liquidity Positions</p>
            </div>

            <div class="nav-tabs">
                <button class="nav-tab active" onclick="switchTab('swap')">Swap</button>
                <button class="nav-tab" onclick="switchTab('create')">Create Position</button>
                <button class="nav-tab" onclick="switchTab('increase')">Increase Liquidity</button>
                <button class="nav-tab" onclick="switchTab('decrease')">Decrease Liquidity</button>
                <button class="nav-tab" onclick="switchTab('staking-main-page')">Staking</button>
                <button class="nav-tab" onclick="switchTab('stakeincrease')">Stake Increase</button>
                <button class="nav-tab" onclick="switchTab('stake-decrease')">Stake Decrease</button>
                <button class="nav-tab" onclick="switchTab('settings')">Settings</button>
                <button class="nav-tab" onclick="switchTab('staking-management')">Stake Management</button>
                <button class="nav-tab" onclick="switchTab('testnet-faucet')">Testnet Token Facuet</button>
            </div>
            <center>
            <div class="wallet-section">
            <button id="connectBtn" onclick="connectWallet()">Connect Wallet</button>
            <div id="walletInfo" style="display: none;">
                <span id="walletAddress"></span>
                <button onclick="disconnectWallet()">Disconnect</button>
            </div>
            </center>
            <div class="content">
                <!-- Settings Page -->
        <div id="testnet-faucet" class="page">
            <div class="info-card">
                <h3>Testnet Facuet</h3>
                <p>Collect 10 0xBTC and 10 B0x for testing!</p>
            </div>

                    <button class="btn-primary" onclick="getFacuetTokens()">Get 10 0xBTC + 10 B0x for Testnet Two Transactions</button>


                </div>

                <!-- Settings Page -->
        <div id="settings" class="page">
            <div class="info-card">
                <h3>System Settings</h3>
                <p>Configure minimum staking amounts and user holding requirements for the platform. To prevent Spam Attacks!</p>
            </div>

            <div class="settings-grid">

                <div class="settings-form address-config">
                    <h3>🏦 Staking Rewards Contract Address Configuration</h3>
                    <p>Configure the Reward contract addresses used by the platform. Enter reward addresses in JSON array format.</p>
                    
                    <div class="form-group">
                        <label>Reward Contract Addresses (JSON Array)</label>
                        <textarea id="contractAddresses" placeholder='["0x4200000000000000000000000000000000000006", "0x0000000000000000000000000000000000000000"]'>["0x4200000000000000000000000000000000000006", "0x0000000000000000000000000000000000000000"]</textarea>
                    </div>
                    
                    <div class="button-group">
                        <button class="btn-secondary" onclick="restoreDefaultAddressesfromContract()">Get Defaults from Contract</button>
                        <button class="btn-secondary" onclick="restoreDefaultAddressesfromGithub()">Get Defaults from Github</button>
                        <button class="btn-secondary" onclick="restoreDefaultAddresses()">Restore Defaults </button>
                        <button class="btn-primary" onclick="saveAddresses()">Save Addresses</button>
                    </div>
                <div id="addressSuccess" class="success-message">Contract addresses saved successfully!</div>
                            <div class="toggle-container">
                                <label class="toggle-switch">
                                    <input type="checkbox" id="toggle1" data-save-key="feature_notifications">
                                    <span class="toggle-slider"></span>
                                </label>
                                <span class="toggle-label">Get New Reward Tokens from Contract Automatically</span>
                            </div>
                </div>
                <div class="settings-form">
                    <h3>🔒 Minimum Staking Configuration</h3>
                    <p>Set the minimum amount of tokenA required for users Staked Position.  Used to prevent spam.  Units is Wei</p>
                    
                    <div class="form-group">
                        <label>Minimum Staking Amount</label>
                        <div class="input-group">
                            <input type="number" id="minStaking" placeholder="0" step="1" min="0">
                            <div class="unit">Tokens</div>
                        </div>
                    </div>
                    
                    <button class="btn-primary" onclick="saveMinStaking()">Save Minimum Staking</button>
                    <div id="stakingSuccess" class="success-message">Minimum staking amount saved successfully!</div>
                </div>

                <div class="settings-form">
                    <h3>💰 Minimum User Holdings</h3>
                    <p>Set the minimum tokenA required for user to see a NFT position held in wallet. To prevent spam attacks! Units is Wei</p>
                    
                    <div class="form-group">
                        <label>Minimum Holdings Required</label>
                        <div class="input-group">
                            <input type="number" id="minUserHoldings" placeholder="0" step="1" min="0">
                            <div class="unit">Tokens</div>
                        </div>
                    </div>
                    
                    <button class="btn-primary" onclick="saveMinUserHoldings()">Save Minimum Holdings</button>
                    <div id="holdingsSuccess" class="success-message">Minimum holdings amount saved successfully!</div>
                </div>

            </div>
                </div>

                <!-- Staking Management Page -->
                <div id="staking-management" class="page">
                    <div class="info-card">
                        <h3>Staking Management</h3>
                        <p>Manage reward tokens and configure staking reward periods for the platform.</p>
                    </div>

                    <div class="staking-management">
                        <div class="management-card">
                            <h3>🪙 Add Reward Token</h3>
                            <p>Add new ERC20 tokens to be distributed as staking rewards. Costs 10 USDC, get Testnet USDC for Base Sepolia @ <a href="https://faucet.circle.com/" target="_blank" rel="noopener noreferrer">https://faucet.circle.com/</a></p>
                            
                            <div class="form-group">
                                <label>Reward Token Contract Address</label>
                                <input type="text" id="rewardTokenAddress" class="address-input" 
                                    placeholder="0x742d35Cc6634C0532925a3b8D1C07E8DEa95C7C4" 
                                    pattern="^0x[a-fA-F0-9]{40}$">
                            </div>
                            <button class="btn-success" onclick="addRewardToken()">Add Reward Token</button>
                            <br></br><br></br>
                            <div class="reward-tokens-list" id="rewardTokensList">
                                <h4>Current Reward Tokens Ready to Start new Period of Staking:</h4>
                                <div id="rewardTokensContainer">
                                    <p style="color: #6c757d; font-style: italic;">No reward tokens added yet.</p>
                                </div>
                            </div>
                        </div>

                        <div class="management-card">
                            <h3>🚀 Start Reward Period</h3>
                            <p>Configure and start a new reward distribution period for stakers.</p>
                            
                            <div class="form-group">
                                <label>Select Reward Token</label>
                                <select id="selectedRewardToken">
                                    <option value="">Select a reward token...</option>
                                </select>
                            </div>
                            <button class="btn-primary" onclick="startRewardPeriod()">Start Reward Period</button>
                        </div><br></br>

                        <div class="management-card">
                            <h3>📊 Active Reward Periods</h3>
                            <p>Monitor and manage currently active reward distribution periods.</p>
                            
                            <div id="activePeriodsContainer">
                                <p style="color: #6c757d; font-style: italic;">No active reward periods.</p>
                            </div>
                        </div>
                    </div>
                            <button class="btn-primary" onclick="getRewardStats()">getRewardStats</button>
                </div>


                <!-- Swap Page -->
                <div id="swap" class="page active">


                    <!-- Wallet Balances Display -->
                    <div class="wallet-balances">
                        <h3>Wallet Balances</h3>
                        <div id="walletBalancesDisplay3" class="balances-grid">
                            <!-- Will be populated by JavaScript -->
                            <p style="color: #6c757d; font-style: italic;">Loading wallet balances...</p>
                        </div>
                    </div>

                    <div class="info-card">
                        <h3>Token Swap</h3>
                        <p>Exchange one token for another at current market rates with minimal slippage.</p>
                    </div>
                    
                    <div class="form-group">
                        <label>From Token</label>
                        <div class="token-selector">
                            <div class="token-icon" id="fromTokenIcon">E</div>
                            <select id="fromToken" onchange="updateTokenIcon('fromToken', 'fromTokenIcon')">
                                <option value="B0x">B0x - B Zero X Token</option>
                                <option value="0xBTC">0xBTC - 0xBitcoin Token</option>
                            </select>
                        </div>
                    </div>


                    <div class="form-group">
                        <label>Amount</label>
                        <input type="number" placeholder="0.0" step="0.000001" value="0">
                    </div>

                    <div class="swap-direction">
                        <button class="swap-arrow" onclick="swapTokens()">⇅</button>
                    </div>

                    <div class="form-group">
                        <label>To Token</label>
                        <div class="token-selector">
                            <div class="token-icon" id="toTokenIcon">U</div>
                            <select id="toToken" onchange="updateTokenIcon('toToken', 'toTokenIcon')">
                                <option value="0xBTC">0xBTC - 0xBitcoin Token</option>
                                <option value="B0x">B0x - B Zero X Token</option>
                            </select>
                        </div>
                    </div>

                    <div class="form-group">
                        <label>Estimated Output</label>
                        <input type="text" value="0.0" readonly style="background: #f8f9fa;">
                    </div>

                        <div class="form-group">
                            <label>Slippage Tolerance</label>
                            <select id="slippageToleranceSwap"> 
                                <option>0.1%</option>
                                <option>0.5%</option>
                                <option>1.0%</option>
                                <option>2.0%</option>
                            </select>
                        </div>

                    <button class="btn-primary" onclick="executeSwap()">Execute Swap</button>
                </div>

                <!-- Staking Page -->
                <div id="staking-main-page" class="page">
                    <div class="info-card3">
                        <h2>Uniswap V4 Token Staking</h2>
                        <p>Stake your Unsiwap NFT tokens to earn rewards and support network security.</p>
                        </div>
                    <div class="rewards-card">
                        <h3>Current Rewards</h3>
                        <div class="rewards-amount" id="rewardsAmount">0.01 ETH & 10 TokenA</div>
                        <div class="rewards-usd" id="rewardsUSD">≈ $1.90 USD</div>

                        <button class="btn-primary" onclick="collectRewards()">Collect Rewards</button>
                    </div>
                    <div class="staking-stats" id="stakingStatsContainer">
                        <!-- Will be populated by JavaScript -->
                    </div>
                    <div class="info-card3">
                        <h2>Uniswap V4 Token Staking</h2>
                        <p>Stake your Unsiwap NFT tokens to earn rewards and support network security.</p>
                        </div>

                    <div class="info-card2">
                        <h3>NFT Position Info</h3>
                        <p>Create Position to Stake Position</p>
                    </div>
                    <div class="form-group">
                        <label>Select Position</label>
                            <select>
                                <option>STAKE - Staking Token</option>
                                <option>DAI - Dai Stablecoin</option>
                            </select>
                    </div>

                    <div class="form-group">
                        <label>Estimated Percentage of Staking Rewards this position is</label>
                        <input type="text" id="estimatedRewards" value="0.00 B0x" readonly style="background: #f8f9fa;">
                    </div>

                        <button class="btn-success" onclick="depositNFTStake()">Deposit NFT</button><br></br><br></br>

                    <div class="info-card3">
                        <h2>Uniswap v4 NFT Token Withdrawing</h2>
                        <p>Unstake your Unsiwap NFT tokens below. It is cheaper if you use Stake Decrease if you are only removing a portion of your funds from staking.</p>
                    </div>

                        <div class="info-card">
                        <h3>Token Withdrawing</h3>
                        <p>Unstake your Unsiwap NFT tokens below.</p>
                    </div>
                <br></br>
                    <div class="form-group2">
                        <label>Select NFT to Withdraw</label>
                            <select>
                                <option>UNSTAKE - UNStaking Token</option>
                                <option>UNDAI - UNDai Stablecoin</option>
                            </select>
                    </div>
                        <button class="btn-warning" onclick="withdrawStake()">Withdraw</button>


                </div>

                <!-- Create Position Page -->
                <div id="create" class="page">
                    <div class="info-card">
                        <h3>Create Liquidity Position</h3>
                        <p>Provide liquidity to earn fees by depositing token pairs into liquidity pools.</p>
                    </div>

                    <!-- Wallet Balances Display -->
                    <div class="wallet-balances">
                        <h3>Wallet Balances</h3>
                        <div id="walletBalancesDisplay4" class="balances-grid">
                            <!-- Will be populated by JavaScript -->
                            <p style="color: #6c757d; font-style: italic;">Loading wallet balances...</p>
                        </div>
                    </div>

                    <div class="form-row">
                        <div class="form-group">
                            <label>Token A</label>
                            <div class="token-selector">

                        <div class="token-icon" id="tokenAIcon">U</div>
                                <select id="tokenA">
                                    <option value="0xBTC">0xBTC - 0xBitcoin Token</option>
                                    <option value="B0x">B0x - B Zero X Token</option>
                                </select>
                            </div>
                        </div>
                        <div class="form-group">
                            <label>Token B</label>
                            <div class="token-selector">
                            <div class="token-icon" id="tokenBIcon">U</div>
                                <select id="tokenB">
                                    <option value="0xBTC">0xBTC - 0xBitcoin Token</option>
                                    <option value="B0x">B0x - B Zero X Token</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <div class="form-row">
                        <div class="form-group">
                            <label>Amount A</label>
                            <input type="number" id="amountA" placeholder="0.0" step="0.000001" value="0">          </div>
                        <div class="form-group">
                            <label>Amount B</label>
                            <input type="number" id="amountB" placeholder="0.0" step="0.000001" value="0">        </div>
                    </div>

                    <div class="form-row">
                        <div class="form-group">
                            <label>Fee Tier</label>
                            <select>
                                <option>Dynamic Fee - Required For Staking</option>
                            <!-- <option>0.30% - Standard</option>
                                <option>1.00% - Exotic pairs</option>-->
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Price Range</label>
                            <select>
                                <option>Full Range - Required For Staking</option>
                                <!---
                                <option>Narrow (±10%)</option>
                                <option>Wide (±50%)</option>
                                <option>Custom</option>
                                -->
                            </select>
                        </div>

                        <div class="form-group">
                            <label>Hook Address</label>
                            <select>
                                <option>Use Dynamic Fee Hook - Required For Staking</option>
                                <!---
                                <option>Narrow (±10%)</option>
                                <option>Wide (±50%)</option>
                                <option>Custom</option>
                                -->
                            </select>
                        </div>


                        <div class="form-group">
                            <label>Slippage Tolerance</label>
                            <select id="slippageToleranceCreate"> 
                                <option>0.1%</option>
                                <option>0.5%</option>
                                <option>1.0%</option>
                                <option>2.0%</option>
                            </select>
                        </div>
                    </div>


                    <button class="btn-primary" onclick="getCreatePosition()">Create Position</button>
                 <!--   <button class="btn-primary" onclick="getRatioCreatePositiontokenA()">getRatioCreatePositiontokenA Position</button>
                    <button class="btn-primary" onclick="getRatioCreatePositiontokenB()">getRatioCreatePositiontokenB Position</button>
                    <button class="btn-primary" onclick="getMaxCreatePosition()">getMaxCreatePosition Button</button> -->
                    
                </div>


                <!-- Increase Liquidity Page -->
                <div id="increase" class="page">
                    <div class="info-card">
                        <h3>Increase Liquidity</h3>
                        <p>Add more funds to your existing liquidity position to earn more fees.</p>
                    </div>
                    <!-- Wallet Balances Display -->
                    <div class="wallet-balances">
                        <h3>Wallet Balances</h3>
                        <div id="walletBalancesDisplay" class="balances-grid">
                            <!-- Will be populated by JavaScript -->
                            <p style="color: #6c757d; font-style: italic;">Loading wallet balances...</p>
                        </div>
                    </div>


                    <div class="form-group">
                        <label>Select Position</label>
                        <select>
                            <!-- Options will be populated by JavaScript -->
                        </select>
                    </div>
                    <!--
                    <div class="info-card">
                        <h3>Current Selected Position</h3>
                        <p><strong>Pool:</strong> ETH/USDC (0.30%)</p>
                        <p><strong>Current Liquidity:</strong> $1,250.00</p>
                        <p><strong>Unclaimed Fees:</strong> $12.50</p>
                    </div>
                            instead we want reminder -->
                    <div class="info-card">
                        <h3>Current Selected Position</h3><p> create position to increase</p>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label>Add Total <span id="tokenALabel">ETH</span></label>
                            <input type="number" id="tokenAAmount" placeholder="0.0" step="0.000001" value="0">
                        </div>
                        <div class="form-group">
                            <label>Add Total <span id="tokenBLabel">USDC</span></label>
                            <input type="number" id="tokenBAmount" placeholder="0.0" step="0.000001" value="0">
                        </div>
                    </div>
                    
                    <b>Adding Liquidity Automatically uses your unclaimed fees in the deposit</b><br></br>

                    <div class="form-group">
                        <label>New Total Liquidity</label>
                        <input type="text" value="$0.00" readonly style="background: #f8f9fa;">
                    </div>

                        <div class="form-group">
                            <label>Slippage Tolerance</label>
                            <select id="slippageToleranceIncreaseLiquidity"> 
                                <option>0.1%</option>
                                <option>0.5%</option>
                                <option>1.0%</option>
                                <option>2.0%</option>
                            </select>
                        </div>
                    <button class="btn-primary" onclick="increaseLiquidity()">Increase Liquidity</button>
               <!--      <button class="btn-primary" onclick="getTokenIDsOwnedByMetamask()">Get Metamask StakedTokensOwned</button>
                    <button class="btn-primary" onclick="getTokenIDsOwnedByStaking()">Get Staking Contracted Owned NFTs</button>
                    -->
                </div>


                <!-- Decrease Liquidity Page -->
                <div id="decrease" class="page">
                    <div class="info-card">
                        <h3>Decrease Liquidity</h3>
                        <p>Remove funds from your liquidity position and claim accumulated fees.</p>
                    </div>

                    <div class="form-group">
                        <label>Select Position</label>
                        <select onchange="updatePositionInfo()">
                        </select>
                    </div>

                    <div class="info-card">
                        <h3>Current Selected Position</h3><p> create position to decrease</p>
                    </div>

                    <!-- old
                    <div class="info-card">
                        <h3>Position Details</h3>
                        <p><strong>Pool:</strong> ETH/USDC (0.30%)</p>
                        <p><strong>Total Liquidity:</strong> $1,250.00</p>
                        <p><strong>Unclaimed Fees:</strong> $12.50</p>
                        <p><strong>Position Age:</strong> 15 days</p>
                    </div>
-->
                    <div class="form-group">
                        <label>Removal Percentage</label>
                        <div class="slider-container">
                            <input type="range" min="0" max="100" value="25" class="slider" onchange="updatePercentage(this.value)">
                            <div class="percentage-display" id="percentageDisplay">25%</div>
                        </div>
                    </div>

                    <div class="form-row">
                        <div class="form-group">
                            <label><span id="tokenALabel">B0x</span> to Recieve</label>
                            <input type="text" value="0.00 B0x" readonly style="background: #f8f9fa;" id="tokenAAmount">
                        </div>
                        <div class="form-group">
                            <label><span id="tokenBLabel">0xBTC</span> to Recieve</label>
                            <input type="text" value="0.00 0xBTC" readonly style="background: #f8f9fa;" id="tokenBAmount">
                        </div>
                    </div>

    <b>Remving Liquidity Automatically claims your unclaimed fees.</b><br></br>

                    <div class="form-group">
                        <label>Fees to Claim</label>
                        <input type="text" value="$0.00" readonly style="background: #f8f9fa;">
                    </div>

                        <div class="form-group">
                            <label>Slippage Tolerance</label>
                            <select id="slippageToleranceDecrease"> 
                                <option>0.1%</option>
                                <option>0.5%</option>
                                <option>1.0%</option>
                                <option>2.0%</option>
                            </select>
                        </div>
                    <button class="btn-primary" onclick="decreaseLiquidity()">Remove Liquidity & Claim Fees</button>
                </div>

                <!-- Staking Increase Liquidity Page -->
                <!-- Staking Increase Liquidity Page -->
                <div id="stakeincrease" class="page">
                    <div class="info-card">
                        <h3>Increase Staking Liquidity</h3>
                        <p>Add more funds to your existing staking position to earn more rewards.</p>
                    </div>

                    <!-- Wallet Balances Display -->
                    <div class="wallet-balances">
                        <h3>Wallet Balances</h3>
                        <div id="walletBalancesDisplay2" class="balances-grid">
                            <!-- Will be populated by JavaScript -->
                            <p style="color: #6c757d; font-style: italic;">Loading wallet balances...</p>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Select Position</label>
                        <select>
                            <!-- Options will be populated by JavaScript -->
                        </select>
                    </div>

                    <div class="info-card">
                        <h3>Current Selected Position</h3><p> stake position to increase</p>
                    </div>
                    <!-- old
                    <div class="info-card">
                        <h3>Current Selected Position</h3>
                        <p><strong>Pool:</strong> ETH/USDC (0.30%)</p>
                        <p><strong>Current Liquidity:</strong> $1,250.00</p>
                   
                    </div>-->


                    <div class="form-row">
                        <div class="form-group">
                            <label>Add <span id="tokenALabelINC">ETH</span></label>
                            <input type="number" id="tokenAAmount" placeholder="0.01" step="0.000001" value=1>
                        </div>
                        <div class="form-group">
                            <label>Add <span id="tokenBLabelINC">USDC</span></label>
                            <input type="number" id="tokenBAmount" placeholder="0.01" step="0.000001" value=2>
                        </div>
                    </div>

                    <div class="form-group">
                        <label>New Total Liquidity</label>
                        <input type="text" value="$0.00" readonly style="background: #f8f9fa;">
                    </div>
                        <div class="form-group">
                            <label>Slippage Tolerance</label>
                            <select id="slippageToleranceStakeIncrease"> 
                                <option>0.1%</option>
                                <option>0.5%</option>
                                <option>1.0%</option>
                                <option>2.0%</option>f
                            </select>
                        </div>

                    <button class="btn-primary" onclick="increaseLiquidityStaking()">Increase Staking Position</button>
                </div>

                <!-- Staking Decrease Liquidity Page -->
                <div id="stake-decrease" class="page">
                    <div class="info-card">
                        <h3>Decrease Staking Liquidity</h3>
                        <p>Remove funds from your staking position and claim accumulated rewards.</p>
                    </div>

                    <div class="form-group">
                        <label>Select Position</label>
                        <select>
                            <!-- Options will be populated by JavaScript -->
                        </select>
                    </div>
                    <!-- old
                    <div class="info-card">
                        <h3>Position Details</h3>
                        <p><strong>Pool:</strong> ETH/USDC (0.30%)</p>
                        <p><strong>Total Staked:</strong> $1,250.00</p>
                        <p><strong>Unclaimed Rewards:</strong> $12.50</p>
                        <p><strong>APY:</strong> 8.75%</p>
                    </div>
                    -->
                    <div class="info-card">
                        <h3>Current Selected Position</h3><p> stake position to decrease</p>
                    </div>
                    <div class="form-group">
                        <label>Removal Percentage</label>
                        <div class="slider-container">
                            <input type="range" min="0" max="100" value="25" class="slider">
                            <div class="percentage-display" id="stakePercentageDisplay">25%</div>
                        </div>
                    </div>

                    <div class="form-row">
                        <div class="form-group">
                            <label><span id="tokenALabelDec">0xBTC</span> to Recieve</label>
                            <input type="text" value="0.0 0xBTC" readonly style="background: #f8f9fa;" id="tokenAAmountDec">
                        </div>
                        <div class="form-group">
                            <label><span id="tokenBLabelDec">B0x</span> to Recieve</label>
                            <input type="text" value="0.0 B0x" readonly style="background: #f8f9fa;" id="tokenBAmountDec">
                        </div>
                    </div>

                        <div class="form-group">
                            <label>Slippage Tolerance</label>
                            <select id="slippageToleranceStakeDecrease"> 
                                <option>0.1%</option>
                                <option>0.5%</option>
                                <option>1.0%</option>
                                <option>2.0%</option>
                            </select>
                        </div>

                        <button class="btn-primary" onclick="decreaseLiquidityStaking()">Decrease Liquidity on Staked NFT</button>

                </div>


                <!-- Staking Decrease Liquidity Page -->
                <div id="admin-functions" class="page">
                    <div class="info-card">
                        <h3>ADMIN FUNCTIONS FILL IN HERE</h3>
                        <p>ADMIN FUNCTIONS FILL IN HERE2.</p>
                        <p>Update Pool Fee and Add ERC20 Token Reward and Remove ERC20 Reward</p>
                    </div>
    <h1>Hook Admin Functions</h1>

    <div class="form-row">
        <div class="form-group">
            <label>New Fee %</label>
            <div style="position: relative; display: inline-block; width: 100%;">
                <input type="number" 
                    id="UpdateAdminFee" 
                    value="1" 
                    step="0.1" 
                    min="0" 
                    max="100"
                    style="width: 100%; padding: 10px 25px 10px 10px; border: 1px solid #ddd; border-radius: 4px;">
                <span style="position: absolute; left: 55px; top: 50%; transform: translateY(-50%); color: #666; pointer-events: none;">%</span>
            </div>
        </div>
    </div>
                        <button class="btn-primary" onclick="updateAdminFeeForPool()">Update Admin PooL Fee</button>
                    <br></br><br></br><br></br><h1>Staking Admin Functions</h1>


    <!-- Basic Address Input -->
        <div class="form-group">
            <label for="basic-address-Add">Add ERC20 to Staking</label>
            <input type="text" 
                id="basic-address-add" 
                class="address-input"
                placeholder="0x1234567890abcdef1234567890abcdef12345678"
                maxlength="42">
        </div>
                        <button class="btn-primary" onclick="addERC20ToStakingContract()">Add ERC20 to Staking Contract</button>
    <br></br><br></br>
    <!-- Basic Address Input -->
        <div class="form-group">
            <label for="basic-address-Remove">Remove ERC20 from Staking</label>
            <input type="text" 
                id="basic-address-remove" 
                class="address-input"
                placeholder="0x2222567890abcdef1234567890abcdef12345678"
                maxlength="42">
        </div>

                        <button class="btn-primary" onclick="removeERC20FromStakingContract()">Remove ERC20 to Staking Contract</button>

                </div>







            </div>
        </div>

    </div>

    <script>

document.addEventListener('DOMContentLoaded', () => {
    const toggle = document.getElementById('toggle1');
    const saveKey = toggle.dataset.saveKey;

    // Load saved state
    const savedState = localStorage.getItem(saveKey);
    if (savedState !== null) {
        toggle.checked = savedState === 'true';
    }

    // Save state on change
    toggle.addEventListener('change', () => {
        localStorage.setItem(saveKey, toggle.checked);
    });
});
            initializeDApp();

    // Loading screen management
        function updateLoadingStatus(message) {
            document.getElementById('loading-status').textContent = message;
        }

        function hideLoadingScreen() {
            document.getElementById('loading-screen').style.display = 'none';
            document.getElementById('main-content').style.display = 'block';
        }

        /* Simulate your dApp initialization*/
        async function initializeDApp() {
            try {
                updateLoadingStatus('Connecting to blockchain...');
                await new Promise(resolve => setTimeout(resolve, 3000));
                
                updateLoadingStatus('Loading smart contracts...');
                await new Promise(resolve => setTimeout(resolve, 1500));
                
                updateLoadingStatus('Fetching data...');
                await new Promise(resolve => setTimeout(resolve, 1500));
                
                updateLoadingStatus('Initializing interface...');
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                updateLoadingStatus('Ready!');
                await new Promise(resolve => setTimeout(resolve, 500));
                
                hideLoadingScreen();
            } catch (error) {
                console.error('Failed to initialize dApp:', error);
                updateLoadingStatus('Error loading dApp. Please refresh.');
            }
        }
        


function updateStakingStats() {
    const container = document.querySelector('#staking-main-page #stakingStatsContainer');
    console.log("thishur:");
    
    console.log("continaer!: ", container)
    
    if (!container) return;
    
    // Use the same logic as updateStakingValues to get the 2 tokens
    var tokencheck = Address_ZEROXBTC_TESTNETCONTRACT;
    var tokencheck2 = tokenAddresses['B0x'];
    console.log("tokenCheck: ", tokencheck);
    console.log("tokencheck2: ", tokencheck2);
    
    // Simple string comparison (addresses as hex strings)
    let currency0, currency1;
    if (tokencheck.toLowerCase() < tokencheck2.toLowerCase()) {
        currency0 = tokencheck;
        currency1 = tokencheck2;
    } else {
        currency0 = tokencheck2;
        currency1 = tokencheck;
    }
    
    console.log("Using currency0:", currency0);
    console.log("Using currency1:", currency1);
    
    let statsHTML = '';
    
    // Create stat cards for total staked (one card for all tokens)
    statsHTML += `
        <div class="stat-card">
    `;
    
    // Add stat-value divs for the 2 tokens only
    const token0Name = getTokenNameFromAddress(currency0);
    const token1Name = getTokenNameFromAddress(currency1);
    
    statsHTML += `<div class="stat-value" id="totalStaked0">0 ${token0Name}</div>`;
    statsHTML += `<div class="stat-value" id="totalStaked1">0 ${token1Name}</div>`;
    
    statsHTML += `
            <div class="stat-label">Your Total Staked</div>
        </div>
        <div class="stat-card">
            <div class="stat-value" id="APYPercentage">0%</div>
            <div class="stat-label">Current APY</div>
        </div>
    `;
    
    container.innerHTML = statsHTML;
}

// Function to update the values
function updateStakingValues(stakedAmounts, apy) {


// Clean the string first
let rawString = currentSettingsAddresses.contractAddresses;
console.log("Original string:", rawString);

try {
// Remove any extra quotes or escape characters
rawString = rawString.replace(/^"/, '').replace(/"$/, ''); // Remove surrounding quotes
rawString = rawString.replace(/\\"/g, '"'); // Fix escaped quotes

console.log("Cleaned string:", rawString);
var tokenAddresses1;
    tokenAddresses1 = JSON.parse(rawString);
    console.log("Parsed successfully:", tokenAddresses1);
} catch (error) {
    console.error("Still can't parse:", error);
    tokenAddresses1 = rawString; 
}



var tokencheck = Address_ZEROXBTC_TESTNETCONTRACT;
var tokencheck2 = tokenAddresses['B0x'];
console.log("tokenCheck: ", tokencheck);
console.log("tokencheck2: ", tokencheck2);
// Simple string comparison (addresses as hex strings)
let currency0, currency1;

if (tokencheck.toLowerCase() < tokencheck2.toLowerCase()) {
    currency0 = tokencheck;
    currency1 = tokencheck2;
} else {
    currency0 = tokencheck2;
    currency1 = tokencheck;
}


// Handle totalStaked0 (first address)
const element0 = document.getElementById(`totalStaked0`);
if (element0) {
        const tokenName = getTokenNameFromAddress(currency0);
        element0.textContent = `${stakedAmounts[0] || '0'} ${tokenName}`;
}

// Handle totalStaked1 (second address)
const element1 = document.getElementById(`totalStaked1`);
if (element1) {
        const tokenName = getTokenNameFromAddress(currency1);
        element1.textContent = `${stakedAmounts[1] || '0'} ${tokenName}`;
    }




    const apyElement = document.getElementById('APYPercentage');
    if (apyElement) {
        apyElement.textContent = `${apy}%`;
    }
}

 
    var mockRewardTokens = [
      ];

    var mockActivePeriods = [
    ];



/**
 * Fills in the Current Reward Tokens and Active Reward Periods sections
 
    var mockRewardTokens = [
        { address: "0x742d35Cc6634C0532925a3b8D1C07E8DEa95C7C4", symbol: "REWARD" },
        { address: "0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984", symbol: "UNI" },
        { address: "0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9", symbol: "AAVE" }
    ];

    var mockActivePeriods = [
        { token: "REWARD", startTime: "2023-05-15", endTime: "2023-06-15", totalRewards: "10,000 REWARD" },
        { token: "UNI", startTime: "2023-05-20", endTime: "2023-07-20", totalRewards: "5,000 UNI" }
    ];


 */
function populateStakingManagementData() {
    // Mock data - replace with actual data from your contract/API

    // Populate Reward Tokens
    const rewardTokensContainer = document.getElementById('rewardTokensContainer');
    const tokenSelect = document.getElementById('selectedRewardToken');
    
    if (mockRewardTokens.length === 0) {
        rewardTokensContainer.innerHTML = '<p style="color: #6c757d; font-style: italic;">No reward tokens period is over with and ready for restarting.</p>'; // Also populate the select dropdown
        tokenSelect.innerHTML = '<option value="">Select a reward token...</option>' +
            mockRewardTokens.map(token => 
                `<option value="${token.address}">${token.symbol} (${token.address})</option>`
            ).join('');
    } else {
        rewardTokensContainer.innerHTML = '<ul class="token-list">' + 
            mockRewardTokens.map(token => 
                `<li>
                    <span class="token-symbol">${token.symbol}</span>
                    <span class="token-address">${token.address}</span>
                </li>`
            ).join('') + '</ul>';
        
        // Also populate the select dropdown
        tokenSelect.innerHTML = '<option value="">Select a reward token...</option>' +
            mockRewardTokens.map(token => 
                `<option value="${token.address}">${token.symbol} (${token.address})</option>`
            ).join('');
    }

    // Populate Active Periods
    const activePeriodsContainer = document.getElementById('activePeriodsContainer');
    
    if (mockActivePeriods.length === 0) {
        activePeriodsContainer.innerHTML = '<p style="color: #6c757d; font-style: italic;">No active reward periods.</p>';
    } else {
        activePeriodsContainer.innerHTML = `
            <table class="periods-table">
                <thead>
                    <tr>
                        <th>Token</th>
                        <th>Start Date</th>
                        <th>End Date</th>
                        <th>Total Rewards</th>
                    </tr>
                </thead>
                <tbody>
                    ${mockActivePeriods.map(period => `
                        <tr>
                            <td>${period.token}</td>
                            <td>${period.startTime}</td>
                            <td>${period.endTime}</td>
                            <td>${period.totalRewards}</td>
                        </tr>
                    `).join('')}
                </tbody>
            </table>
        `;
    }
}


        let walletConnected = false;
        let userAddress = null;

        // Check if wallet was previously connected
        async function checkWalletConnection() {
        if (typeof window.ethereum !== 'undefined' && localStorage.getItem('walletConnected') === 'true') {
            try {
            const accounts = await window.ethereum.request({
                method: 'eth_accounts'
            });

            if (accounts.length > 0) {
                await connectWallet();
            }
            } catch (error) {
            console.error('Error checking wallet connection:', error);
            }
        }
        }

            let provider = "";
            let signer =  "";
        async function connectWallet() {
            console.log("ConnectWallet");
        if (walletConnected) {
            console.log('Wallet already connected');
            return userAddress;
        }

        if (typeof window.ethereum === 'undefined') {
            alert('Please install MetaMask or Rabby wallet!');
            return null;
        }

        try {
            const accounts = await window.ethereum.request({
            method: 'eth_requestAccounts'
            });

            if (accounts.length > 0) {
            userAddress = accounts[0];
            walletConnected = true;
            

            // Switch to Base Sepolia network
            await switchToBaseSepolia();

            localStorage.setItem('walletConnected', 'true');
            localStorage.setItem('walletAddress', userAddress);
            
            provider = new ethers.providers.Web3Provider(window.ethereum);
            signer = provider.getSigner();

            updateWalletUI(userAddress, true);
            
            // Set up event listeners for account changes
            setupWalletListeners();
            await fetchBalances();


                       await getTokenIDsOwnedByMetamask();
                        await getRewardStats();
    await checkAdminAccess();

await loadPositionsIntoDappSelections();

            throttledGetSqrtRtAndPriceRatio("ConnectWallet");

    const toggle = document.getElementById('#settings toggle1');
    if(toggle1.checked){
        console.log ("contractAddresses MATCH ");
       await restoreDefaultAddressesfromContract();
    }



            return userAddress;
            }
        } catch (error) {
            handleWalletError(error);
            return null;
        }
        }



// Alternative approach - always try to add first, then switch
async function switchToBaseSepolia() {
    const baseSepoliaConfig = {
        chainId: '0x14A34', // 84532 in hex
        chainName: 'Base Sepolia',
        nativeCurrency: {
            name: 'Ethereum',
            symbol: 'ETH',
            decimals: 18
        },
        rpcUrls: ['https://sepolia.base.org'],
        blockExplorerUrls: ['https://sepolia.basescan.org/']
    };
    
    try {
        // Try to add the network first (this will do nothing if it already exists)
        await window.ethereum.request({
            method: 'wallet_addEthereumChain',
            params: [baseSepoliaConfig]
        });
        console.log('Base Sepolia network added/confirmed');
        
        // Then switch to it
        await window.ethereum.request({
            method: 'wallet_switchEthereumChain',
            params: [{ chainId: baseSepoliaConfig.chainId }]
        });
        console.log('Switched to Base Sepolia network');
        
    } catch (error) {
        console.error('Error with Base Sepolia network:', error);
        throw new Error(`Failed to setup Base Sepolia network: ${error.message}`);
    }
}

var totalLiquidityInStakingContract =0;

async function getRewardStats(){

//    function getRewardOwedStats() public returns(address[] memory rewardTokenAddresses, uint256[] memory rewardsOwed, string[] memory tokenSymbols, string[] memory tokenNames, uint8[] memory tokenDecimals, uint[] memory tokenRewardRates, uint[] memory tokenPeriodEndsAt) {
//Gets user rewardsOwed, gets symbol, decimals, names and addresses of all


                        const getRewardStatsABI = [{
                                "inputs": [],
                                "name": "getRewardOwedStats",
                                "outputs": [
                                    {
                                    "internalType": "address[]",
                                    "name": "rewardTokenAddresses",
                                    "type": "address[]"
                                    },
                                    {
                                    "internalType": "uint256[]",
                                    "name": "rewardsOwed",
                                    "type": "uint256[]"
                                    },
                                    {
                                    "internalType": "string[]",
                                    "name": "tokenSymbols",
                                    "type": "string[]"
                                    },
                                    {
                                    "internalType": "string[]",
                                    "name": "tokenNames",
                                    "type": "string[]"
                                    },
                                    {
                                    "internalType": "uint8[]",
                                    "name": "tokenDecimals",
                                    "type": "uint8[]"
                                    },
                                    {
                                    "internalType": "uint256[]",
                                    "name": "tokenRewardRates",
                                    "type": "uint256[]"
                                    },
                                    {
                                    "internalType": "uint256[]",
                                    "name": "tokenPeriodEndsAt",
                                    "type": "uint256[]"
                                    }
                                ],
                                "stateMutability": "view",
                                "type": "function"
                                },{
                                    "inputs": [],
                                    "name": "totalSupply",
                                    "outputs": [
                                        {
                                        "internalType": "uint256",
                                        "name": "",
                                        "type": "uint256"
                                        }
                                    ],
                                    "stateMutability": "view",
                                    "type": "function"
                                    },
                                    {
                                        "inputs": [],
                                        "name": "duration_of_rewards",
                                        "outputs": [
                                            {
                                            "internalType": "uint64",
                                            "name": "",
                                            "type": "uint64"
                                            }
                                        ],
                                        "stateMutability": "view",
                                        "type": "function"
                                        }
                        ];





                 var   LPRewarsdStakingContract = new ethers.Contract(
                        contractAddressLPRewardsStaking, // your tokenSwapper contract address
                        getRewardStatsABI,
                        signer // Use signer since the function isn't view/pure
                    );

        const resultDuration = await LPRewarsdStakingContract.duration_of_rewards();
        const result = await LPRewarsdStakingContract.getRewardOwedStats();
                          
          var rewardAddressesStaking = result[0];
          var rewardsOwed = result[1];
          var rewardtokenSymbols = result[2];
          var rewardtokenNames = result[3];
          var rewardtokenDecimals = result[4];
          var rewardtokenRewardRate = result[5];
          var rewardtokenPeriodEndsAt = result[6];


          console.log("getRewardOwedStats STATS BELOWWWWWWWWWWWW getRewardOwedStats");


          console.log("Reward Address: ", rewardAddressesStaking);

          console.log("rewardsOwed: ", rewardsOwed.toString());

          console.log("rewardtokenSymbols: ", rewardtokenSymbols);

          console.log("rewardtokenNamess: ", rewardtokenNames);

          console.log("rewardtokenDecimals: ", rewardtokenDecimals.toString());
          console.log("rewardtokenRewardRate: ", rewardtokenRewardRate.toString());
          console.log("rewardtokenPeriodEndsAt: ", rewardtokenPeriodEndsAt.toString());


/*
            rewardsAmount.textContent = '15.67 STAKE';
            rewardsUSD.textContent = '≈ $31.34 USD';
    var mockRewardTokens = [
        { address: "0x742d35Cc6634C0532925a3b8D1C07E8DEa95C7C4", symbol: "REWARD" },
        { address: "0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984", symbol: "UNI" },
        { address: "0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9", symbol: "AAVE" }
    ];

    var mockActivePeriods = [
        { token: "REWARD", startTime: "2023-05-15", endTime: "2023-06-15", totalRewards: "10,000 REWARD" },
        { token: "UNI", startTime: "2023-05-20", endTime: "2023-07-20", totalRewards: "5,000 UNI" }
    ];
*/

//resets the mocks to nothgin before population
mockActivePeriods= [];
mockRewardTokens= [];
rewardsAmount.textContent = '';
rewardsUSD.textContent = '';
 currentSettingsAddresses.contractAddresses


// Clean the string first
let rawString = currentSettingsAddresses.contractAddresses;
console.log("Original string:", rawString);

try {
// Remove any extra quotes or escape characters
rawString = rawString.replace(/^"/, '').replace(/"$/, ''); // Remove surrounding quotes
rawString = rawString.replace(/\\"/g, '"'); // Fix escaped quotes

console.log("Cleaned string:", rawString);
var tokenAddresses1;

    tokenAddresses1 = JSON.parse(rawString);
    console.log("Parsed successfully:", tokenAddresses1);
} catch (error) {
    console.error("Still can't parse:", error);
    tokenAddresses1 = rawString; 
}

var Rewardduration = parseFloat(resultDuration.toString()); //300 seconds
console.log("Reward Duration is how many seconds = ", Rewardduration);
            for(var x=0; x<rewardAddressesStaking.length; x++){
                console.log("X = ", x);
                const timestamp = rewardtokenPeriodEndsAt[x].toString();
                const date = new Date(timestamp * 1000); // Convert to milliseconds
                console.log(date.toLocaleDateString()); // "1/1/2025" (format varies by locale)
                var rewardtokenPeriodEndsAtDate = date.toLocaleDateString();

                // Subtract 45 days to get start date
                var startDate = new Date(date);
                startDate.setDate(startDate.getDate() - 45);
                var rewardtokenPeriodStartsAtDate = startDate.toLocaleDateString();
                console.log("Starts at Date: ",rewardtokenPeriodStartsAtDate, " end at Date: ", rewardtokenPeriodEndsAtDate);

                var rewardRate = rewardtokenRewardRate[x];
                var fortyfivedays = toBigNumber(Rewardduration); // make duration 45*24*60*60 when in production
                var rewardsFor45Days = fortyfivedays.mul(rewardRate);
                console.log("Total Rewards for 45 days = ", rewardsFor45Days);
                var rewardAddress = rewardAddressesStaking[x];
                const addressIndex = tokenAddresses1 ? tokenAddresses1.indexOf(rewardAddress) : -1;

                console.log("AddressOfReward = ", rewardAddress);
                var rewardSymbol = rewardtokenSymbols[x];
                console.log("Symbol of Reward = ", rewardSymbol);
                var totRewardsString = parseFloat(rewardsFor45Days.toString()).toFixed(6) + " " + rewardSymbol;
                var rewardsOwedNow = rewardsOwed[x];

                
                var tknDecimals = rewardtokenDecimals[x];
                            // Convert BigNumber to human-readable format first, then apply toFixed
                var humanReadableAmount = ethers.utils.formatUnits(rewardsFor45Days, tknDecimals);
                var totRewardsString = parseFloat(humanReadableAmount).toFixed(6) + " " + rewardSymbol;
                console.log("Rewards for 45 days = ", totRewardsString);

                    var humanReadableAmount2 = ethers.utils.formatUnits(rewardsOwedNow, tknDecimals);
                var totRewardsString2 = parseFloat(humanReadableAmount2).toFixed(6) + " " + rewardSymbol;
                if(x==0){
                                        rewardsAmount.innerHTML = totRewardsString2;

                }else{
                    rewardsAmount.innerHTML = rewardsAmount.innerHTML + "<br>" + totRewardsString2;
                }
                // If you still have access to the original timestamp value
                    const timestampEND = parseFloat(rewardtokenPeriodEndsAt[x].toString());
                    const endDateTimestamp = timestampEND * 1000; // Convert to milliseconds

                    if(endDateTimestamp < Date.now()){
                        console.log("PERIOD ENDED FOR : ", rewardSymbol, " ",rewardAddress);
                        
                      mockRewardTokens.push({
                        address: rewardAddress,
                        symbol: rewardSymbol
                        });


                    }


                    mockActivePeriods.push({
                    token: rewardSymbol,
                    startTime: rewardtokenPeriodStartsAtDate,
                    endTime: rewardtokenPeriodEndsAtDate,
                    totalRewards: totRewardsString
                    });

            }


        const result2 = await LPRewarsdStakingContract.totalSupply();
                  totalLiquidityInStakingContract = result2;      
                  
                  console.log("totalLiquidityInStakingContract called! result = ",totalLiquidityInStakingContract.toString());
            populateStakingManagementData();
}

























        function handleWalletError(error) {
            console.error('Wallet connection error:', error);
            
            switch (error.code) {
                case 4001:
                alert('Please approve the connection request in your wallet');
                break;
                case -32002:
                alert('Connection request is already pending. Please check your wallet');
                break;
                default:
                alert('Failed to connect wallet: ' + error.message);
            }
        }

        function disconnectWallet() {
            walletConnected = false;
            userAddress = null;
            
            localStorage.removeItem('walletConnected');
            localStorage.removeItem('walletAddress');
            
            // Reset UI
            const connectBtn = document.getElementById('connectBtn');
            if (connectBtn) {
                connectBtn.textContent = 'Connect Wallet';
                connectBtn.classList.remove('connected');
            }
            updateWalletUI("",true);


        }

        function setupWalletListeners() {
        if (window.ethereum) {
            // Handle account changes
            window.ethereum.on('accountsChanged', (accounts) => {
            if (accounts.length === 0) {
                disconnectWallet();
            } else {
                userAddress = accounts[0];
                updateWalletUI(userAddress, true);
                fetchBalances();
            }
            });

            // Handle network changes
            window.ethereum.on('chainChanged', (chainId) => {
            console.log('Network changed to:', chainId);
            // Optionally reload the page or update UI
            });
        }
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            
    setTimeout(() => {
document.querySelector('#stakeincrease #tokenAAmount').value = '0';
document.querySelector('#stakeincrease #tokenBAmount').value = '0';
    }, 500); // Wait for your init code to finish
        checkWalletConnection();
        });
    

        function updateWalletUI(userAddress, walletName) {
            // Get the elements
            const connectBtn = document.getElementById('connectBtn');
            const walletInfo = document.getElementById('walletInfo');
            const walletAddressSpan = document.querySelector('#walletInfo #walletAddress');
            
                if (userAddress) {   
                        // Shorten the address for display (first 6 + last 4 characters)
                        const shortAddress = `${userAddress.slice(0, 6)}...${userAddress.slice(-4)}`;
                        
                        // Create the BaseScan URL
                        const baseScanUrl = `https://sepolia.basescan.org/address/${userAddress}`;
                        
                        // Update the span with a clickable link that fills the entire button
                        walletAddressSpan.innerHTML = `<a href="${baseScanUrl}" target="_blank" rel="noopener noreferrer">${shortAddress}</a>`;
                        
                        // Show the wallet info div
                        walletInfo.style.display = 'block';
                        
                        // Update connect button
                        connectBtn.textContent = `Connected (${walletName || 'Wallet'})`;
                        connectBtn.classList.add('connected');
                        
                        // Optional: Add title attribute for full address on hover
                        walletAddressSpan.title = userAddress;
                    } else {
                // Hide wallet info if no address
                walletInfo.style.display = 'none';
                connectBtn.textContent = 'Connect Wallet';
                connectBtn.classList.remove('connected');
            }
        }





        function updateTokenIcon(selectId, iconId) {
            const select = document.getElementById(selectId);
            const icon = document.getElementById(iconId);
            const selectedValue = select.value;
            
            // Map token symbols to their first letter
            const tokenIcons = {
                'ETH': 'E',
                'USDC': 'U',
                'DAI': 'D',
                'WBTC': 'W'
            };
            
            icon.textContent = tokenIcons[selectedValue] || selectedValue.charAt(0);
        }













































        function switchTab(tabName) {
            // Hide all pages
            const pages = document.querySelectorAll('.page');
            pages.forEach(page => page.classList.remove('active'));
            
            // Remove active class from all tabs
            const tabs = document.querySelectorAll('.nav-tab');
            tabs.forEach(tab => tab.classList.remove('active'));
            
            // Show selected page
            document.getElementById(tabName).classList.add('active');
            
            // Add active class to clicked tab
            event.target.classList.add('active');
        }







            function updateTokenIconCreate() {
                const formGroups = document.querySelectorAll('#create .form-group');
                
                formGroups.forEach(group => {
                    const label = group.querySelector('label');
                    const select = group.querySelector('select');
                    const icon = group.querySelector('.token-icon');
                    
                    if (label && select && icon) {
                        const labelText = label.textContent;
                        if (labelText === 'Token A' || labelText === 'Token B') {
                            const selectedValue = select.value;
                            
                            const tokenIcons = {
                                'ETH': 'E',
                                'USDC': 'U',
                                'DAI': 'D',
                                'WBTC': 'W'
                            };
                            
                            icon.textContent = tokenIcons[selectedValue] || selectedValue.charAt(0);
                        }
                    }
                });

                            filterTokenOptionsCreate();
            }

            // Add event listeners when page loads
            document.addEventListener('DOMContentLoaded', function() {
                const createSelects = document.querySelectorAll('#create .token-selector select');
                createSelects.forEach(select => {
                    select.addEventListener('change', updateTokenIconCreate);
                });
            });







var positionData = {};

// Staking position data structure
var stakingPositionData = {};




/* FILL IN OLD DATA Position data structure
var positionData = {
    "position_1": {
        id: "position_1",
        pool: "ETH/USDC",
        feeTier: "0.30%",
        tokenA: "ETH",
        tokenB: "USDC",
        currentLiquidity: 1250.00,
        currentTokenA: 1.00,
        currentTokenB: 2000.00,
        unclaimedFeesTokenA: 12.50,
        unclaimedFeesTokenB: 12.50,
        tokenAIcon: "E",
        tokenBIcon: "U"
    },
    "position_2": {
        id: "position_2",
        pool: "DAI/USDC",
        feeTier: "0.05%",
        tokenA: "DAI",
        tokenB: "USDC",
        currentLiquidity: 850.00,
        currentTokenA: 2000.00,
        currentTokenB: 2000.00,
        unclaimedFeesTokenA: 12.50,
        unclaimedFeesTokenB: 12.50,
        tokenAIcon: "D",
        tokenBIcon: "U"
    },
    "position_3": {
        id: "position_3",
        pool: "WBTC/ETH",
        feeTier: "0.30%",
        tokenA: "WBTC",
        tokenB: "ETH",
        currentLiquidity: 2100.00,
        currentTokenA: 1.00,
        currentTokenB: 50.00,
        unclaimedFeesTokenA: 12.50,
        unclaimedFeesTokenB: 12.50,
        tokenAIcon: "W",
        tokenBIcon: "E"
    },
    "position_4": {
        id: "position_4",
        pool: "ETH/B0x",
        feeTier: "0.30%",
        tokenA: "ETH",
        tokenB: "B0x",
        currentLiquidity: 100.00,
        currentTokenA: 1.00,
        currentTokenB: 2000.00,
        unclaimedFeesTokenA: 0.12,
        unclaimedFeesTokenB: 212.50,
        tokenAIcon: "E",
        tokenBIcon: "B"
    },
    "position_5": {
        id: "position_5",
        pool: "0xBTC/B0x",
        feeTier: "10.00%",
        tokenA: "0xBTC",
        tokenB: "B0x",
        currentLiquidity: 100.00,
        currentTokenA: 1.00,
        currentTokenB: 2000.00,
        unclaimedFeesTokenA: 0.12,
        unclaimedFeesTokenB: 212.50,
        tokenAIcon: "0",
        tokenBIcon: "B"
    },
    "position_6": {
        id: "position_6",
        pool: "B0x/0xBTC",
        feeTier: "10.00%",
        tokenA: "B0x",
        tokenB: "0xBTC",
        currentLiquidity: 100.00,
        currentTokenA: "2000.000000000001234578",
        currentTokenB: "1.00000070",
        unclaimedFeesTokenA:  "212.000000000005555578",
        unclaimedFeesTokenB: "0.10000012",
        tokenAIcon: "B",
        tokenBIcon: "0"
    }
};

// Staking position data structure
var stakingPositionData = {
    "stake_position_1": {
        id: "stake_position_1",
        pool: "ETH/USDC",
        feeTier: "0.30%",
        tokenA: "ETH",
        tokenB: "USDC",
        currentLiquidity: 1250.00,
        currentTokenA: 1.00,
        currentTokenB: 2000.00,
        PenaltyForWithdraw: "10%",
        apy: "8.75%",
        tokenAIcon: "E",
        tokenBIcon: "U"
    },
    "stake_position_2": {
        id: "stake_position_2",
        pool: "DAI/USDC",
        feeTier: "0.05%",
        tokenA: "DAI",
        tokenB: "USDC",
        currentLiquidity: 850.00,
        currentTokenA: 2000.00,
        currentTokenB: 2000.00,
        PenaltyForWithdraw: "10%",
        apy: "12.1%",
        tokenAIcon: "D",
        tokenBIcon: "U"
    },
    "stake_position_3": {
        id: "stake_position_3",
        pool: "WBTC/ETH",
        feeTier: "0.30%",
        tokenA: "WBTC",
        tokenB: "ETH",
        currentLiquidity: 2100.00,
        currentTokenA: 1.00,
        currentTokenB: 50.00,
        PenaltyForWithdraw: "10%",
        apy: "5.2%",
        tokenAIcon: "W",
        tokenBIcon: "E"
    },
    "stake_position_4": {
        id: "stake_position_4",
        pool: "0xBTC/B0x",
        feeTier: "0.30%",
        tokenA: "0xBTC",
        tokenB: "B0x",
        currentLiquidity: 100.00,
        currentTokenA: 1.00000070,
        currentTokenB: 2000.000000000001234578,
        PenaltyForWithdraw: "10%",
        apy: "11.2%",
        tokenAIcon: "0",
        tokenBIcon: "B"
    }
};
*/


 function updatePositionInfoMAIN_STAKING() {
    const positionSelect = document.querySelector('#staking-main-page select');
    const selectedPositionId = positionSelect.value;
    const position = positionData[selectedPositionId];
    
    if (!position) return;
    
    
    console.log("updatePositionInfoMAIN_STAKING");
    var positionLiq = parseFloat(position.currentLiquidity);
    var percentOfStaking = positionLiq/(parseFloat(totalLiquidityInStakingContract.toString())+positionLiq);

document.getElementById('estimatedRewards').value = percentOfStaking.toFixed(6)*100 + "%";


    const infoCard = document.querySelector('#staking-main-page .info-card2');
    infoCard.innerHTML = `<h3>Current Selected Position</h3>
        <p><strong>Pool:</strong> ${position.pool} (${position.feeTier})</p>
        <p><strong>Current Liquidity:</strong> ${position.currentLiquidity.toFixed(2)}</p>
        <p><strong>Total Liquidity:</strong> ${parseFloat(position.currentTokenA).toFixed(4)} ${position.tokenA} & ${parseFloat(position.currentTokenB).toFixed(4)} ${position.tokenB}</p>

    `;
    


}



 function updatePositionInfoMAIN_UNSTAKING() {
    console.log('staking-main-page:', document.querySelector('#staking-main-page'));
console.log('form-group2:', document.querySelector('#staking-main-page .form-group2'));
console.log('select:', document.querySelector('#staking-main-page .form-group2 select'));
    const positionSelect = document.querySelector('#staking-main-page .form-group2 select');
    const selectedPositionId = positionSelect.value;
    const position = stakingPositionData[selectedPositionId];
    if (!position) return;


    console.log("Success position: ",position);
    

    const infoCard = document.querySelector('#staking-main-page .info-card');

    console.log('Found info-car12313213d2:', infoCard);
    
    infoCard.innerHTML = `<h3>Current Selected Position</h3>
        <p><strong>Pool:</strong> ${position.pool} (${position.feeTier})</p>
        <p><strong>Current Liquidity:</strong> ${position.currentLiquidity.toFixed(2)}</p>
        <p><strong>Total Liquidity:</strong> ${parseFloat(position.currentTokenA).toFixed(4)} ${position.tokenA} & ${parseFloat(position.currentTokenB).toFixed(4)} ${position.tokenB}</p>

        <p style="font-weight: bold; font-size: 2em; color: red;"><strong>Penalty for Early Stake Withdrawl:</strong> ${position.PenaltyForWithdraw}</p>    `;
    


}

function updatePositionInfo() {
    const positionSelect = document.querySelector('#increase select');
    const selectedPositionId = positionSelect.value;
    const position = positionData[selectedPositionId];
    
    if (!position) return;
    
    // Update current position info card
    const infoCard = document.querySelector('#increase .info-card:nth-child(4)');
    infoCard.innerHTML = `
        <h3>Current Selected Position</h3>
        <p><strong>Pool:</strong> ${position.pool} (${position.feeTier})</p>
        <p><strong>Current Liquidity:</strong> ${position.currentLiquidity.toFixed(2)}</p>
        <p><strong>Total Liquidity:</strong> ${parseFloat(position.currentTokenA).toFixed(4)} ${position.tokenA} & ${parseFloat(position.currentTokenB).toFixed(4)} ${position.tokenB}</p>

        <p><strong>Unclaimed Fees:</strong> ${parseFloat(position.unclaimedFeesTokenA).toFixed(4)} ${position.tokenA} & ${parseFloat(position.unclaimedFeesTokenB).toFixed(4)} ${position.tokenB}</p>

    `;
    // Clear input values when position changes
    const inputs = document.querySelectorAll('#increase input[type="number"]');
    inputs.forEach(input => input.value = '0');
    updateTotalLiqIncrease();
    
}

function updateTotalLiqIncrease() {
    const positionSelect = document.querySelector('#increase select');
    const selectedPositionId = positionSelect.value;
    const position = positionData[selectedPositionId];
            if (!position) return;
            


            
            // Just directly update each span - much cleaner!
            const tokenASpan = document.querySelector('#increase #tokenALabel');
            const tokenBSpan = document.querySelector('#increase #tokenBLabel');
            
            if (tokenASpan) {
                tokenASpan.textContent = position.tokenA;
                console.log(`Set tokenALabel to: ${position.tokenA}`);
            }
            
            if (tokenBSpan) {
                tokenBSpan.textContent = position.tokenB;
                console.log(`Set tokenBLabel to: ${position.tokenB}`);
            }
            
            // Get input values
            let inputTokenA = 0;
            let inputTokenB = 0;
            
            const tokenAInput = document.querySelector('#increase #tokenAAmount');
            const tokenBInput = document.querySelector('#increase #tokenBAmount');
            
            if (tokenAInput) inputTokenA = tokenAInput.value || 0;
            if (tokenBInput) inputTokenB = tokenBInput.value || 0;
            
            console.log(`Final values: ${position.tokenA}=${inputTokenA}, ${position.tokenB}=${inputTokenB}`);
            console.log(`Final values position wise: ${position.tokenA}=${position.currentTokenA}, ${position.tokenB}=${position.currentTokenB}`);
                       var maxAmountA = addWithPrecision(position.currentTokenA,inputTokenA,tokenAddressesDecimals[position.tokenA]);
                        var maxAmountB =  addWithPrecision(position.currentTokenB,inputTokenB,tokenAddressesDecimals[position.tokenB]);
            console.log("Output maxAmountA: ", maxAmountA.toString());
            console.log("Output maxAmountB: ", maxAmountB.toString());
            // Update total liquidity
            const totalLiquidityInput = document.querySelector('#increase input[readonly]');
            if (totalLiquidityInput) {
                console.log("MaxAmount B: maxAmountB: ", maxAmountB);
                totalLiquidityInput.value = `${(maxAmountA).toString()} ${position.tokenA} &23 ${(maxAmountB).toString()} ${position.tokenB}`;
            }


   }





function updateTotalLiqIncreaseSTAKING(){

    const positionSelect = document.querySelector('#stakeincrease select');
    const selectedPositionId = positionSelect.value;
    const position = stakingPositionData[selectedPositionId];
    console.log("Postion Staking Udpate Liq: ", position);
    if (!position) return;
    var x=0;
    var inputTokenA = 0;
    var inputTokenB = 0;
    // Update form labels and placeholders
    const formGroups = document.querySelectorAll('#stakeincrease .form-row .form-group');
    formGroups.forEach(group => {
        const label = group.querySelector('label');
        const input = group.querySelector('input'); // Get the input element

        // Get the input value
        if (input) {
            const inputValue = input.value;
            console.log("input value is: ",inputValue);
            console.log(`${label?.textContent}: ${inputValue}`);
          if(x==0){
                inputTokenA = parseFloat(inputValue) || 0; // Convert to number
            } else {
                inputTokenB = parseFloat(inputValue) || 0; // Convert to number
            }
            // Or do something with the value
            // someFunction(inputValue);
        }
        x = x+1;
    });
    
    // Update new total liquidity field
    const totalLiquidityInput = document.querySelector('#stakeincrease input[readonly]');
    totalLiquidityInput.value = `${(parseFloat(position.currentTokenA)+parseFloat(inputTokenA)).toFixed(4)} ${position.tokenA} &123 ${(parseFloat(position.currentTokenB)+parseFloat(inputTokenB)).toFixed(4)} ${position.tokenB}`;

}

function updateStakePositionInfo() {
    const positionSelect = document.querySelector('#stakeincrease select');
    const selectedPositionId = positionSelect.value;
    const position = stakingPositionData[selectedPositionId];
    console.log("Staked Position: ", position);
    if (!position) return;
    
    // Update current position info card
    const infoCard = document.querySelector('#stakeincrease .info-card:nth-child(4)');
    infoCard.innerHTML = `
        <h3>Current Selected Position</h3>
        <p><strong>Pool:</strong> ${position.pool} (${position.feeTier})</p>
        <p><strong>Current Liquidity:</strong> ${position.currentLiquidity.toFixed(2)}</p>
        <p><strong>Total Liquidity:</strong> ${parseFloat(position.currentTokenA).toFixed(4)} ${position.tokenA} & ${parseFloat(position.currentTokenB).toFixed(4)} ${position.tokenB}</p>

        <p><strong>APY:</strong> ${position.apy}</p>
    `;



            // Just directly update each span - much cleaner!
            const tokenASpan = document.querySelector('#stakeincrease #tokenALabelINC');
            const tokenBSpan = document.querySelector('#stakeincrease #tokenBLabelINC');
            console.log("TokenASpan: ", tokenASpan);
            if (tokenASpan) {
                tokenASpan.textContent = position.tokenA;
                console.log(`Set tokenALabel to: ${position.tokenA}`);
            }
            
            if (tokenBSpan) {
                tokenBSpan.textContent = position.tokenB;
                console.log(`Set tokenBLabel to: ${position.tokenB}`);
            }
    
    
    // Update new total liquidity field
    const totalLiquidityInput = document.querySelector('#stakeincrease input[readonly]');
    totalLiquidityInput.value = `$#${parseFloat(position.currentTokenA).toFixed(4)} ${position.tokenA} & ${parseFloat(position.currentTokenB).toFixed(4)} ${position.tokenB};
    `
    // Clear input values when position changes
    const inputs = document.querySelectorAll('#stakeincrease input[type="number"]');
    inputs.forEach(input => input.value = '0');
}


function updateDecreasePositionInfo() {
    const positionSelect = document.querySelector('#decrease select');
    const selectedPositionId = positionSelect.value;
    const position = positionData[selectedPositionId];
    
    if (!position) return;
    
    // Update position details info card
    const infoCard = document.querySelector('#decrease .info-card:nth-child(3)');
    infoCard.innerHTML = `
        <h3>Position Details</h3>
        <p><strong>Pool:</strong> ${position.pool} (${position.feeTier})</p>
        <p><strong>Total Liquidity:</strong> ${position.currentLiquidity.toFixed(2)}</p>
        <p><strong>Total Liquidity:</strong> ${parseFloat(position.currentTokenA).toFixed(4)} ${position.tokenA} & ${parseFloat(position.currentTokenB).toFixed(4)} ${position.tokenB}</p>
        <p><strong>Unclaimed Fees:</strong> ${parseFloat(position.unclaimedFeesTokenA).toFixed(4)} ${position.tokenA} & ${parseFloat(position.unclaimedFeesTokenB).toFixed(4)} ${position.tokenB}</p>
    `;
    

            // Just directly update each span - much cleaner!
            const tokenASpan = document.querySelector('#decrease #tokenALabel');
            const tokenBSpan = document.querySelector('#decrease #tokenBLabel');
            
            if (tokenASpan) {
                tokenASpan.textContent = position.tokenA;
                console.log(`Set tokenALabel to: ${position.tokenA}`);
            }
            
            if (tokenBSpan) {
                tokenBSpan.textContent = position.tokenB;
                console.log(`Set tokenBLabel to: ${position.tokenB}`);
            }
            
    // Update fees to claim field
const feesInput = Array.from(document.querySelectorAll('#decrease .form-group'))
    .find(group => group.querySelector('label')?.textContent === 'Fees to Claim')
    ?.querySelector('input');    console.log("fees input: ", feesInput);
    if (feesInput) {
        console.log("changing fee input!");
        console.log("position.unclaimedFeesTokenA: ", position.unclaimedFeesTokenA);
        console.log("position.unclaimedFeesTokenB: ", position.unclaimedFeesTokenB);
        
        feesInput.value = `${position.unclaimedFeesTokenA} ${position.tokenA} & ${position.unclaimedFeesTokenB} ${position.tokenB}`;
        
        console.log("changing fee input! feeInput.value = ", feesInput.value);
    }
    // Force recalculate amounts with current percentage
    const slider = document.querySelector('#decrease .slider');
    if (slider) {
        // Trigger the calculation manually
        const percentage = parseFloat(slider.value) / 100;
        const removeAmount = percentage;
        
        // Calculate token amounts (simplified - in reality would depend on current pool ratios)
        const tokenAAmount = position.currentTokenA * removeAmount;
        const tokenBAmount = position.currentTokenB * removeAmount;
        
        const tokenInputs = document.querySelectorAll('#decrease .form-row input');
        tokenInputs[0].value = `${(tokenAAmount).toFixed(6)} ${position.tokenA}`;
        tokenInputs[1].value = `${(tokenBAmount).toFixed(6)} ${position.tokenB}`;
        console.log("TokenAAmount: ", tokenAAmount);
        /* Update token receive inputs with correct formatting
        const tokenInputs = document.querySelectorAll('#decrease .form-row input');
        if (tokenInputs.length >= 2) {
            // Format TokenA based on token type
            if (position.tokenA === 'ETH' || position.tokenA === 'WBTC') {
                tokenInputs[0].value = `${(tokenAAmount / 2000).toFixed(6)} ${position.tokenA}`;
            } else {
                tokenInputs[0].value = `${tokenAAmount.toFixed(2)} ${position.tokenA}`;
            }
            
            // Format TokenB based on token type
            if (position.tokenB === 'ETH' || position.tokenB === 'WBTC') {
                tokenInputs[1].value = `${(tokenBAmount / 2000).toFixed(6)} ${position.tokenB}`;
            } else {
                tokenInputs[1].value = `${tokenBAmount.toFixed(2)} ${position.tokenB}`;
            }
        }
            */
    }
}


function updateStakeDecreasePositionInfo() {
    const positionSelect = document.querySelector('#stake-decrease select');
    const selectedPositionId = positionSelect.value;
    const position = stakingPositionData[selectedPositionId];
    
    if (!position) return;
    
    // Update position details info card
    const infoCard = document.querySelector('#stake-decrease .info-card:nth-child(3)');
    infoCard.innerHTML = `
        <h3>Position Details</h3>
        <p><strong>Pool:</strong> ${position.pool} (${position.feeTier})</p>
        <p><strong>Total Staked:</strong> $${position.currentLiquidity.toFixed(2)}</p>
        <p><strong>Total Liquidity:</strong> ${parseFloat(position.currentTokenA).toFixed(4)} ${position.tokenA} & ${parseFloat(position.currentTokenB).toFixed(4)} ${position.tokenB}</p>

        <p><strong>APY:</strong> ${position.apy}</p>
        <p style="font-weight: bold; font-size: 2em; color: red;"><strong>Penalty for Early Stake Withdrawl:</strong> ${position.PenaltyForWithdraw}</p>        `;
    




            // Just directly update each span - much cleaner!
            const tokenASpan = document.querySelector('#stake-decrease #tokenALabelDec');
            const tokenBSpan = document.querySelector('#stake-decrease #tokenBLabelDec');
            
            if (tokenASpan) {
                tokenASpan.textContent = position.tokenA;
                console.log(`Set tokenALabel to: ${position.tokenA}`);
            }
            
            if (tokenBSpan) {
                tokenBSpan.textContent = position.tokenB;
                console.log(`Set tokenBLabel to: ${position.tokenB}`);
            }


    

    
    // Recalculate amounts with current percentage
    const slider = document.querySelector('#stake-decrease .slider');
    if (slider) {
        updateStakePercentage(slider.value);
    }
}




function updateStakePercentage(value) {
    const percentageDisplay = document.getElementById('stakePercentageDisplay');
    if (percentageDisplay) {
        percentageDisplay.textContent = value + '%';
    }
    
    // Get current position data
    const positionSelect = document.querySelector('#stake-decrease select');
    if (!positionSelect) return;
    
    const selectedPositionId = positionSelect.value;
    const position = stakingPositionData[selectedPositionId];
    
    if (!position) return;
        console.log("Value = ",value);
    const percentage = parseFloat(value) / 100;
    const removeAmount =  percentage;
    
    // Calculate token amounts (simplified - in reality would depend on current pool ratios)
        // Calculate token amounts (simplified - in reality would depend on current pool ratios)
        const tokenAAmount = position.currentTokenA * removeAmount;
        const tokenBAmount = position.currentTokenB * removeAmount;
    

        console.log("token B Amount: ", tokenBAmount);
        
        var tokenaDecimals = tokenAddressesDecimals[position.tokenA];
        console.log("TokenA decimals: ", tokenaDecimals);
        var tokenBDecimals = tokenAddressesDecimals[position.tokenB];
        console.log("TokenB decimals: ", tokenBDecimals);
    // Update token receive inputs
    const tokenInputs = document.querySelectorAll('#stake-decrease .form-row input');
    if (tokenInputs.length >= 2) { 
        console.log("Stake stuff: ", position.PenaltyForWithdraw);
      var penaltyAsNumber = parseFloat(position.PenaltyForWithdraw.replace('%', ''));
      console.log("penaltyAsNumber: ", penaltyAsNumber);
        tokenInputs[0].value = `${(((tokenAAmount*(100-penaltyAsNumber))/100)).toFixed(tokenaDecimals)} ${position.tokenA}`;
        tokenInputs[1].value = `${(((tokenBAmount*(100-penaltyAsNumber))/100)).toFixed(tokenBDecimals)} ${position.tokenB}`;
    }
}

















function updatePercentage(value) {
    const percentageDisplay = document.getElementById('percentageDisplay');
    percentageDisplay.textContent = value + '%';
    
    // Get current position data
    const positionSelect = document.querySelector('#decrease select');
    const selectedPositionId = positionSelect.value;
    const position = positionData[selectedPositionId];
    
    if (!position) return;
    console.log("Value = ",value);
    const percentage = parseFloat(value) / 100;
    const removeAmount =  percentage;
    
    // Calculate token amounts (simplified - in reality would depend on current pool ratios)
        // Calculate token amounts (simplified - in reality would depend on current pool ratios)
        const tokenAAmount = position.currentTokenA * removeAmount;
        const tokenBAmount = position.currentTokenB * removeAmount;
    

        var tokenaDecimals = tokenAddressesDecimals[position.tokenA];
        console.log("TokenA decimals: ", tokenaDecimals);
        var tokenBDecimals = tokenAddressesDecimals[position.tokenB];
        console.log("TokenB decimals: ", tokenBDecimals);
    // Update token receive inputs
    const tokenInputs = document.querySelectorAll('#decrease .form-row input');
    if (tokenInputs.length >= 2) {
      
        tokenInputs[0].value = `${(tokenAAmount).toFixed(tokenaDecimals)} ${position.tokenA}`;
        tokenInputs[1].value = `${(tokenBAmount).toFixed(tokenBDecimals)} ${position.tokenB}`;
    }
}










        // Default addresses
        const defaultAddresses = '["0x4200000000000000000000000000000000000006", "0x0000000000000000000000000000000000000000"]';


       // Store current values in memory
        let currentSettingsAddresses = {
            contractAddresses: defaultAddresses
        };

        function saveAddresses() {
            const addresses = document.getElementById('contractAddresses').value;
            try {
                // Validate JSON format
                currentSettingsAddresses.contractAddresses = addresses;
                showSuccessMessage('addressSuccess');
                console.log('Contract addresses saved:', addresses);

                // Save to localStorage
                localStorage.setItem('stakingRewardAddresses', JSON.stringify(currentSettingsAddresses.contractAddresses));
                updateStakingStats();
               // updateStakingValues(['1.0120213', '15.000'], '8.75');
            } catch (error) {
                alert('Invalid JSON format. Please check your address format.');
            }
        }

        function restoreDefaultAddresses() {
            document.getElementById('contractAddresses').value = defaultAddresses;
            currentSettingsAddresses.contractAddresses = defaultAddresses;
            console.log('Addresses restored to defaults');

        }

async function restoreDefaultAddressesfromContract() {
    try {
        console.log('Getting reward tokens from contract...');
        
        // Create contract with full ABI (not just single function)
        const getRewardTokensABI = [
            {
                "inputs": [],
                "name": "getRewardTokens",
                "outputs": [
                    {
                        "internalType": "address[]", // Fixed: should be address[] not IERC20[]
                        "name": "",
                        "type": "address[]"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            }
        ];
        
        tokenLPRewardsStakingContract = new ethers.Contract(
            contractAddressLPRewardsStaking,
            getRewardTokensABI,
            provider // Use provider for view functions, not signer
        );
        
        // Call the contract function
        const rewardTokens = await tokenLPRewardsStakingContract.getRewardTokens();
        
        console.log('Raw result from contract:', rewardTokens);
        
        // Convert to array of strings
        let tokenAddresses = [];
        if (Array.isArray(rewardTokens)) {
            tokenAddresses = rewardTokens.map(address => address.toString());
        } else {
            // Handle case where result might be wrapped
            tokenAddresses = [rewardTokens.toString()];
        }
        
        console.log('Parsed token addresses:', tokenAddresses);
                
        // Option 3: One-liner formatting
        const oneLineFormatted = `["${tokenAddresses.join('","')}"]`;
        // Join addresses with newlines for textarea display
        //const addressesString = tokenAddresses.join('\n');
        
        // Update the UI and settings
        document.getElementById('contractAddresses').value = oneLineFormatted;
        currentSettingsAddresses.contractAddresses = tokenAddresses; // Store as array
        
        console.log('Addresses restored from contract:', tokenAddresses);
        console.log('Addresses restored currentSettingsAddresses.contractAddresses:', currentSettingsAddresses.contractAddresses);
      
            console.log('Addresses for ERC20 restored to defaults of contract');
            } catch (e) {
            console.error('Error loading settings:', e);
            }
        }







        function restoreDefaultAddressesfromGithub() {
            /*GET CONTRACT ERC20s to put into list*/
            document.getElementById('contractAddresses').value = defaultAddresses;
            currentSettingsAddresses.contractAddresses = defaultAddresses;
            console.log('Addresses restored to defaults');
        }

        function showSuccessMessage(elementId) {
            const element = document.getElementById(elementId);
            element.style.display = 'block';
            setTimeout(() => {
                element.style.display = 'none';
            }, 3000);
        }



// Initialize when page loads
document.addEventListener('DOMContentLoaded', function() {
    
    document.getElementById('contractAddresses').value = defaultAddresses;

    // Set up position selector for regular increase
    const positionSelect = document.querySelector('#increase select');
    if (positionSelect) {
        positionSelect.innerHTML = '';
        Object.values(positionData).forEach(position => {
            const option = document.createElement('option');
            option.value = position.id;
            option.textContent = `${position.pool} - ${position.feeTier} - Position #${position.id.split('_')[1]}`;
            positionSelect.appendChild(option);
        });
        
        positionSelect.addEventListener('change', updatePositionInfo);
        positionSelect.addEventListener('change', updateTotalLiqIncrease);
        updatePositionInfo();
    }
    // Add event listeners to both inputs in the form-row
    const ethInput = document.querySelector('#increase .form-row .form-group:first-child input');
    const usdcInput = document.querySelector('#increase .form-row .form-group:last-child input');
    

    if (ethInput) {
        ethInput.addEventListener('input', updateTotalLiqIncrease);
        updateTotalLiqIncrease();
    }
    
    if (usdcInput) {
        usdcInput.addEventListener('input', updateTotalLiqIncrease);
    }


    

    const positionSelect2 = document.querySelector('#staking-main-page select');
    if (positionSelect2) {
        positionSelect2.innerHTML = '';
        Object.values(positionData).forEach(position => {
            const option = document.createElement('option');
            option.value = position.id;
            option.textContent = `${position.pool} - ${position.feeTier} - Position #${position.id.split('_')[1]}`;
            positionSelect2.appendChild(option);
        });
        
        positionSelect2.addEventListener('change', updatePositionInfoMAIN_STAKING);
        updatePositionInfoMAIN_STAKING();
    }
    
    
const positionSelectMainPageWithdrawNFT = document.querySelector('#staking-main-page .form-group2 select');
    if (positionSelectMainPageWithdrawNFT) {
        positionSelectMainPageWithdrawNFT.innerHTML = '';
        Object.values(stakingPositionData).forEach(position => {
            const option = document.createElement('option');
            option.value = position.id;
            option.textContent = `${position.pool} - ${position.feeTier} - Stake Position #${position.id.split('_')[2]}`;
            positionSelectMainPageWithdrawNFT.appendChild(option);
        });
        
        positionSelectMainPageWithdrawNFT.addEventListener('change', updatePositionInfoMAIN_UNSTAKING);
        updatePositionInfoMAIN_UNSTAKING();
    }
    
    // Set up position selector for decrease
    const decreasePositionSelect = document.querySelector('#decrease select');
    if (decreasePositionSelect) {
        decreasePositionSelect.innerHTML = '';
        Object.values(positionData).forEach(position => {
            const option = document.createElement('option');
            option.value = position.id;
            option.textContent = `${position.pool} - ${position.feeTier} - Position #${position.id.split('_')[1]}`;
            decreasePositionSelect.appendChild(option);
        });
        
        decreasePositionSelect.addEventListener('change', updateDecreasePositionInfo);
        updateDecreasePositionInfo();
    }
    
    // Set up position selector for stake increase
    const stakePositionSelect = document.querySelector('#stakeincrease select');
    if (stakePositionSelect) {
        stakePositionSelect.innerHTML = '';
        Object.values(stakingPositionData).forEach(position => {
            const option = document.createElement('option');
            option.value = position.id;
            option.textContent = `${position.pool} - ${position.feeTier} - Stake Position #${position.id.split('_')[2]}`;
            stakePositionSelect.appendChild(option);
        });
        
        stakePositionSelect.addEventListener('change', updateStakePositionInfo);
        updateStakePositionInfo();
    }
    
    // Set up position selector for stake decrease
    const stakeDecreasePositionSelect = document.querySelector('#stake-decrease select');
    if (stakeDecreasePositionSelect) {
        stakeDecreasePositionSelect.innerHTML = '';
        Object.values(stakingPositionData).forEach(position => {
            const option = document.createElement('option');
            option.value = position.id;
            option.textContent = `${position.pool} - ${position.feeTier} - Stake Position #${position.id.split('_')[2]}`;
            stakeDecreasePositionSelect.appendChild(option);
        });
        
        stakeDecreasePositionSelect.addEventListener('change', updateStakeDecreasePositionInfo);
        updateStakeDecreasePositionInfo();
    }
    
    // Set up slider for decrease section with multiple event types
    const decreaseSlider = document.querySelector('#decrease .slider');
    if (decreaseSlider) {
        decreaseSlider.addEventListener('input', function() {
            updatePercentage(this.value);
        });
        decreaseSlider.addEventListener('change', function() {
            updatePercentage(this.value);
        });
        decreaseSlider.addEventListener('mouseup', function() {
            updatePercentage(this.value);
        });
    }
    
    // Set up slider for stake decrease section with multiple event types
    const stakeDecreaseSlider = document.querySelector('#stake-decrease .slider');
    if (stakeDecreaseSlider) {
        stakeDecreaseSlider.addEventListener('input', function() {
            updateStakePercentage(this.value);
        });
        stakeDecreaseSlider.addEventListener('change', function() {
            updateStakePercentage(this.value);
        });
        stakeDecreaseSlider.addEventListener('mouseup', function() {
            updateStakePercentage(this.value);
        });
    }




    // Add event listeners to both inputs in the form-row
    const ethInput2 = document.querySelector('#stakeincrease .form-row .form-group:first-child input');
    const usdcInput2 = document.querySelector('#stakeincrease .form-row .form-group:last-child input');
    
    console.log("Eth input2: ", ethInput2);
    if (ethInput2) {
        ethInput2.addEventListener('input', updateTotalLiqIncreaseSTAKING);
        updateTotalLiqIncreaseSTAKING();
    }
    
    if (usdcInput2) {
        usdcInput2.addEventListener('input', updateTotalLiqIncreaseSTAKING);
    }


    populateStakingManagementData();

    displayWalletBalances();
  loadSettings();
  filterTokenOptionsCreate();

// Target the create section
const createSection = document.getElementById('create');
if (createSection) {
    // Get both number inputs in the create section
    const numberInputs = createSection.querySelectorAll('input[type="number"]');
    const amountAInput = numberInputs[0]; // First input (Amount A)
    const amountBInput = numberInputs[1]; // Second input (Amount B)
    
    let isUpdating = false;
    let debounceTimerA;
    let debounceTimerB;
    
    if (amountAInput) {
        amountAInput.addEventListener('input', function() {
            if (isUpdating) return; // Prevent circular updates
            
            console.log('Create section - Amount A typing:', this.value);
            
            // Clear previous timer
            clearTimeout(debounceTimerA);
            
            // Set new timer - only call function after user stops typing for 300ms
            debounceTimerA = setTimeout(() => {
                console.log('Create section - Amount A final value:', this.value);
                isUpdating = true;
                
                if (typeof getRatioCreatePositiontokenA === 'function') {
                    getRatioCreatePositiontokenA();
                } else {
                    console.log('getRatioCreatePositiontokenA function called from create section');
                }
                
                // Reset the updating flag after processing
                setTimeout(() => {
                    isUpdating = false;
                }, 50);
            }, 1200); // Wait 300ms after user stops typing
        });
    }
    
    // Similar for the other input
    if (amountBInput) {
        amountBInput.addEventListener('input', function() {
            if (isUpdating) return; // Prevent circular updates
            
            console.log('Create section - Amount B typing:', this.value);
            
            // Clear previous timer
            clearTimeout(debounceTimerB);
            
            // Set new timer - only call function after user stops typing for 300ms
            debounceTimerB = setTimeout(() => {
                console.log('Create section - Amount B final value:', this.value);
                isUpdating = true;
                
                if (typeof getRatioCreatePositiontokenB === 'function') {
                    getRatioCreatePositiontokenB();
                } else {
                    console.log('getRatioCreatePositiontokenB function called from create section');
                }
                
                // Reset the updating flag after processing
                setTimeout(() => {
                    isUpdating = false;
                }, 50);
            }, 1200); // Wait 300ms after user stops typing
        });
    }
}




let isProgrammaticUpdate = false;

let isProgrammaticUpdateB = false;

// Target the create section
const increase = document.getElementById('increase');
if (increase) {
    // Get both number inputs in the create section
    const numberInputs = increase.querySelectorAll('input[type="number"]');
    const amountAInput = numberInputs[0]; // First input (Amount A)
    const amountBInput = numberInputs[1]; // Second input (Amount B)
    
    let isUpdating = false;
    let debounceTimerA;
    let debounceTimerB;
    
    if (amountAInput) {
        amountAInput.addEventListener('input', function() {
            if (isUpdating) return; // Prevent circular updates
            
    if (isProgrammaticUpdate || isProgrammaticUpdateB) return;
            console.log('Create section - Amount A typing:', this.value);
            
            // Clear previous timer
            clearTimeout(debounceTimerA);
            
            // Set new timer - only call function after user stops typing for 300ms
            debounceTimerA = setTimeout(() => {
                console.log('Create section - Amount A final value:', this.value);
                isUpdating = true;
                
                if (typeof getRatioIncreasePositiontokenA === 'function') {
                    getRatioIncreasePositiontokenA();
                } else {
                    console.log('getRatioIncreasePositiontokenA function called from create section');
                }
                
                // Reset the updating flag after processing
                setTimeout(() => {
                    isUpdating = false;
                }, 50);
            }, 1001); // Wait 1001ms after user stops typing
        });
    }
    
    // Similar for the other input
    if (amountBInput) {
        amountBInput.addEventListener('input', function() {
            if (isUpdating) return; // Prevent circular updates
            
    if (isProgrammaticUpdate || isProgrammaticUpdateB) return;
            console.log('Create section - Amount B typing:', this.value);
            
            // Clear previous timer
            clearTimeout(debounceTimerB);
            
            // Set new timer - only call function after user stops typing for 300ms
            debounceTimerB = setTimeout(() => {
                console.log('Create section - Amount B final value:', this.value);
                isUpdating = true;
                
                if (typeof getRatioIncreasePositiontokenB === 'function') {
                    getRatioIncreasePositiontokenB();
                } else {
                    console.log('getRatioCreatePositiontokenB function called from create section');
                }
                
                // Reset the updating flag after processing
                setTimeout(() => {
                    isUpdating = false;
                }, 50);
            }, 1001); // Wait 1001ms after user stops typing
        });
    }
}





let isProgrammaticUpdateC = false;

let isProgrammaticUpdateD = false;

// Target the create section
const increaseStaking = document.getElementById('stakeincrease');
console.log("increase staking doc: ",increaseStaking);
if (increaseStaking) {
    // Get both number inputs in the create section
    const numberInputs = increaseStaking.querySelectorAll('input[type="number"]');
    const amountAInput = numberInputs[0]; // First input (Amount A)
    const amountBInput = numberInputs[1]; // Second input (Amount B)
    console
    let isUpdating = false;
    let debounceTimerC;
    let debounceTimerD;
    
    if (amountAInput) {
        amountAInput.addEventListener('input', function() {
            if (isUpdating) return; // Prevent circular updates
            
    if (isProgrammaticUpdate || isProgrammaticUpdateB) return;
            console.log('Create section - Amount A typing:', this.value);
            
            // Clear previous timer
            clearTimeout(debounceTimerC);
            
            // Set new timer - only call function after user stops typing for 300ms
            debounceTimerC = setTimeout(() => {
                console.log('Create section - Amount A final value:', this.value);
                isUpdating = true;
                
                if (typeof getRatioStakeIncreasePositiontokenA === 'function') {
                    getRatioStakeIncreasePositiontokenA();
                } else {
                    console.log('Error getRatioStakeIncreasePositiontokenA');
                }
                
                // Reset the updating flag after processing
                setTimeout(() => {
                    isUpdating = false;
                }, 50);
            }, 1001); // Wait 1001ms after user stops typing
        });
    }
    
    // Similar for the other input
    if (amountBInput) {
        amountBInput.addEventListener('input', function() {
            if (isUpdating) return; // Prevent circular updates
            
    if (isProgrammaticUpdate || isProgrammaticUpdateB) return;
            console.log('Create section - Amount B typing:', this.value);
            
            // Clear previous timer
            clearTimeout(debounceTimerD);
            
            // Set new timer - only call function after user stops typing for 300ms
            debounceTimerD = setTimeout(() => {
                console.log('Create section - Amount B final value:', this.value);
                isUpdating = true;
                
                if (typeof getRatioStakeIncreasePositiontokenB === 'function') {
                    getRatioStakeIncreasePositiontokenB();
                } else {
                    console.log('Error getRatioStakeIncreasePositiontokenB');
                }
                
                // Reset the updating flag after processing
                setTimeout(() => {
                    isUpdating = false;
                }, 50);
            }, 1001); // Wait 1001ms after user stops typing
        });
    }
}











console.log("contractAddresses value = " ,document.getElementById('contractAddresses').value);

console.log("contractAddresses defaultAddresses= " ,defaultAddresses);





});



// Helper function to format numbers without rounding
function formatExactNumber(value) {
    // If it's already a string, return as-is
    if (typeof value === 'string') {
        return value;
    }
    
    // If it's a BigInt, convert to string
    if (typeof value === 'bigint') {
        return value.toString();
    }
    
    // If it's a number, use toFixed(0) for integers or check if it needs decimal places
    if (typeof value === 'number') {
        // Check if it's a whole number
        if (Number.isInteger(value)) {
            return value.toFixed(0);
        }
        // For decimals, you might want to preserve more precision
        return value.toString();
    }
    
    return value.toString();
}

// Optional: Format with commas for better readability
function formatExactNumberWithCommas(value) {
    const exactValue = formatExactNumber(value);
    // Add commas to make large numbers more readable (10,999,900)
    return exactValue.replace(/\B(?=(\d{3})+(?!\d))/g, ',');
}

// Solution 1: Define a fixed token order (RECOMMENDED)
const TOKEN_ORDER = ['ETH', 'B0x', '0xBTC', 'USDC', 'DAI', 'WBTC'];

// Updated function with consistent ordering
function displayWalletBalances() {
    const balancesContainer = document.getElementById('walletBalancesDisplay');
    const balancesContainer2 = document.getElementById('walletBalancesDisplay2');
    const balancesContainer3 = document.getElementById('walletBalancesDisplay3');
    const balancesContainer4 = document.getElementById('walletBalancesDisplay4');
    
    if (!balancesContainer) return;
    
    // Create HTML with consistent token order
    let balancesHTML = '';
    
    // Method 1: Use predefined order
    TOKEN_ORDER.forEach(token => {
        if (walletBalances[token] !== undefined) {
            balancesHTML += `
                <div class="balance-item">
                    <span class="token-name">${token}</span>
                    <span class="token-amount">${formatExactNumber(walletBalances[token])}</span>
                </div>
            `;
        }
    });
    
    // Add any tokens not in the predefined order (in case you add new tokens)
    for (const [token, balance] of Object.entries(walletBalances)) {
        if (!TOKEN_ORDER.includes(token)) {
            balancesHTML += `
                <div class="balance-item">
                    <span class="token-name">${token}</span>
                    <span class="token-amount">${formatExactNumber(balance)}</span>
                </div>
            `;
        }
    }
    
    // Update all containers
    balancesContainer.innerHTML = balancesHTML;
    if (balancesContainer2) balancesContainer2.innerHTML = balancesHTML;
    if (balancesContainer3) balancesContainer3.innerHTML = balancesHTML;
    if (balancesContainer4) balancesContainer4.innerHTML = balancesHTML;
}


// Settings object to hold our values
const appSettings = {
  minStaking: 0,
  minUserHoldings: 0
};


/**
 * Saves the minimum staking amount to localStorage
 */
function saveMinStaking() {
  const minStakingInput = document.getElementById('minStaking');
  const value = minStakingInput.value.trim();
  
  if (!value || isNaN(value) || parseFloat(value) < 0) {
    showAlert('Please enter a valid positive number', 'error');
    return;
  }
  
  // Save to our settings object
  appSettings.minStaking = value;
  
  // Save to localStorage
  localStorage.setItem('stakingSettings', JSON.stringify(appSettings));
  
  showAlert(`Minimum staking amount set to ${value} tokens`, 'success');
}

/**
 * Saves the minimum user holdings to localStorage
 */
function saveMinUserHoldings() {
  const minHoldingsInput = document.getElementById('minUserHoldings');
  const value = minHoldingsInput.value.trim();
  
  if (!value || isNaN(value) || parseFloat(value) < 0) {
    showAlert('Please enter a valid positive number', 'error');
    return;
  }
  
  // Save to our settings object
  appSettings.minUserHoldings = value;
  
  // Save to localStorage
  localStorage.setItem('stakingSettings', JSON.stringify(appSettings));
  
  showAlert(`Minimum user holdings set to ${value} tokens`, 'success');
}

/**
 * Loads settings from localStorage and updates the form
 */
function loadSettings() {
  const savedSettings = localStorage.getItem('stakingSettings');
  const savedSettingsRewards = localStorage.getItem('stakingRewardAddresses');
  if(savedSettingsRewards){


      const setting2 = JSON.parse(savedSettingsRewards);
        console.log("setting2: ",setting2);
      // Update our appSettings object
      currentSettingsAddresses.contractAddresses = setting2 || "0xError";

            document.getElementById('contractAddresses').value = currentSettingsAddresses.contractAddresses;
  }
  if (savedSettings) {
    try {
      const settings = JSON.parse(savedSettings);
      
      // Update our appSettings object
      appSettings.minStaking = settings.minStaking || 0;
      appSettings.minUserHoldings = settings.minUserHoldings || 0;
      
      // Update the form inputs
      document.getElementById('minStaking').value = appSettings.minStaking;
      document.getElementById('minUserHoldings').value = appSettings.minUserHoldings;
      
    } catch (e) {
      console.error('Error loading settings:', e);
    }
  }else{

      appSettings.minStaking = 0;
      appSettings.minUserHoldings = 0;
  }
}

/**
 * Simple alert notification
 */
function showAlert(message, type = 'info') {
  const alertDiv = document.createElement('div');
  alertDiv.className = `alert alert-${type}`;
  alertDiv.textContent = message;
  
  const settingsPage = document.getElementById('settings');
  settingsPage.insertBefore(alertDiv, settingsPage.firstChild);
  
  setTimeout(() => alertDiv.remove(), 5000);
}




async function  collectRewards(){



            if(!walletConnected){
               await connectWallet();
            }
var ctaddy = document.getElementById('contractAddresses').value

console.log("Token Addresses: ", ctaddy);


// Clean the string first
let rawString = currentSettingsAddresses.contractAddresses;
console.log("Original string:", rawString);

try {
// Remove any extra quotes or escape characters
rawString = rawString.replace(/^"/, '').replace(/"$/, ''); // Remove surrounding quotes
rawString = rawString.replace(/\\"/g, '"'); // Fix escaped quotes

console.log("Cleaned string:", rawString);
var tokenAddresses1;
    tokenAddresses1 = JSON.parse(rawString);
    console.log("Parsed successfully:", tokenAddresses1);
} catch (error) {
    console.error("Still can't parse:", error);
    tokenAddresses1 = rawString; 
}



   const collectRewardsABI = [
                            {
                            "inputs": [
                                {
                                "internalType": "contract IERC20[]",
                                "name": "rewardTokens",
                                "type": "address[]"
                                }
                            ],
                            "name": "getRewardForTokens",
                            "outputs": [],
                            "stateMutability": "nonpayable",
                            "type": "function"
                            }
                        ];


//
                    LPStakingContract = new ethers.Contract(
                        contractAddressLPRewardsStaking, // your tokenSwapper contract address
                        collectRewardsABI,
                        signer // Use signer since the function isn't view/pure
                    );




                        const rewardTx = await LPStakingContract.getRewardForTokens(tokenAddresses1);
                        
                        console.log("Staking transaction sent:", rewardTx.hash);
                        await rewardTx.wait(); // Wait for confirmation
                        console.log("Rewards Claimed successfully!");
                        alert("Claimed Rewards SUCCESSFULLY!");
                        
                       await fetchBalances();
                        await getRewardStats();
        }













async function  depositNFTStake(){



            if(!walletConnected){
               await connectWallet();
            }


    // Get position data for unclaimed fees
    const positionSelect = document.querySelector('#staking-main-page select');
    const selectedPositionId = positionSelect.value;
    const position = positionData[selectedPositionId];

                var positionID = position.id.split('_')[1];
                console.log("Deposit this NFT ", positionID);
            var approveThisToken = positionID;
     // ABI for getAmount0andAmount1forLiquidityPercentage function
                        const depositNFTabi = [
                        {
                            "inputs": [
                            {
                                "internalType": "uint256",
                                "name": "tokenId",
                                "type": "uint256"
                            }
                            ],
                            "name": "stakeUniswapV3NFT",
                            "outputs": [],
                            "stateMutability": "nonpayable",
                            "type": "function"
                        }
                        ];
                        const approveNFTabi = [
                        {
                            "inputs": [
                            {
                                "internalType": "address",
                                "name": "to",
                                "type": "address"
                            },
                            {
                                "internalType": "uint256",
                                "name": "tokenId",
                                "type": "uint256"
                            }
                            ],
                            "name": "approve",
                            "outputs": [],
                            "stateMutability": "nonpayable",
                            "type": "function"
                        }
                        ];


//
                    LPStakingContract = new ethers.Contract(
                        contractAddressLPRewardsStaking, // your tokenSwapper contract address
                        depositNFTabi,
                        signer // Use signer since the function isn't view/pure
                    );



                    positionManagerContract = new ethers.Contract(
                        positionManager_address, // your tokenSwapper contract address
                        approveNFTabi,
                        signer // Use signer since the function isn't view/pure
                    );


                    try {
                        console.log(`Approving NFT token ${approveThisToken}...`);
                        
                        // Step 1: Approve the staking contract to transfer the NFT
                        const approveTx = await positionManagerContract.approve(
                        contractAddressLPRewardsStaking, // Address to approve (staking contract)
                        approveThisToken // Token ID to approve
                        );
                        
                        console.log("Approval transaction sent:", approveTx.hash);
                        await approveTx.wait(); // Wait for confirmation
                        console.log("Approval confirmed!");
                        
                        // Step 2: Stake the NFT
                        console.log(`Staking NFT token ${approveThisToken}...`);
                        const stakeTx = await LPStakingContract.stakeUniswapV3NFT(approveThisToken);
                        
                        console.log("Staking transaction sent:", stakeTx.hash);
                        await stakeTx.wait(); // Wait for confirmation
                        console.log("NFT staked successfully!");
                        alert("NFT STAKED SUCCESSFULLY!");
                        
                        fetchBalances();
                         await getTokenIDsOwnedByMetamask();
                        await getRewardStats();
                    } catch (error) {
                        console.error("Error approving/staking NFT:", error);
                    }

}
async function decreaseLiquidityStaking(){

    const percentageDisplay = document.getElementById('stakePercentageDisplay');
   var decreasePercentageBy =  percentageDisplay.textContent;
    console.log("decreasePercentageBy: ", decreasePercentageBy);

var decreasePercentageNumber = parseInt(decreasePercentageBy.replace('%', ''));
var percentagedivby10000000000000 = 10000000000000 * decreasePercentageNumber / 100;


            if(!walletConnected){
               await connectWallet();
            }
    
                // Get slippage tolerance
                const selectSlippage = document.getElementById('slippageToleranceStakeDecrease');
                const selectSlippageValue = selectSlippage.value; // Returns: "0.1%", "0.5%", "1.0%", or "2.0%"
                const numberValueSlippage = parseFloat(selectSlippageValue.replace('%', ''));
                // Divide by 100 to get decimal
                const decimalValueSlippage = numberValueSlippage / 100;
                
                console.log("selectSlippageValue: ", selectSlippageValue);
                console.log("decimalValueSlippage: ", decimalValueSlippage);
                
                

                const positionSelect = document.querySelector('#stake-decrease select');

                    const selectedPositionId = positionSelect.value;
                    const position = stakingPositionData[selectedPositionId];
                    if (!position) return;

                var positionID = position.id.split('_')[2];
                console.log("positionID = : ", positionID);

    
                    
                        console.log("positionID: ",positionID);


                    // ABI for getAmount0andAmount1forLiquidityPercentage function
                    const liquidityPercentageABI = [{
                        "inputs": [
                            {
                            "internalType": "uint256",
                            "name": "tokenID",
                            "type": "uint256"
                            },
                            {
                            "internalType": "uint128",
                            "name": "percentageToRemoveOutOf10000000000000",
                            "type": "uint128"
                            },
                            {
                            "internalType": "address",
                            "name": "ownerOfNFT",
                            "type": "address"
                            }
                        ],
                        "name": "getTokenAmountForPercentageLiquidity",
                        "outputs": [
                            {
                            "internalType": "uint256",
                            "name": "amount0fees",
                            "type": "uint256"
                            },
                            {
                            "internalType": "uint256",
                            "name": "amount1fees",
                            "type": "uint256"
                            },
                            {
                            "internalType": "uint256",
                            "name": "amount0",
                            "type": "uint256"
                            },
                            {
                            "internalType": "uint256",
                            "name": "amount1",
                            "type": "uint256"
                            }
                        ],
                        "stateMutability": "view",
                        "type": "function"
                        }
                    ];



//
                    LPRewardsStakingContract = new ethers.Contract(
                        contractAddressLPRewardsStaking, // your tokenSwapper contract address
                        liquidityPercentageABI,
                        signer // Use signer since the function isn't view/pure
                    );





let minAmount0Remove = 0;
let minAmount1Remove = 0;
      try {
        console.log("Percentage to remove decreaseLiquidityStaking : ", (percentagedivby10000000000000/10000000000000));
        // Call the view function
        const result = await LPRewardsStakingContract.getTokenAmountForPercentageLiquidity(positionID, percentagedivby10000000000000, userAddress);

        if(tokenAddress == position.tokenA){
          minAmount0Remove = result[2];
          minAmount1Remove = result[3];
          console.log("token0 = b0x");
          console.log("token1 = 0xbtc");


        }else{

          console.log("token0 = 0xbtc");
          console.log("token1 = b0x");
          minAmount0Remove = result[3];
          minAmount1Remove = result[2];
        }




        console.log("minRemoveAmount0 aka b0x: ", minAmount0Remove.toString());
        console.log("minRemoveAmount1 aka 0xbtc: ", minAmount1Remove.toString());
          
        } catch (error) {
          console.error(`Error finding valid getTokenAmountForPercentageLiquidity for remove Liq:`, error);
        }











                        const StakingLPRewardsABI = [{
                                "inputs": [
                                    {
                                    "internalType": "uint256",
                                    "name": "tokenID",
                                    "type": "uint256"
                                    },
                                    {
                                    "internalType": "uint128",
                                    "name": "percentageToRemoveOutOf10000000000000",
                                    "type": "uint128"
                                    },
                                    {
                                    "internalType": "uint256",
                                    "name": "minAmount0",
                                    "type": "uint256"
                                    },
                                    {
                                    "internalType": "uint256",
                                    "name": "minAmount1",
                                    "type": "uint256"
                                    }
                                ],
                                "name": "decreaseLiquidityOfPosition",
                                "outputs": [
                                    {
                                    "internalType": "bool",
                                    "name": "",
                                    "type": "bool"
                                    }
                                ],
                                "stateMutability": "nonpayable",
                                "type": "function"
                                }];




                    LPrewardsStakingContracts = new ethers.Contract(
                        contractAddressLPRewardsStaking, // your tokenSwapper contract address
                        StakingLPRewardsABI,
                        signer // Use signer since the function isn't view/pure
                    );


















     try {

// Use the slippage-adjusted amounts
const minAmount0 = calculateWithSlippageBigNumber(minAmount0Remove, decimalValueSlippage); // BigNumber
const minAmount1 = calculateWithSlippageBigNumber(minAmount1Remove, decimalValueSlippage); // BigNumber
console.log("min amount0: ",minAmount0.toString());
console.log("min amount1: ",minAmount1.toString());
//  Method 1: Using ternary operator with destructuring
const [token0, token1] = tokenAddress < Address_ZEROXBTC_TESTNETCONTRACT
    ? [tokenAddress, Address_ZEROXBTC_TESTNETCONTRACT]
    : [Address_ZEROXBTC_TESTNETCONTRACT, tokenAddress];

const [amount0remove, amount1remove] = tokenAddress < Address_ZEROXBTC_TESTNETCONTRACT
    ? [minAmount0, minAmount1]
    : [minAmount1, minAmount0];


console.log("decLiqStaking min amount0: ",amount0remove.toString(), " address: ",token0);
console.log("decLiqStaking min amount1: ",amount1remove.toString(), " address: ",token1);
        alert("Decreasing Liquidity now! Approve Transaction!");
        console.log("((((((((((((((Stats For Withdrawal))))))))))))))");
        console.log("positionID: ",positionID);
        console.log("percentagedivby10000000000000: ",percentagedivby10000000000000);
        console.log("minAmount0: ",minAmount0.toString());
        console.log("minAmount1: ",minAmount1.toString());
              const tx = await LPrewardsStakingContracts.decreaseLiquidityOfPosition(positionID, percentagedivby10000000000000, amount0remove, amount1remove,{gasLimit: 10000000});
        
      console.log("DECREASED Liquidity transaction sent:", tx.hash);
      console.log("Waiting for transaction confirmation...");
      
      // Wait for the transaction to be mined
      const receipt = await tx.wait();
      console.log("Increased Liquidity transaction confirmed in block:", receipt.blockNumber);
      console.log("REMOVED "+(percentagedivby10000000000000/10000000000000)+"% of the tokens from tokenID: "+ positionID);

        // If you want to use these values for further operations
        // For example, if there's a deploy function that uses the salt
        // await UniV4Hook.deploy(validSalt);
        fetchBalances();
        
                        await getTokenIDsOwnedByMetamask();

                        await getRewardStats();
      } catch (error) {
        console.error(`Error decrease liquidty on token`, error);
      }



console.log("Done with decrease Liq");















}

async function decreaseLiquidity(){


    const percentageDisplay = document.getElementById('percentageDisplay');
   var decreasePercentageBy =  percentageDisplay.textContent;
    console.log("decreasePercentageBy: ", decreasePercentageBy);

var decreasePercentageNumber = parseInt(decreasePercentageBy.replace('%', ''));
var percentagedivby10000 = 10000 * decreasePercentageNumber / 100;


            if(!walletConnected){
               await connectWallet();
            }
    
                // Get slippage tolerance
                const selectSlippage = document.getElementById('slippageToleranceDecrease');
                const selectSlippageValue = selectSlippage.value; // Returns: "0.1%", "0.5%", "1.0%", or "2.0%"
                const numberValueSlippage = parseFloat(selectSlippageValue.replace('%', ''));
                // Divide by 100 to get decimal
                const decimalValueSlippage = numberValueSlippage / 100;
                
                console.log("selectSlippageValue: ", selectSlippageValue);
                console.log("decimalValueSlippage: ", decimalValueSlippage);
                
                
                                // Get token types from labels within increase page
                const tokenALabel = document.querySelector('#decrease #tokenALabel');
                const tokenBLabel = document.querySelector('#decrease #tokenBLabel');

                // Get input amounts from inputs within increase page  
                const tokenAInput = document.querySelector('#decrease #tokenAAmount');
                const tokenBInput = document.querySelector('#decrease #tokenBAmount');
                // Get the token values from the label text content
                const tokenAValue = tokenALabel.textContent; // Gets "ETH"
                const tokenBValue = tokenBLabel.textContent; // Gets "USDC"
                
                console.log("Currently selected value TokenA:", tokenAValue);
                console.log("Currently selected value TokenB:", tokenBValue);
                
                
                var tokenAAmount = tokenAInput ? tokenAInput.value : '0';

    
    // Remove everything after the first space (removes token symbol)
     tokenAAmount = tokenAAmount.split(' ')[0];
    
                var tokenBAmount = tokenBInput ? tokenBInput.value : '0';
                
    
    // Remove everything after the first space (removes token symbol)
    tokenBAmount = tokenBAmount.split(' ')[0];
                console.log("Token A Amount:", tokenAAmount);
                console.log("Token B Amount:", tokenBAmount);


                console.log("Currently selected value TokenB:f", tokenBValue);

                // Or get the selected option element itself

                            var tokenAinputAddress = tokenAddresses[tokenAValue];
                            var tokenBinputAddress = tokenAddresses[tokenBValue];
                console.log("tokenA InputAddresstoken", tokenAinputAddress);
                console.log("tokenB InputAddresstoken", tokenBinputAddress);

                // Simple and reliable approach - select all number inputs in create page
                 const decreaseInputs = document.querySelectorAll('#decrease input[type="text"][readonly]');
                const amountInputA = decreaseInputs[0]; // First number input (Amount A)
                const amountInputB = decreaseInputs[1]; // Second number input (Amount B)

                // Add null checks to prevent errors
                if (!amountInputA || !amountInputB) {
                    console.error("Could not find amount inputfields");
                    return; 
                }


                console.log("Currently amountInputA value:", tokenAAmount);
                console.log("Currently amountInputB value:", tokenBAmount);

                const positionSelect = document.querySelector('#decrease select');

                    const selectedPositionId = positionSelect.value;
                    const position = positionData[selectedPositionId];
                    if (!position) return;
                    
                    let maxAmount = 0;
                    var uncalimedFeesA = position.unclaimedFeesTokenA;
                    var uncalimedFeesB = position.unclaimedFeesTokenB;

                var positionID = position.id.split('_')[1];
                console.log("positionID = : ", positionID);

                    var amountAtoCreate = ethers.utils.parseUnits(tokenAAmount, 18);  // Correctly represents 12 * 10^8
                         if( tokenAValue=="0xBTC"){
                                    console.log("LOGGED 0xBTC selected A Value, increaseTokenA");
                            amountAtoCreate = ethers.utils.parseUnits(tokenAAmount, 8);  // Correctly represents 12 * 10^8
                            }

                console.log("Currently amountInputB value:", tokenBAmount);
                
                var amountBtoCreate = ethers.utils.parseUnits(tokenBAmount, 18);  // Correctly represents 12 * 10^8
                            var amountInB0x = ethers.BigNumber.from(0);
                            var amountIn0xBTC = ethers.BigNumber.from(0);
                            var uncalimedFeesB0x = ethers.utils.parseUnits("0", 18);
                            var uncalimedFees0xBTC =  ethers.utils.parseUnits("0", 8);
                            if(tokenBValue != "0xBTC"){
                                amountInB0x = ethers.BigNumber.from(amountBtoCreate.toString());
                                 amountIn0xBTC = ethers.BigNumber.from(amountAtoCreate.toString());
                                  uncalimedFeesB0x = ethers.utils.parseUnits(position.unclaimedFeesTokenB.toString(), 18);
                                 uncalimedFees0xBTC =  ethers.utils.parseUnits(position.unclaimedFeesTokenA.toString(), 8);
                            }else if( tokenBValue=="0xBTC"){
                                    console.log("LOGGED 0xBTC selected B Value, increaseTokenA");
                            amountBtoCreate = ethers.utils.parseUnits(tokenBAmount, 8);  // Correctly represents 12 * 10^8

                             amountInB0x = ethers.BigNumber.from(amountAtoCreate.toString());
                            amountIn0xBTC = ethers.BigNumber.from(amountBtoCreate.toString());
                            uncalimedFeesB0x = ethers.utils.parseUnits(position.unclaimedFeesTokenA.toString(), 18);
                            uncalimedFees0xBTC = ethers.utils.parseUnits(position.unclaimedFeesTokenB.toString(), 8);
                            }


                        let amountOut = 0;

                       // await throttledGetSqrtRtAndPriceRatio();

                        console.log("AmountAtoCreate2: ", amountAtoCreate.toString());
                        console.log("AmountBtoCreate2: ", amountBtoCreate.toString());
                       console.log("uncalimedFeesA: ", uncalimedFeesA.toString());
                       console.log("uncalimedFeesB: ", uncalimedFeesB.toString());
                        console.log("positionID: ",positionID);


                    // ABI for getAmount0andAmount1forLiquidityPercentage function
                        const liquidityPercentageABI = [{
                            "inputs": [
                                {
                                    "internalType": "address",
                                    "name": "token",
                                    "type": "address"
                                },
                                {
                                    "internalType": "address", 
                                    "name": "token2",
                                    "type": "address"
                                },
                                {
                                    "internalType": "uint128",
                                    "name": "percentagedivby10000", 
                                    "type": "uint128"
                                },
                                {
                                    "internalType": "uint256",
                                    "name": "tokenID",
                                    "type": "uint256"
                                },
                                {
                                    "internalType": "address",
                                    "name": "HookAddress",
                                    "type": "address"
                                }
                            ],
                            "name": "getAmount0andAmount1forLiquidityPercentage",
                            "outputs": [
                                {
                                    "internalType": "uint256",
                                    "name": "amount0",
                                    "type": "uint256"
                                },
                                {
                                    "internalType": "uint256", 
                                    "name": "amount1",
                                    "type": "uint256"
                                }
                            ],
                            "stateMutability": "view",
                            "type": "function"
                        }
                    ];



//
                    tokenSwapperContract = new ethers.Contract(
                        contractAddress_Swapper, // your tokenSwapper contract address
                        liquidityPercentageABI,
                        signer // Use signer since the function isn't view/pure
                    );





let minAmount0Remove = 0;
let minAmount1Remove = 0;
      try {
        // Call the view function
        const result = await tokenSwapperContract.getAmount0andAmount1forLiquidityPercentage(tokenAddress, Address_ZEROXBTC_TESTNETCONTRACT, percentagedivby10000, positionID, HookAddress);

        if(tokenAddress == position.tokenA){
          minAmount0Remove = result[0];
          minAmount1Remove = result[1];
          console.log("token0 = b0x");
          console.log("token1 = 0xbtc");


        }else{

          console.log("token0 = 0xbtc");
          console.log("token1 = b0x");
          minAmount0Remove = result[1];
          minAmount1Remove = result[0];
        }




        console.log("minRemoveAmount0 aka b0x: ", minAmount0Remove.toString());
        console.log("minRemoveAmount1 aka 0xbtc: ", minAmount1Remove.toString());
          
        } catch (error) {
          console.error(`Error finding valid getAmount0andAmount1forLiquidityPercentage for remove Liq:`, error);
        }












                    const positionManagerABI = [
                    {
                        "inputs": [
                        {"internalType": "bytes", "name": "unlockData", "type": "bytes"},
                        {"internalType": "uint256", "name": "deadline", "type": "uint256"}
                        ],
                        "name": "modifyLiquidities",
                        "outputs": [],
                        "stateMutability": "payable",
                        "type": "function"
                    },{
                        "inputs": [
                            {
                                "internalType": "uint256",
                                "name": "tokenId",
                                "type": "uint256"
                            }
                        ],
                        "name": "getPositionLiquidity",
                        "outputs": [
                            {
                                "internalType": "uint128",
                                "name": "liquidity",
                                "type": "uint128"
                            }
                        ],
                        "stateMutability": "view",
                        "type": "function"
                    }
                    ];




                    positionManagerContract = new ethers.Contract(
                        positionManager_address, // your tokenSwapper contract address
                        positionManagerABI,
                        signer // Use signer since the function isn't view/pure
                    );


















     try {

// Use the slippage-adjusted amounts
const minAmount0 = calculateWithSlippageBigNumber(minAmount0Remove, decimalValueSlippage); // BigNumber
const minAmount1 = calculateWithSlippageBigNumber(minAmount1Remove, decimalValueSlippage); // BigNumber
console.log("min amount0: ",minAmount0.toString());
console.log("min amount1: ",minAmount1.toString());
//  Method 1: Using ternary operator with destructuring
const [token0, token1] = tokenAddress < Address_ZEROXBTC_TESTNETCONTRACT
    ? [tokenAddress, Address_ZEROXBTC_TESTNETCONTRACT]
    : [Address_ZEROXBTC_TESTNETCONTRACT, tokenAddress];

const [amount0remove, amount1remove] = tokenAddress < Address_ZEROXBTC_TESTNETCONTRACT
    ? [minAmount0, minAmount1]
    : [minAmount1, minAmount0];


  
var liqnow = 0;
        // Check if NFT is full-range
        
               console.log("percentagedivby10000 =: ",percentagedivby10000);
        
         var result =  await positionManagerContract.getPositionLiquidity(positionID);

               var liqtoRemove = 0;
        liqnow = result;
        if(percentagedivby10000!=10000){
            percentagedivby10000 = percentagedivby10000 + 1;
            
               liqtoRemove = toBigNumber(liqnow * (percentagedivby10000) / 10000);
        }else{

            liqtoRemove = liqnow;
        }
               console.log("LiqtoRemove =: ",liqtoRemove);

//bytes memory actions = abi.encodePacked(uint8(Actions.DECREASE_LIQUIDITY), uint8(Actions.TAKE_PAIR));
//DECREASE_LIQUIDITY = 0x01,
// TAKE_PAIR = 0x11,

                    // Initial actions: INCREASE_LIQUIDITY (0x00) and SETTLE_PAIR (0x0d)
                    let actions = ethers.utils.concat([
                        ethers.utils.hexZeroPad(0x01, 1), // uint8(0x00)
                        ethers.utils.hexZeroPad(0x11, 1)  // uint8(0x0d)
                    ]);



                const abiCoder = ethers.utils.defaultAbiCoder;
                // Initialize params array with 2 elements
                    let params = new Array(2);
                    
                  
                    // Encode first parameter: positionID, liquidityToRemove, amount0remove, amount1remove, empty bytes
                    params[0] = abiCoder.encode(
                        ["uint256", "int128", "uint256", "uint256", "bytes"], // Changed int128 to uint128
                        [positionID, liqtoRemove, amount0remove, amount1remove, "0x"]
                    );

                    // Encode second parameter: currency0, currency1, userAddress
                    params[1] = abiCoder.encode(
                        ["address", "address", "address"], // Added userAddress
                        [token0, token1, userAddress]
                    );

                    // Set deadline (current timestamp + 160 seconds)
                    const currentTimestamp = Math.floor(Date.now() / 1000);
                    const deadline = currentTimestamp + 160;

        /*
         bytes memory test = hex"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000056f2192f6c509e78c69adbe483f96aa1677d73a00000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000000003c00000000000000000000000093cbf1d665cc6268bf8f9f1510858076368a5000fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff2761800000000000000000000000000000000000000000000000000000000000d89e800000000000000000000000000000000000000000000000000000000a16f3ca5000000000000000000000000000000000000000000000000000000000756b5b30000000000000000000000000000000000000000000000000000001c32c8e5c70000000000000000000000007e2b7f161c0376f69c62bffd345da07843a7b73300000000000000000000000000000000000000000000000000000000000001800000000000000000000000000000000000000000000000000000000000000000";
     
            (PoolKey memory pool2, int24 tickLower2, int24 tickUpper2, uint256 liquidity2, uint128 amount0Max2,  uint128 amount1Max2 , address owner2 , bytes memory hookData2) = 
        abi.decode(test, (PoolKey, int24, int24, uint256, uint128, uint128, address, bytes));
            v_poolKey21 = pool2;
            v_tickLower = tickLower2;
            v_tickUpper = tickUpper2;
            v_liquidity = liquidity2;
            v_amount0Max = amount0Max2;
            v_amount1Max = amount1Max2;
            v_owner = owner2;
            v_hookData = hookData2;
            */




                // Encode the final call data
                    const callData = abiCoder.encode(
                        ["bytes", "bytes[]"],
                        [actions, params]
                    );
                    

        alert("Decreasing Liquidity now! Approve Transaction!");
              const tx = await positionManagerContract.modifyLiquidities(callData, deadline);
        
      console.log("DECREASED Liquidity transaction sent:", tx.hash);
      console.log("Waiting for transaction confirmation...");
      
      // Wait for the transaction to be mined
      const receipt = await tx.wait();
      console.log("Increased Liquidity transaction confirmed in block:", receipt.blockNumber);
      console.log("REMOVED "+(percentagedivby10000/10000)+"% of the tokens from tokenID: "+ positionID);

        // If you want to use these values for further operations
        // For example, if there's a deploy function that uses the salt
        // await UniV4Hook.deploy(validSalt);
        fetchBalances();
        
                         getTokenIDsOwnedByMetamask();
      } catch (error) {
        console.error(`Error decrease liquidty on token`, error);
      }



console.log("Done with decrease Liq");













}


// Method 1: Using ethers BigNumber for slippage calculations
function calculateWithSlippageBigNumber(amount, decimalValueSlippage) {
    // Convert slippage to basis points (multiply by 10000)
    // 0.001 (0.1%) becomes 10 basis points
    const slippageBasisPoints = Math.floor(decimalValueSlippage * 10000);
    const remainingBasisPoints = 10000 - slippageBasisPoints;
    
    console.log("Slippage basis points:", slippageBasisPoints);
    console.log("Remaining basis points:", remainingBasisPoints);
    
    // Convert to BigNumber for calculation
    const amountBN = ethers.BigNumber.from(amount.toString());
    const remainingBN = ethers.BigNumber.from(remainingBasisPoints);
    const divisorBN = ethers.BigNumber.from(10000);
    
    // Calculate: amount * (1 - slippage) = amount * remainingBasisPoints / 10000
    const result = amountBN.mul(remainingBN).div(divisorBN);
    
    return result;
}




    async function increaseLiquidityStaking(){


            if(!walletConnected){
               await connectWallet();
            }


    
                // Get slippage tolerance
                const selectSlippage = document.getElementById('slippageToleranceStakeIncrease');
                const selectSlippageValue = selectSlippage.value; // Returns: "0.1%", "0.5%", "1.0%", or "2.0%"
                const numberValueSlippage = parseFloat(selectSlippageValue.replace('%', ''));
                // Divide by 100 to get decimal
                const decimalValueSlippage = numberValueSlippage / 100;
                
                console.log("selectSlippageValue: ", selectSlippageValue);
                console.log("decimalValueSlippage: ", decimalValueSlippage);
                
                
                                // Get token types from labels within increase page
                const tokenALabel = document.querySelector('#stakeincrease #tokenALabelINC');
                const tokenBLabel = document.querySelector('#stakeincrease #tokenBLabelINC');

                // Get input amounts from inputs within increase page  
                const tokenAInput = document.querySelector('#stakeincrease #tokenAAmount');
                const tokenBInput = document.querySelector('#stakeincrease #tokenBAmount');
                // Get the token values from the label text content
                const tokenAValue = tokenALabel.textContent; // Gets "ETH"
                const tokenBValue = tokenBLabel.textContent; // Gets "USDC"
                
                console.log("Currently selected value TokenA:", tokenAValue);
                console.log("Currently selected value TokenB:", tokenBValue);
                
                
                const tokenAAmount = tokenAInput ? tokenAInput.value : '0';
                const tokenBAmount = tokenBInput ? tokenBInput.value : '0';
                
                console.log("Token A Amount:", tokenAAmount);
                console.log("Token B Amount:", tokenBAmount);


                console.log("Currently selected value TokenB:f", tokenBValue);

                // Or get the selected option element itself

                            var tokenAinputAddress = tokenAddresses[tokenAValue];
                            var tokenBinputAddress = tokenAddresses[tokenBValue];
                console.log("tokenA InputAddresstoken", tokenAinputAddress);
                console.log("tokenB InputAddresstoken", tokenBinputAddress);

                // Simple and reliable approach - select all number inputs in create page
                const createInputs = document.querySelectorAll('#stakeincrease input[type="number"]');
                const amountInputA = createInputs[0]; // First number input (Amount A)
                const amountInputB = createInputs[1]; // Second number input (Amount B)

                // Add null checks to prevent errors
                if (!amountInputA || !amountInputB) {
                    console.error("Could not find amount inputfields");
                    return; 
                }


                console.log("Currently amountInputA value:", tokenAAmount);
                console.log("Currently amountInputB value:", tokenBAmount);

                const positionSelect = document.querySelector('#stakeincrease select');

                    const selectedPositionId = positionSelect.value;
                    const position = stakingPositionData[selectedPositionId];
                    if (!position) return;
                    
                    let maxAmount = 0;
                    var uncalimedFeesA = position.unclaimedFeesTokenA;
                    var uncalimedFeesB = position.unclaimedFeesTokenB;

                var positionID = position.id.split('_')[2];
                console.log("positionID = : ", positionID);

                    var amountAtoCreate = ethers.utils.parseUnits(tokenAAmount, 18);  // Correctly represents 12 * 10^8
                         if( tokenAValue=="0xBTC"){
                                    console.log("LOGGED 0xBTC selected A Value, stakeincrease");
                            amountAtoCreate = ethers.utils.parseUnits(tokenAAmount, 8);  // Correctly represents 12 * 10^8
                            }

                console.log("Currently amountInputB value:", tokenBAmount);
                            var amountBtoCreate = ethers.utils.parseUnits(tokenBAmount, 18);  // Correctly represents 12 * 10^8
                            var amountInB0x = ethers.BigNumber.from(0);
                            var amountIn0xBTC = ethers.BigNumber.from(0);
                            var uncalimedFeesB0x = ethers.utils.parseUnits("0", 18);
                            var uncalimedFees0xBTC =  ethers.utils.parseUnits("0", 8);
                            if(tokenBValue != "0xBTC"){
                                amountInB0x = ethers.BigNumber.from(amountBtoCreate.toString());
                                 amountIn0xBTC = ethers.BigNumber.from(amountAtoCreate.toString());
                                 // uncalimedFeesB0x = ethers.utils.parseUnits(position.unclaimedFeesTokenB.toString(), 18);
                               //  uncalimedFees0xBTC =  ethers.utils.parseUnits(position.unclaimedFeesTokenA.toString(), 8);
                            }else if( tokenBValue=="0xBTC"){
                                    console.log("LOGGED 0xBTC selected B Value, stakeincrease");
                            amountBtoCreate = ethers.utils.parseUnits(tokenBAmount, 8);  // Correctly represents 12 * 10^8

                             amountInB0x = ethers.BigNumber.from(amountAtoCreate.toString());
                            amountIn0xBTC = ethers.BigNumber.from(amountBtoCreate.toString());
                          //  uncalimedFeesB0x = ethers.utils.parseUnits(position.unclaimedFeesTokenA.toString(), 18);
                          //  uncalimedFees0xBTC = ethers.utils.parseUnits(position.unclaimedFeesTokenB.toString(), 8);
                            }

                        let amountOut = 0;

                       // await throttledGetSqrtRtAndPriceRatio();

                        console.log("AmountAtoCreate2: ", amountAtoCreate.toString());
                        console.log("AmountBtoCreate2: ", amountBtoCreate.toString());
                      //  console.log("uncalimedFeesA: ", uncalimedFeesA.toString());
                      //  console.log("uncalimedFeesB: ", uncalimedFeesB.toString());
                        console.log("positionID: ",positionID);

                        const INCREASE_LIQUIDITY_ABI = [
                            {
                                "inputs": [
                                    {
                                        "internalType": "address",
                                        "name": "forWho",
                                        "type": "address"
                                    },
                                    {
                                        "internalType": "uint256",
                                        "name": "amount0In",
                                        "type": "uint256"
                                    },
                                    {
                                        "internalType": "uint256",
                                        "name": "amount1In",
                                        "type": "uint256"
                                    },
                                    {
                                        "internalType": "uint256",
                                        "name": "tokenID",
                                        "type": "uint256"
                                    },
                                    {
                                        "internalType": "uint160",
                                        "name": "expectedSqrtPricex96",
                                        "type": "uint160"
                                    },
                                    {
                                        "internalType": "uint160",
                                        "name": "slippageBps",
                                        "type": "uint160"
                                    }
                                ],
                                "name": "increaseLiquidityOfPosition",
                                "outputs": [
                                    {
                                        "internalType": "bool",
                                        "name": "",
                                        "type": "bool"
                                    }
                                ],
                                "stateMutability": "nonpayable",
                                "type": "function"
                            }
                        ];




//
//  Method 1: Using ternary operator with destructuring
const [token0, token1] = tokenAddress < Address_ZEROXBTC_TESTNETCONTRACT
    ? [tokenAddress, Address_ZEROXBTC_TESTNETCONTRACT]
    : [Address_ZEROXBTC_TESTNETCONTRACT, tokenAddress];

const [amount0, amount1] = tokenAddress < Address_ZEROXBTC_TESTNETCONTRACT
    ? [amountInB0x, amountIn0xBTC]
    : [amountIn0xBTC, amountInB0x];

const [fees0a, fees1a] = tokenAddress < Address_ZEROXBTC_TESTNETCONTRACT
    ? [uncalimedFeesB0x, uncalimedFees0xBTC]
    : [uncalimedFees0xBTC, uncalimedFeesB0x];



                 var   LPRewarsdStakingContract = new ethers.Contract(
                        contractAddressLPRewardsStaking, // your tokenSwapper contract address
                        INCREASE_LIQUIDITY_ABI,
                        signer // Use signer since the function isn't view/pure
                    );
                        console.log("FFF! amountInB0x: ", amountInB0x.toString());
                        console.log("FFF! amountIn0xBTC: ", amountIn0xBTC.toString());
                        console.log("FFF! FeesB0x: ", uncalimedFeesB0x.toString());
                        console.log("FFF! Fees0xBTC: ", uncalimedFees0xBTC.toString());
                        console.log("positionID: ",positionID);
                        console.log("FFF! token0: ", token0);
                        console.log("FFF! token1: ", token1);
                        console.log("FFF! amount0: ", amount0);
                        console.log("FFF! amount1: ", amount1);
                        console.log("FFF! fees0a: ", fees0a);
                        console.log("FFF! fees1a: ", fees1a);
                        // no fees because we are staking mode where it collects fees and redistributes
                                var afterFees0 = amount0;
                                var afterFees1 = amount1;
                        console.log("FFF! afterFees0: ", afterFees0);
                        console.log("FFF! afterFees0: ", afterFees1);
                        
                                const abiCoder = ethers.utils.defaultAbiCoder;
                                let liquidityDelta=0;
                        try {

                                permit2Address = "0x000000000022D473030F116dDEE9F6B43aC78BA3";
                                var afterFees = amount0-fees0a;
                               // await approveTokensViaPermit2(signer, permit2Address, token0, token1, positionManager_address, afterFees0, afterFees1);
                                console.log("Approved Permit Successfully");
                                await approveIfNeeded(token0, contractAddressLPRewardsStaking, afterFees0);
                                await approveIfNeeded(token1, contractAddressLPRewardsStaking, afterFees1);
                                console.log("Approved Both Approvals if needed");

                                console.log(`NFT token ${positionID} approved for spending by ${permit2Address}`);

                                var tickLower = -887220; // Your desired lower tick
                                var tickUpper = 887220;  // Your desired upper tick

                                // Convert ticks to sqrtPriceX96 values
                                var sqrtRatioAX96 = getSqrtRatioAtTick(tickLower);
                                var sqrtRatioBX96 = getSqrtRatioAtTick(tickUpper);
                                var sqrtPricex96 = Current_getsqrtPricex96;
                                console.log("Sllipage BPS: ", numberValueSlippage," %");
                                var slippageBPS = Math.floor(numberValueSlippage*100);
                                const tx  = await LPRewarsdStakingContract.increaseLiquidityOfPosition(userAddress, amount0, amount1, positionID, sqrtPricex96, slippageBPS);
                          
                                    
                                    console.log("Transaction sent:", tx.hash);
                                    const receipt12 = await tx.wait();
                                console.log("Increase Liq Transaction Confirmed@!")




                        } catch (error) {
                            console.error(`Error approving tokens for  liquidty increase`, error);
                        }
                    





                        console.log(`Deposited ${ ethers.utils.formatEther(amountInB0x.toString())} tokens and another ${ethers.utils.formatUnits(amountIn0xBTC.toString(), 8)} tokens into tokenID: ${positionID}`);
                         fetchBalances();
                         await getTokenIDsOwnedByMetamask();

                        await getRewardStats();
                            // If you want to use these values for further operations
                            // For example, if there's a deploy function that uses the salt
                            // await UniV4Hook.deploy(validSalt);
                            
                    

            }

        
    



    async function increaseLiquidity() {



            if(!walletConnected){
               await connectWallet();
            }


    
                // Get slippage tolerance
                const selectSlippage = document.getElementById('slippageToleranceIncreaseLiquidity');
                const selectSlippageValue = selectSlippage.value; // Returns: "0.1%", "0.5%", "1.0%", or "2.0%"
                const numberValueSlippage = parseFloat(selectSlippageValue.replace('%', ''));
                // Divide by 100 to get decimal
                const decimalValueSlippage = numberValueSlippage / 100;
                
                console.log("selectSlippageValue: ", selectSlippageValue);
                console.log("decimalValueSlippage: ", decimalValueSlippage);
                
                
                                // Get token types from labels within increase page
                const tokenALabel = document.querySelector('#increase #tokenALabel');
                const tokenBLabel = document.querySelector('#increase #tokenBLabel');

                // Get input amounts from inputs within increase page  
                const tokenAInput = document.querySelector('#increase #tokenAAmount');
                const tokenBInput = document.querySelector('#increase #tokenBAmount');
                // Get the token values from the label text content
                const tokenAValue = tokenALabel.textContent; // Gets "ETH"
                const tokenBValue = tokenBLabel.textContent; // Gets "USDC"
                
                console.log("Currently selected value TokenA:", tokenAValue);
                console.log("Currently selected value TokenB:", tokenBValue);
                
                
                const tokenAAmount = tokenAInput ? tokenAInput.value : '0';
                const tokenBAmount = tokenBInput ? tokenBInput.value : '0';
                
                console.log("Token A Amount:", tokenAAmount);
                console.log("Token B Amount:", tokenBAmount);


                console.log("Currently selected value TokenB:f", tokenBValue);

                // Or get the selected option element itself

                            var tokenAinputAddress = tokenAddresses[tokenAValue];
                            var tokenBinputAddress = tokenAddresses[tokenBValue];
                console.log("tokenA InputAddresstoken", tokenAinputAddress);
                console.log("tokenB InputAddresstoken", tokenBinputAddress);

                // Simple and reliable approach - select all number inputs in create page
                const createInputs = document.querySelectorAll('#increase input[type="number"]');
                const amountInputA = createInputs[0]; // First number input (Amount A)
                const amountInputB = createInputs[1]; // Second number input (Amount B)

                // Add null checks to prevent errors
                if (!amountInputA || !amountInputB) {
                    console.error("Could not find amount inputfields");
                    return; 
                }


                console.log("Currently amountInputA value:", tokenAAmount);
                console.log("Currently amountInputB value:", tokenBAmount);

                const positionSelect = document.querySelector('#increase select');

                    const selectedPositionId = positionSelect.value;
                    const position = positionData[selectedPositionId];
                    if (!position) return;
                    
                    let maxAmount = 0;
                    var uncalimedFeesA = position.unclaimedFeesTokenA;
                    var uncalimedFeesB = position.unclaimedFeesTokenB;

                var positionID = position.id.split('_')[1];
                console.log("positionID = : ", positionID);

                    var amountAtoCreate = ethers.utils.parseUnits(tokenAAmount, 18);  // Correctly represents 12 * 10^8
                         if( tokenAValue=="0xBTC"){
                                    console.log("LOGGED 0xBTC selected A Value, increaseTokenA");
                            amountAtoCreate = ethers.utils.parseUnits(tokenAAmount, 8);  // Correctly represents 12 * 10^8
                            }

                console.log("Currently amountInputB value:", tokenBAmount);
                            var amountBtoCreate = ethers.utils.parseUnits(tokenBAmount, 18);  // Correctly represents 12 * 10^8
                            var amountInB0x = ethers.BigNumber.from(0);
                            var amountIn0xBTC = ethers.BigNumber.from(0);
                            var uncalimedFeesB0x = ethers.utils.parseUnits("0", 18);
                            var uncalimedFees0xBTC =  ethers.utils.parseUnits("0", 8);
                            if(tokenBValue != "0xBTC"){
                                amountInB0x = ethers.BigNumber.from(amountBtoCreate.toString());
                                 amountIn0xBTC = ethers.BigNumber.from(amountAtoCreate.toString());
                                  uncalimedFeesB0x = ethers.utils.parseUnits(position.unclaimedFeesTokenB.toString(), 18);
                                 uncalimedFees0xBTC =  ethers.utils.parseUnits(position.unclaimedFeesTokenA.toString(), 8);
                            }else if( tokenBValue=="0xBTC"){
                                    console.log("LOGGED 0xBTC selected B Value, increaseTokenA");
                            amountBtoCreate = ethers.utils.parseUnits(tokenBAmount, 8);  // Correctly represents 12 * 10^8

                             amountInB0x = ethers.BigNumber.from(amountAtoCreate.toString());
                            amountIn0xBTC = ethers.BigNumber.from(amountBtoCreate.toString());
                            uncalimedFeesB0x = ethers.utils.parseUnits(position.unclaimedFeesTokenA.toString(), 18);
                            uncalimedFees0xBTC = ethers.utils.parseUnits(position.unclaimedFeesTokenB.toString(), 8);
                            }

                        let amountOut = 0;

                       // await throttledGetSqrtRtAndPriceRatio();

                        console.log("AmountAtoCreate2: ", amountAtoCreate.toString());
                        console.log("AmountBtoCreate2: ", amountBtoCreate.toString());
                        console.log("uncalimedFeesA: ", uncalimedFeesA.toString());
                        console.log("uncalimedFeesB: ", uncalimedFeesB.toString());
                        console.log("positionID: ",positionID);


                    const tokenSwapperABI = [
                    {
                        "inputs": [
                        {"internalType": "address", "name": "tokenA", "type": "address"},
                        {"internalType": "address", "name": "tokenB", "type": "address"},
                        {"internalType": "address", "name": "hookAddress", "type": "address"},
                        {"internalType": "uint256", "name": "amountA", "type": "uint256"},
                        {"internalType": "uint256", "name": "amountB", "type": "uint256"},
                        {"internalType": "uint256", "name": "tokenID", "type": "uint256"},
                        {"internalType": "uint256", "name": "fees0", "type": "uint256"},         
                        {"internalType": "uint256", "name": "fees1", "type": "uint256"}
                        ],
                        "name": "increaseLiqTwoTokens",
                        "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
                        "stateMutability": "payable",
                        "type": "function"
                    },{
                    "inputs": [
                        {
                        "internalType": "uint160",
                        "name": "sqrtPriceX96",
                        "type": "uint160"
                        },
                        {
                        "internalType": "uint160",
                        "name": "sqrtPriceAX96",
                        "type": "uint160"
                        },
                        {
                        "internalType": "uint160",
                        "name": "sqrtPriceBX96",
                        "type": "uint160"
                        },
                        {
                        "internalType": "uint256",
                        "name": "amount0",
                        "type": "uint256"
                        },
                        {
                        "internalType": "uint256",
                        "name": "amount1",
                        "type": "uint256"
                        }
                    ],
                    "name": "getLiquidityForAmounts",
                    "outputs": [
                        {
                        "internalType": "uint128",
                        "name": "liquidity",
                        "type": "uint128"
                        }
                    ],
                    "stateMutability": "pure",
                    "type": "function"
                    }



                    ];
                    const positionManagerABI = [
                    {
                        "inputs": [
                        {"internalType": "bytes", "name": "unlockData", "type": "bytes"},
                        {"internalType": "uint256", "name": "deadline", "type": "uint256"}
                        ],
                        "name": "modifyLiquidities",
                        "outputs": [],
                        "stateMutability": "payable",
                        "type": "function"
                    }
                    ];




//
//  Method 1: Using ternary operator with destructuring
const [token0, token1] = tokenAddress < Address_ZEROXBTC_TESTNETCONTRACT
    ? [tokenAddress, Address_ZEROXBTC_TESTNETCONTRACT]
    : [Address_ZEROXBTC_TESTNETCONTRACT, tokenAddress];

const [amount0, amount1] = tokenAddress < Address_ZEROXBTC_TESTNETCONTRACT
    ? [amountInB0x, amountIn0xBTC]
    : [amountIn0xBTC, amountInB0x];

const [fees0a, fees1a] = tokenAddress < Address_ZEROXBTC_TESTNETCONTRACT
    ? [uncalimedFeesB0x, uncalimedFees0xBTC]
    : [uncalimedFees0xBTC, uncalimedFeesB0x];



                    tokenSwapperContract = new ethers.Contract(
                        contractAddress_Swapper, // your tokenSwapper contract address
                        tokenSwapperABI,
                        signer // Use signer since the function isn't view/pure
                    );
                    positionManagerContract = new ethers.Contract(
                        positionManager_address, // your tokenSwapper contract address
                        positionManagerABI,
                        signer // Use signer since the function isn't view/pure
                    );

                        console.log("FFF! amountInB0x: ", amountInB0x.toString());
                        console.log("FFF! amountIn0xBTC: ", amountIn0xBTC.toString());
                        console.log("FFF! FeesB0x: ", uncalimedFeesB0x.toString());
                        console.log("FFF! Fees0xBTC: ", uncalimedFees0xBTC.toString());
                        console.log("positionID: ",positionID);
                        console.log("FFF! token0: ", token0);
                        console.log("FFF! token1: ", token1);
                        console.log("FFF! amount0: ", amount0);
                        console.log("FFF! amount1: ", amount1);
                        console.log("FFF! fees0a: ", fees0a);
                        console.log("FFF! fees1a: ", fees1a);
                                var afterFees0 = amount0-fees0a;
                                var afterFees1 = amount1-fees1a;
                        console.log("FFF! afterFees0: ", afterFees0);
                        console.log("FFF! afterFees0: ", afterFees1);
                        
                                const abiCoder = ethers.utils.defaultAbiCoder;
                                let liquidityDelta=0;
                        try {

                                permit2Address = "0x000000000022D473030F116dDEE9F6B43aC78BA3";
                                var afterFees = amount0-fees0a;
                                await approveTokensViaPermit2(signer, permit2Address, token0, token1, positionManager_address, afterFees0, afterFees1);
                                console.log("Approved Permit Successfully");
                                await approveIfNeeded(token0, permit2Address, afterFees0);
                                await approveIfNeeded(token1, permit2Address, afterFees1);
                                console.log("Approved Both Approvals if needed");

                                console.log(`NFT token ${positionID} approved for spending by ${permit2Address}`);

                                var tickLower = -887220; // Your desired lower tick
                                var tickUpper = 887220;  // Your desired upper tick

                                // Convert ticks to sqrtPriceX96 values
                                var sqrtRatioAX96 = getSqrtRatioAtTick(tickLower);
                                var sqrtRatioBX96 = getSqrtRatioAtTick(tickUpper);
                                var sqrtPricex96 = Current_getsqrtPricex96;
                                const result = await tokenSwapperContract.getLiquidityForAmounts(sqrtPricex96, sqrtRatioAX96,  sqrtRatioBX96, amount0, amount1);
                                console.log("Get Liquidity for amounts result: ", result.toString());
                                liquidityDelta=result;






                        } catch (error) {
                            console.error(`Error approving tokens for  liquidty increase`, error);
                        }
                    





                // Initialize params array with 2 elements
                    let params = new Array(2);
                    
                    // Encode first parameter: tokenID, liquidityDelta, amount0, amount1, empty bytes
                    params[0] = abiCoder.encode(
                        ["uint256", "int128", "uint256", "uint256", "bytes"],
                        [positionID, liquidityDelta, amount0, amount1, "0x"]
                    );
                    
                    // Currency wrapping (assuming Currency.wrap just returns the address)
                    const currency0 = token0; // In JS, we'll just use the token address directly
                    const currency1 = token1;
                    
                    // Encode currency pair for settlement
                    params[1] = abiCoder.encode(
                        ["address", "address"],
                        [currency0, currency1]
                    );
                    
                    // Initial actions: INCREASE_LIQUIDITY (0x00) and SETTLE_PAIR (0x0d)
                    let actions = ethers.utils.concat([
                        ethers.utils.hexZeroPad(0x00, 1), // uint8(0x00)
                        ethers.utils.hexZeroPad(0x0d, 1)  // uint8(0x0d)
                    ]);
                    
                    // Calculate remaining fees to avoid claiming more than available
                    const remainingFees0 = fees0a > amount0 ? fees0a - amount0 : 0;
                    const remainingFees1 = fees1a > amount1 ? fees1a - amount1 : 0;
                    
                    // Only use CLOSE_CURRENCY if there are actually remaining fees to claim
                    if (remainingFees0 > 0 || remainingFees1 > 0) {
                        // Resize params array to 3 elements
                        params = new Array(3);
                        
                        // Update actions: INCREASE_LIQUIDITY, CLOSE_CURRENCY, CLOSE_CURRENCY
                        actions = ethers.utils.concat([
                            ethers.utils.hexZeroPad(0x00, 1), // INCREASE_LIQUIDITY
                            ethers.utils.hexZeroPad(0x12, 1), // CLOSE_CURRENCY
                            ethers.utils.hexZeroPad(0x12, 1)  // CLOSE_CURRENCY
                        ]);
                        
                        // Re-encode first parameter
                        params[0] = abiCoder.encode(
                            ["uint256", "int128", "uint256", "uint256", "bytes"],
                            [positionID, liquidityDelta, amount0, amount1, "0x"]
                        );
                        
                        // Encode individual currencies for closing
                        params[1] = abiCoder.encode(["address"], [token0]); // Close token0
                        params[2] = abiCoder.encode(["address"], [token1]); // Close token1
                    }
                    
                    // Set deadline (current timestamp + 160 seconds)
                    const currentTimestamp = Math.floor(Date.now() / 1000);
                    const deadline = currentTimestamp + 160;
                    
                    // Encode the final call data
                    const callData = abiCoder.encode(
                        ["bytes", "bytes[]"],
                        [actions, params]
                    );
                    
                    
                    try {
                        const tx = await positionManagerContract.modifyLiquidities(
                            callData,
                            deadline
                        );
                        
                        console.log("Transaction sent:", tx.hash);
                        const receipt12 = await tx.wait();
                        console.log("Transaction confirmed:", receipt12.transactionHash);
                        






                        console.log("Increased Liquidity transaction confirmed in block:", receipt12.blockNumber);
                        console.log(`Deposited ${ ethers.utils.formatEther(amountInB0x.toString())} tokens and another ${ethers.utils.formatUnits(amountIn0xBTC.toString(), 8)} tokens into tokenID: ${positionID}`);
                         fetchBalances();
                         await getTokenIDsOwnedByMetamask();
                            // If you want to use these values for further operations
                            // For example, if there's a deploy function that uses the salt
                            // await UniV4Hook.deploy(validSalt);
                            
                        } catch (error) {
                            console.error(`Error increasing liquidty on modfiyLiquitidies`, error);
                        }
                    

            }





        // Check current allowance for a token
        async function checkAllowance2(permit2Contract, userAddress, tokenAddress, spenderAddress) {
        const allowanceData = await permit2Contract.allowance(userAddress, tokenAddress, spenderAddress);
        return {
            amount: allowanceData.amount,
            expiration: allowanceData.expiration,
            nonce: allowanceData.nonce,
            isExpired: allowanceData.expiration < Math.floor(Date.now() / 1000)
        };
        }

        // Check if approval is needed
        async function needsApproval(permit2Contract, userAddress, tokenAddress, spenderAddress, requiredAmount) {
        const allowance = await checkAllowance2(permit2Contract, userAddress, tokenAddress, spenderAddress);
        // When setting requiredAmount earlier in your code:
requiredAmount = toBigNumber(requiredAmount);              
        // Then your comparison will work:
        // Check if allowance is sufficient and not expired
        const sufficientAmount = allowance.amount.gte(requiredAmount);
        const notExpired = !allowance.isExpired;
        
        return !(sufficientAmount && notExpired);
        }

        async function approveTokensViaPermit2(signer, permit2Address, token0, token1, positionManagerAddress, requiredAmount0, requiredAmount1) {
        // Create contract instance
        // Permit2 interface
          const permit2Abi = [
            {
            "name": "approve",
            "type": "function",
            "stateMutability": "nonpayable", // Add this
            "inputs": [
                {"name": "token", "type": "address"},
                {"name": "spender", "type": "address"},
                {"name": "amount", "type": "uint160"},
                {"name": "expiration", "type": "uint48"}
            ],
            "outputs": []
            },
            {
            "name": "allowance",
            "type": "function",
            "stateMutability": "view", // Add this
            "inputs": [
                {"name": "user", "type": "address"},
                {"name": "token", "type": "address"},
                {"name": "spender", "type": "address"}
            ],
            "outputs": [
                {"name": "amount", "type": "uint160"},
                {"name": "expiration", "type": "uint48"},
                {"name": "nonce", "type": "uint48"}
            ]
            }
        ];
        const permit2Contract = new ethers.Contract(permit2Address, permit2Abi, signer);
        const userAddress = await signer.getAddress();
        
        // Get current timestamp and add 1 hour (3600 seconds)
        const currentTime = Math.floor(Date.now() / 1000);
        const expiration = currentTime + 3600; // 1 hour from now
        
        // Maximum uint160 value (equivalent to type(uint160).max in Solidity)
        const maxAmount = ethers.BigNumber.from(2).pow(160).sub(1);
        
        try {
            // Check if token0 needs approval
            const needsToken0Approval = await needsApproval(
            permit2Contract, 
            userAddress, 
            token0, 
            positionManagerAddress, 
            requiredAmount0 || maxAmount
            );
            
            if (needsToken0Approval) {
            console.log('Token0 needs approval, approving...');
            const tx1 = await permit2Contract.approve(
                token0,
                positionManagerAddress,
                maxAmount,
                expiration
            );
            console.log('Token0 approval transaction hash:', tx1.hash);
            await tx1.wait();
            } else {
            console.log('Token0 already has sufficient allowance');
            }
            
            // Check if token1 needs approval
            const needsToken1Approval = await needsApproval(
            permit2Contract, 
            userAddress, 
            token1, 
            positionManagerAddress, 
            requiredAmount1 || maxAmount
            );
            
            if (needsToken1Approval) {
            console.log('Token1 needs approval, approving...');
            const tx2 = await permit2Contract.approve(
                token1,
                positionManagerAddress,
                maxAmount,
                expiration
            );
            console.log('Token1 approval transaction hash:', tx2.hash);
            await tx2.wait();
            } else {
            console.log('Token1 already has sufficient allowance');
            }
            
            console.log('Approval check and setup completed');
            
        } catch (error) {
            console.error('Error checking/approving tokens:', error);
            throw error;
        }
        }




const MAX_TICK = 887220;

/**
 * Convert tick to sqrtPriceX96
 * @param {number} tick - The tick value
 * @returns {bigint} - The sqrt ratio as a 160-bit unsigned integer
 */
function getSqrtRatioAtTick(tick) {
    const absTick = tick < 0 ? -tick : tick;
    
    if (absTick > MAX_TICK) {
        throw new Error("TICK_OUT_OF_RANGE");
    }
    
    let ratio = (absTick & 0x1) !== 0
        ? 0xfffcb933bd6fad37aa2d162d1a594001n
        : 0x100000000000000000000000000000000n;
    
    if ((absTick & 0x2) !== 0) ratio = (ratio * 0xfff97272373d413259a46990580e213an) >> 128n;
    if ((absTick & 0x4) !== 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdccn) >> 128n;
    if ((absTick & 0x8) !== 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0n) >> 128n;
    if ((absTick & 0x10) !== 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644n) >> 128n;
    if ((absTick & 0x20) !== 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0n) >> 128n;
    if ((absTick & 0x40) !== 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861n) >> 128n;
    if ((absTick & 0x80) !== 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053n) >> 128n;
    if ((absTick & 0x100) !== 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4n) >> 128n;
    if ((absTick & 0x200) !== 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54n) >> 128n;
    if ((absTick & 0x400) !== 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3n) >> 128n;
    if ((absTick & 0x800) !== 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9n) >> 128n;
    if ((absTick & 0x1000) !== 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825n) >> 128n;
    if ((absTick & 0x2000) !== 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5n) >> 128n;
    if ((absTick & 0x4000) !== 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7n) >> 128n;
    if ((absTick & 0x8000) !== 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6n) >> 128n;
    if ((absTick & 0x10000) !== 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9n) >> 128n;
    if ((absTick & 0x20000) !== 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604n) >> 128n;
    if ((absTick & 0x40000) !== 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98n) >> 128n;
    if ((absTick & 0x80000) !== 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2n) >> 128n;
    
    if (tick > 0) {
        // Equivalent to type(uint256).max / ratio
        const MAX_UINT256 = (1n << 256n) - 1n;
        ratio = MAX_UINT256 / ratio;
    }
    
    // This divides by 1<<32 rounding up to go from a Q128.128 to a Q96.64
    const sqrtPriceX96 = (ratio >> 32n) + (ratio % (1n << 32n) === 0n ? 0n : 1n);
    
    // Return as bigint (equivalent to uint160 - we trust it fits in 160 bits)
    return sqrtPriceX96;
}























/* Mock wallet balances - replace with real data from your wallet
var walletBalances = {
    'ETH': 2.5,
    'USDC': 1500.75,
    'DAI': 890.25,
    'WBTC': 0.15,
    '0xBTC': 13.99997,
    'B0x': 5.0000
};

*/


var walletBalances = {
    'ETH': 0.0,
    'USDC': 0.000,
    '0xBTC': 0.00,
    'B0x': 0.00,
    'WETH': 0.00
};










//USE CONTRACT LAUNCH PARAMETERS HERE!//









const USDCToken = "0x036CbD53842c5426634e7929541eC2318f3dCF7e";
const positionManager_address = "0x4B2C77d209D3405F41a037Ec6c77F7F5b8e2ca80";
const contractAddress_PositionFinderPro = '0x9c7F1CacC7FC92530455383a7ba2d119B77Ec52e'; // Replace with actual contract address
const contractAddress_Swapper = '0xC25d908f13Cdf714a674A5FFCE1020CB28B23E9D'; // Replace with actual contract address
const contractAddressLPRewardsStaking = '0x0C056B786f7330ddf9F818cd92C38d6C9c83755f';
const hookAddress = '0x3Ef2b925bb512F105b5c4aebF8644E04aca31000';

// Token addresses mapping
const tokenAddresses = {
'ETH': '0x0000000000000000000000000000000000000000', // Example addresses
'B0x': '0x96339eeAd50A34271fdb160308EE4234eE634221',
'0xBTC': '0x8f5E8ABfd3eA6b59A88eFEd222AE9d815C024dAd',
'WETH': '0x4200000000000000000000000000000000000006',
};



    const tokenMap = {
        "0x4200000000000000000000000000000000000006": "WETH",
        "0x0000000000000000000000000000000000000000": "ETH",
        "0x96339eeAd50A34271fdb160308EE4234eE634221": "B0x",
        "0x8f5E8ABfd3eA6b59A88eFEd222AE9d815C024dAd": "0xBTC",
        // Add more token mappings as needed
    };











// Helper function to get token name from address
function getTokenNameFromAddress(address) {

    return tokenMap[address] || `Token${address.slice(-4)}`;
}































        // Token addresses mapping
        const tokenAddressesDecimals = {
            'USDC': '6', // Example addresses
            'ETH': '18', // Example addresses
            'DAI': '18',
            'WBTC': '8',
            'B0x': '18',
            '0xBTC': '8',
            'WETH': '18'
        };
        const addressToSymbol = {};
        Object.keys(tokenAddresses).forEach(symbol => {
            const address = tokenAddresses[symbol].toLowerCase(); // Store in lowercase for easier matching
            addressToSymbol[address] = symbol;
        });

        // Function to get symbol from address using reverse mapping
        function getSymbolFromAddress(address) {
            if (!address) return null;
            
            const normalizedAddress = address.toLowerCase();
            return addressToSymbol[normalizedAddress] || null;
        }







        // Declare global variables that should be defined elsewhere in your application
        let tokenSwapper = contractAddress_Swapper;
        let tokenAddress= tokenAddresses["B0x"];
        let Address_ZEROXBTC_TESTNETCONTRACT = tokenAddresses["0xBTC"];

        let HookAddress = hookAddress;
        let MinamountOut; // Declare this variable globally

        async function getSwapOfTwoTokens() {
            if(!walletConnected){
               await connectWallet();
            }

    var selectSlippage = document.getElementById('slippageToleranceSwap');
    var selectSlippageValue = selectSlippage.value; // Returns: "0.1", "0.5", "1.0", or "2.0"
 const numberValueSlippage = parseFloat(selectSlippageValue.replace('%', ''));
    // Divide by 100 to get decimal
    const decimalValueSlippage= numberValueSlippage / 100;
    console.log("selectSlippageValue: ",selectSlippageValue);
    console.log("decimalValueSlippage: ",decimalValueSlippage);

const fromSelect = document.querySelector('#swap .form-group:nth-child(3) select');


// Get the currently selected value
const selectedValue = fromSelect.value;
console.log("Currently selected value:", selectedValue);

// Or get the selected option element itself
const selectedOption = fromSelect.options[fromSelect.selectedIndex];
console.log("Selected option text:", selectedOption.text);
console.log("Selected option value:", selectedOption.value);


const toSelect = document.querySelector('#swap .form-group:nth-child(6) select');


// Get the currently selected value
const toSelectValue = toSelect.value;
console.log("Currently selected value:", toSelectValue);



            var tokenInputAddress = tokenAddresses[selectedValue];
console.log("tokenInputAddresstokenInputAddresstokenInputAddresstokenInputAddress", tokenInputAddress);
            const amountInput = document.querySelector('#swap .form-group:nth-child(4) input');
// Get the currently selected value
const selectedValue2 = amountInput.value;
console.log("Currently amountInput value:", selectedValue2);
            var amountToSwap = ethers.utils.parseUnits(selectedValue2, 18);  // Correctly represents 12 * 10^8
            
            if(selectedValue=="0xBTC"){
                    console.log("LOGGED 0xBTC selected Value");
             amountToSwap = ethers.utils.parseUnits(selectedValue2, 8);  // Correctly represents 12 * 10^8
            }
            let amountOut = 0;
const tokenSwapperABI = [
    // Your existing getOutput function
    {
        "inputs": [
            {"name": "tokenZeroxBTC", "type": "address"},
            {"name": "tokenBZeroX", "type": "address"}, 
            {"name": "tokenIn", "type": "address"},
            {"name": "hookAddress", "type": "address"},
            {"name": "amountIn", "type": "uint128"}
        ],
        "name": "getOutput",
        "outputs": [{"name": "amountOut", "type": "uint256"}],
        "stateMutability": "view",
        "type": "function"
    },
    // Add the swapTokenTWOTOKENS function
    {
        "inputs": [
            {"name": "tokenA", "type": "address"},
            {"name": "tokenB", "type": "address"},
            {"name": "tokenIn", "type": "address"},
            {"name": "tokenOut", "type": "address"},
            {"name": "amountIn", "type": "uint256"},
            {"name": "minAmountOut", "type": "uint256"},
            {"name": "hookAddress", "type": "address"},
            {"name": "WhereToSendFunds", "type": "address"}
        ],
        "name": "swapTokenTWOTOKENS",
        "outputs": [{"name": "", "type": "bool"}],
        "stateMutability": "nonpayable", // This will modify state
        "type": "function"
    }
];


                tokenSwapperContract = new ethers.Contract(
                    contractAddress_Swapper, // your tokenSwapper contract address
                    tokenSwapperABI,
                    signer // Use signer since the function isn't view/pure
                );

            try {
                // Call the view function
                const result = await tokenSwapperContract.callStatic.getOutput(
                    Address_ZEROXBTC_TESTNETCONTRACT, 
                    tokenAddress, 
                    tokenInputAddress, 
                    HookAddress, 
                    amountToSwap
                );

                // First debug what we're getting back
                console.log("Raw result type:", typeof result);
                console.log("Raw result structure:", Object.keys(result).join(", "));
                
                if (typeof result === 'bigint' || typeof result === 'number') {
                    // If it's already a primitive value
                    amountOut = result;
                } else if (result._isBigNumber || result instanceof ethers.BigNumber) {
                    // For ethers v5 BigNumber
                    amountOut = result;
                } else if (typeof result === 'object' && result !== null) {
                    // For objects, try to extract the value
                    // With ethers v6, we might get the value directly
                    if (typeof result.toString === 'function' && result.toString().match(/^[0-9]+$/)) {
                        amountOut = result;
                    } else {
                        // Attempt to extract value based on common patterns
                        amountOut = result[0] || result.amountOut || result._hex || result.value || result;
                    }
                }
                
                console.log(`Found valid amountOut: ${amountOut.toString()}`);
                const formattedResult = ethers.utils.formatEther(result);
                // Format to display as a readable number
                let readableAmountOut2Output = ethers.utils.formatEther(amountOut);
                let readableAmountIN2Input = ethers.utils.formatUnits(amountToSwap, 8);

                if (tokenInputAddress == Address_ZEROXBTC_TESTNETCONTRACT) {
                    // Keep the current formatting
                } else {
                    readableAmountOut2Output = ethers.utils.formatUnits(amountOut, 8);
                    readableAmountIN2Input = ethers.utils.formatEther(amountToSwap);
                }

                // Fix the BigInt arithmetic issue
                if (typeof amountOut === 'bigint') {
                    MinamountOut = amountOut*((1-decimalValueSlippage)*1000n)/10000n; // Use 10n for BigInt
                } else {
                    MinamountOut = amountOut*((1-decimalValueSlippage)*1000)/10000;
                }
                
                    alert(`You will trade `+ readableAmountIN2Input+ ` `+selectedValue+ " for "+ readableAmountOut2Output+ " "+toSelectValue);
                

                console.log(`Predicted amountOut: ${amountToSwap} tokens for ${MinamountOut} tokens input`);
                console.log(`Predicted amountOut: ${readableAmountIN2Input} tokens for ${readableAmountOut2Output} tokens input`);
                
            } catch (error) {
                console.error(`Error finding valid getOutput for swap:`, error);
                return; // Exit early if there's an error
            }

            console.log("\n\n!!!!!!!!!!!!!!!!!!!SWAPTWO TOKENS STUFF INFO BELOW!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
            console.log("TokenAddress: ", tokenAddress);
            console.log("Address_ZEROXBTC_TESTNETCONTRACT: ", Address_ZEROXBTC_TESTNETCONTRACT);
            console.log("TokenIn: ", tokenAddress);
            console.log("TokenOut: ", Address_ZEROXBTC_TESTNETCONTRACT);
            console.log("AmountIn: ", amountToSwap);
            console.log("MinAmountOut: ", MinamountOut);
            console.log("HookAddress: ", HookAddress);
            console.log("WheretoSendFunds: ", userAddress);
            
                console.log(`Found valid amountOut: ${amountOut.toString()}`);
                console.log(`Found valid MinamountOut amountOut: ${MinamountOut.toString()}`);









            if(Address_ZEROXBTC_TESTNETCONTRACT == tokenInputAddress){





const amountToSwapBN = ethers.BigNumber.from(amountToSwap.toString());
const minAmountOutBN = ethers.BigNumber.from(MinamountOut.toString());
            await approveIfNeeded(Address_ZEROXBTC_TESTNETCONTRACT, contractAddress_Swapper, amountToSwapBN);
            console.log("amountToSwapBN: ", amountToSwapBN);
            console.log("minAmountOutBN: ", minAmountOutBN);
            console.log("tokenAddress: ", tokenAddress);
            console.log("Address_ZEROXBTC_TESTNETCONTRACT: ", Address_ZEROXBTC_TESTNETCONTRACT);
            console.log("HookAddress: ", HookAddress);
            console.log("userAddress: ", userAddress);
            console.log("minAmountOutBN: ", minAmountOutBN);
            try {
                // Call the swap function
                const tx = await tokenSwapperContract.swapTokenTWOTOKENS(
                    tokenAddress, 
                    Address_ZEROXBTC_TESTNETCONTRACT, 
                    Address_ZEROXBTC_TESTNETCONTRACT, 
                    tokenAddress, 
                    amountToSwapBN, 
                    minAmountOutBN, 
                    HookAddress, 
                    userAddress
                );
                
                console.log("swapTokenTWOTOKENS transaction sent:", tx.hash);
                await tx.wait();
                console.log("Transaction confirmed!");
                alert("Successful Swap!")
                
            } catch (error) {
                console.error(`Error finding swapTokenTWOTOKENS stuff:`, error);
                alert("User rejected request for swap!")
            }




        }else{



const amountToSwapBN = ethers.BigNumber.from(amountToSwap.toString());
const minAmountOutBN = ethers.BigNumber.from(MinamountOut.toFixed(0).toString());


                                await approveIfNeeded(tokenAddress, contractAddress_Swapper, amountToSwapBN);
            try {
                // Call the swap function
                const tx = await tokenSwapperContract.swapTokenTWOTOKENS(
                    tokenAddress, 
                    Address_ZEROXBTC_TESTNETCONTRACT, 
                    tokenAddress, 
                    Address_ZEROXBTC_TESTNETCONTRACT, 
                    amountToSwapBN, 
                    minAmountOutBN, 
                    HookAddress, 
                    userAddress
                );
                
                console.log("swapTokenTWOTOKENS transaction sent:", tx.hash);
                await tx.wait();
                console.log("Transaction confirmed!");
                await new Promise(resolve => setTimeout(resolve, 3000));
                await throttledGetSqrtRtAndPriceRatio("SwapFunction");
                fetchBalances();
            } catch (error) {
                console.error(`Error finding swapTokenTWOTOKENS stuff:`, error);
            }
        }





    }

    


 async function getEstimate() {


            if(!walletConnected){
               await connectWallet();
            }

const fromSelect = document.querySelector('#swap .form-group:nth-child(3) select');


// Get the currently selected value
const selectedValue = fromSelect.value;
console.log("Currently selected value:", selectedValue);

// Or get the selected option element itself
const selectedOption = fromSelect.options[fromSelect.selectedIndex];
console.log("Selected option text:", selectedOption.text);
console.log("Selected option value:", selectedOption.value);


            var tokenInputAddress = tokenAddresses[selectedValue];
console.log("tokenInputAddresstokenInputAddresstokenInputAddresstokenInputAddress", tokenInputAddress);
            const amountInput = document.querySelector('#swap .form-group:nth-child(4) input');
// Get the currently selected value
const selectedValue2 = amountInput.value;
console.log("Currently amountInput value:", selectedValue2);
            var amountToSwap = ethers.utils.parseUnits(selectedValue2, 18);  // Correctly represents 12 * 10^8
            if(amountToSwap == 0){
                console.log("AmountToSwap 0 returning");
                return;
            }

            if(selectedValue == "0xBTC") {
                console.log("LOGGED 0xBTC selected Value");
                
                const numericValue = parseFloat(selectedValue2);
                
                // Count decimal places
                const decimalPlaces = (selectedValue2.split('.')[1] || '').length;
                
                let valueToUse;
                if (decimalPlaces > 8) {
                    // Chop off decimals after 8th place (no rounding)
                    const parts = selectedValue2.split('.');
                    valueToUse = parts[0] + '.' + parts[1].substring(0, 8);
                    console.log(`Truncated from ${decimalPlaces} to 8 decimal places: ${valueToUse}`);
                } else {
                    valueToUse = selectedValue2; // Keep original string
                }
                    amountToSwap = ethers.utils.parseUnits(valueToUse, 8);  // Correctly represents 12 * 10^8
             amountInput.value = ethers.utils.formatUnits(amountToSwap, 8);;

            }
            let amountOut = 0;
const tokenSwapperABI = [
    // Your existing getOutput function
    {
        "inputs": [
            {"name": "tokenZeroxBTC", "type": "address"},
            {"name": "tokenBZeroX", "type": "address"}, 
            {"name": "tokenIn", "type": "address"},
            {"name": "hookAddress", "type": "address"},
            {"name": "amountIn", "type": "uint128"}
        ],
        "name": "getOutput",
        "outputs": [{"name": "amountOut", "type": "uint256"}],
        "stateMutability": "view",
        "type": "function"
    },
    // Add the swapTokenTWOTOKENS function
    {
        "inputs": [
            {"name": "tokenA", "type": "address"},
            {"name": "tokenB", "type": "address"},
            {"name": "tokenIn", "type": "address"},
            {"name": "tokenOut", "type": "address"},
            {"name": "amountIn", "type": "uint256"},
            {"name": "minAmountOut", "type": "uint256"},
            {"name": "hookAddress", "type": "address"},
            {"name": "WhereToSendFunds", "type": "address"}
        ],
        "name": "swapTokenTWOTOKENS",
        "outputs": [{"name": "", "type": "bool"}],
        "stateMutability": "nonpayable", // This will modify state
        "type": "function"
    }
];


                tokenSwapperContract = new ethers.Contract(
                    contractAddress_Swapper, // your tokenSwapper contract address
                    tokenSwapperABI,
                    signer // Use signer since the function isn't view/pure
                );
                

                /*
                console.log("EERRROR HERE");
                console.log("EERRROR Address_ZEROXBTC_TESTNETCONTRACT: ",Address_ZEROXBTC_TESTNETCONTRACT);
                console.log("EERRROR tokenAddress: ",tokenAddress);
                console.log("EERRROR tokenInputAddress: ",tokenInputAddress);
                console.log("EERRROR HookAddress: ",HookAddress);
                console.log("EERRROR amountToSwap: ",amountToSwap);
                console.log("EERRROR amountToSwap: ",amountToSwap);
                console.log("EERRROR contractAddress_Swapper: ",contractAddress_Swapper);
                */

                // Call the view function
                const result = await tokenSwapperContract.callStatic.getOutput(
                    Address_ZEROXBTC_TESTNETCONTRACT, 
                    tokenAddress, 
                    tokenInputAddress, 
                    HookAddress, 
                    amountToSwap
                );

                // First debug what we're getting back
                console.log("Raw result type:", typeof result);
                console.log("Raw result structure:", Object.keys(result).join(", "));
                
                if (typeof result === 'bigint' || typeof result === 'number') {
                    // If it's already a primitive value
                    amountOut = result;
                } else if (result._isBigNumber || result instanceof ethers.BigNumber) {
                    // For ethers v5 BigNumber
                    amountOut = result;
                } else if (typeof result === 'object' && result !== null) {
                    // For objects, try to extract the value
                    // With ethers v6, we might get the value directly
                    if (typeof result.toString === 'function' && result.toString().match(/^[0-9]+$/)) {
                        amountOut = result;
                    } else {
                        // Attempt to extract value based on common patterns
                        amountOut = result[0] || result.amountOut || result._hex || result.value || result;
                    }
                }
                
                console.log(`Found valid amountOut: ${amountOut.toString()}`);
                const formattedResult = ethers.utils.formatEther(result);
                // Format to display as a readable number
                let readableAmountOut2Output = ethers.utils.formatEther(amountOut);
                let readableAmountIN2Input = ethers.utils.formatUnits(amountToSwap, 8);

                if (tokenInputAddress == Address_ZEROXBTC_TESTNETCONTRACT) {
                    // Keep the current formatting
                } else {
                    readableAmountOut2Output = ethers.utils.formatUnits(amountOut, 8);
                    readableAmountIN2Input = ethers.utils.formatEther(amountToSwap);
                }

                // Fix the BigInt arithmetic issue
                if (typeof amountOut === 'bigint') {
                    MinamountOut = amountOut - 10n; // Use 10n for BigInt
                } else {
                    MinamountOut = amountOut - 10;
                }
                
                                // Update the estimated output display
                const estimatedOutputInput = document.querySelector('#swap .form-group:nth-child(7) input');

            
                // Fix 4: Using ethers.js formatUnits (if you're using ethers.js)
                if(selectedValue == "0xBTC"){
                    estimatedOutputInput.value = ethers.utils.formatUnits(amountOut, 18);
                } else {
                    estimatedOutputInput.value = ethers.utils.formatUnits(amountOut, 8);
                }
           }
    

const amountInput = document.querySelector('#swap .form-group:nth-child(4) input');

let debounceTimerSwap;

// Function to handle amount changes
function handleAmountChange() {
    const amount = parseFloat(this.value) || 0;
    console.log("Amount changed:", amount);
    
    // Clear the previous timer
    clearTimeout(debounceTimerSwap);
    
    // Only call getEstimate if amount > 0
    if (amount > 0) {
        // Set a new timer for 1 second delay
        debounceTimerSwap = setTimeout(() => {
            getEstimate();
        }, 1000); // 1000ms = 1 second delay
    }
}
// Listen for both input and change events
amountInput.addEventListener('input', handleAmountChange);
amountInput.addEventListener('change', handleAmountChange);



        function calculateNewRewards() {
            // This would calculate based on additional staking amount
            console.log('Calculating new rewards...');
            // Update the rewards amount
            rewardsAmount.textContent = '15.67 STAKE';
            rewardsUSD.textContent = '≈ $31.34 USD';
            APYPercentage.textContent = '99.99 %';
        }

        // Swap functions
       async function executeSwap() {

    try {
        // Check if wallet is connected
        if (!window.ethereum || !userAddress) {
            alert('Please connect your wallet first!');
            return;
        }

        // Get form values
        const fromToken = document.getElementById('fromToken').value;
        const toToken = document.getElementById('toToken').value;
        const amountInput = document.querySelector('#swap input[type="number"]');
        const amount = amountInput.value;

        // Validation
        if (!amount || parseFloat(amount) <= 0) {
            alert('Please enter a valid amount to swap');
            return;
        }

        if (fromToken === toToken) {
            alert('Cannot swap the same token');
            return;
        }

        // Only support swapping TO ETH for now (based on your contract function)
     
        await getSwapOfTwoTokens();
        alert('Swap completed successfully!');
        
        // Refresh balances
        if (typeof fetchBalances === 'function') {
            fetchBalances();
        }
       await getTokenIDsOwnedByMetamask();
        // Clear the input
        amountInput.value = '0.0';

    } catch (error) {
        console.error('Swap failed:', error);
        
        // Handle specific error types
        if (error.code === 4001) {
            alert('Transaction cancelled by user');
        } else if (error.code === -32603) {
            alert('Transaction failed. Please check your balance and try again.');
        } else {
            alert('Swap failed: ' + (error.message || error.reason || 'Unknown error'));
        }
    }
}




        // Add this function to check ownership and show/hide admin tab
async function checkAdminAccess() {
    try {        
        
        console.log("user address checkAdminAccess Function : ",userAddress);
        console.log("walletConnected checkAdminAccess Function : ",walletConnected);

        if (!userAddress || !walletConnected) {
            hideAdminTab();
            return;
            }
    // Global contract variables
    let lpRewardsContract = null;
    let hookContract = null;
// ABI for owner function (standard Ownable contract)
const OWNER_ABI = [
    {
        "inputs": [],
        "name": "owner",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
];

            // Initialize LP Rewards contract
        if (contractAddressLPRewardsStaking) {
            lpRewardsContract = new ethers.Contract(
                contractAddressLPRewardsStaking, 
                OWNER_ABI, 
                provider // Use provider for read-only calls
            );
            console.log("LP Rewards contract initialized:", contractAddressLPRewardsStaking);
        }

        // Initialize Hook contract
        if (HookAddress) {
            hookContract = new ethers.Contract(
                HookAddress, 
                OWNER_ABI, 
                provider // Use provider for read-only calls
            );
            console.log("Hook contract initialized:", HookAddress);
        }




        // Check if user is owner of LP Rewards Staking contract
        let isLPOwner = false;
        try {
            if (contractAddressLPRewardsStaking && lpRewardsContract) {
                const lpOwner = await lpRewardsContract.owner();
                isLPOwner = lpOwner.toLowerCase() === userAddress.toLowerCase();
                console.log("LP Rewards owner:", lpOwner);
                console.log("Is LP owner:", isLPOwner);
            }
        } catch (error) {
            console.log("Error checking LP owner:", error);
        }

        // Check if user is owner of Hook contract
        let isHookOwner = false;
        try {
            if (HookAddress && hookContract) {
                const hookOwner = await hookContract.owner();
                isHookOwner = hookOwner.toLowerCase() === userAddress.toLowerCase();
                console.log("Hook owner:", hookOwner);
                console.log("Is Hook owner:", isHookOwner);
            }
        } catch (error) {
            console.log("Error checking Hook owner:", error);
        }

        // Show admin tab if user owns either contract
        if (isLPOwner || isHookOwner) {
            showAdminTab();
            console.log("User has admin access");
        } else {
            hideAdminTab();
            console.log("User does not have admin access");
        }

    } catch (error) {
        console.error("Error checking admin access:", error);
        hideAdminTab();
    }
}

function showAdminTab() {
    let adminTab = document.getElementById('admin-tab');
    if (!adminTab) {
        // Create the admin tab if it doesn't exist
        const navTabs = document.querySelector('.nav-tabs');
        adminTab = document.createElement('button');
        adminTab.id = 'admin-tab';
        adminTab.className = 'nav-tab';
        adminTab.onclick = () => switchTab('admin-functions');
        adminTab.textContent = 'Admin Functions';
        navTabs.appendChild(adminTab);
    }
    adminTab.style.display = 'inline-block';
}

function hideAdminTab() {
    const adminTab = document.getElementById('admin-tab');
    if (adminTab) {
        adminTab.style.display = 'none';
    }
}




        async function getFacuetTokens(){

            if(!walletConnected){
               await connectWallet();
            }


                // Check if wallet is connected
                if (!window.ethereum || !userAddress) {
                    alert('Please connect your wallet first!');
                    return;
                }

                const faucetABI_0xBTC = [
            // Your existing getOutput function
            {
                "inputs": [],
                "name": "getFacuetTokens_Testnet_0xBTC",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            }
            
        ];

                const faucetABI_MainToken = [
            // Your existing getOutput function
        {
                "inputs": [],
                "name": "getFacuetTokens_Testnet",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            }

            
        ];



                        Address_ZEROXBTC_TESTNETCONTRACT_CONTRACT = new ethers.Contract(
                            Address_ZEROXBTC_TESTNETCONTRACT, // your tokenSwapper contract address
                            faucetABI_0xBTC,
                            signer // Use signer since the function isn't view/pure
                        );
                        
        MAIN_TOKEN_CONTRACT = new ethers.Contract(
                            tokenAddress, // your tokenSwapper contract address
                            faucetABI_MainToken,
                            signer // Use signer since the function isn't view/pure
                        );
                        



        const tx = await Address_ZEROXBTC_TESTNETCONTRACT_CONTRACT.getFacuetTokens_Testnet_0xBTC();


                        console.log("getFacuetTokens_Testnet_0xBTC transaction sent:", tx.hash);
                        await tx.wait();
                        console.log("Transaction confirmed!");


        const tx2 = await MAIN_TOKEN_CONTRACT.getFacuetTokens_Testnet();


                        console.log("getFacuetTokens_Testnet transaction sent:", tx2.hash);
                        await tx2.wait();
                        console.log("Transaction confirmed!");


                    fetchBalances();



        }

























































const erc20ABI = [
    {"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
    {"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},
    {"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
    {"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},
    {"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},
    {"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},
    {"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
    {"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},
    {"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"}
];

async function checkAllowance(tokenToCheck, spenderAddress, requiredAmount) {

            if(!walletConnected){
               await connectWallet();
            }
    try {
        let tokenContract;
        let tokenName;
        

        // Determine which token to check
        if (tokenToCheck === tokenAddress) {
            tokenContract = new ethers.Contract(tokenAddress, erc20ABI, signer);
            tokenName = "B0x";
        } else if (tokenToCheck === Address_ZEROXBTC_TESTNETCONTRACT) {
            tokenContract = new ethers.Contract(Address_ZEROXBTC_TESTNETCONTRACT, erc20ABI, signer);
            tokenName = "0xBTC";
        } else if (tokenToCheck === USDCToken) {
            tokenContract = new ethers.Contract(USDCToken, erc20ABI, signer);
            tokenName = "USDC";
        }else {
            console.error("Unknown token address!");
            return false;
        }

requiredAmount = toBigNumber(requiredAmount);              
        // Get current allowance
        const userAddress = await signer.getAddress();
        const currentAllowance = await tokenContract.allowance(userAddress, spenderAddress);
        
        console.log(`Current ${tokenName} allowance:`, ethers.utils.formatEther(currentAllowance));
        if(tokenName == "0xBTC"){

            console.log(`Required ${tokenName} amount:`, ethers.utils.formatUnits(requiredAmount,8));
        }else{

            console.log(`Required ${tokenName} amount:`, ethers.utils.formatEther(requiredAmount));
        
        }
        
        // Check if allowance is sufficient
        if (currentAllowance.gte(requiredAmount)) {
            alert(`${tokenName} allowance is sufficient. No approval needed.`);
            return true;
        } else {
            alert(`${tokenName} allowance is insufficient. Approval needed.`);
            return false;
        }
        
    } catch (error) {
        console.error("Allowance check failed:", error);
        alert(`Allowance check failed: ${error.message}`);
        return false;
    }
}



















function toBigNumber(value) {
    if (ethers.BigNumber.isBigNumber(value)) {
        return value;
    }
    
    if (typeof value === 'number') {
        // Convert scientific notation to proper integer string
        if (value >= 1e20 || value <= -1e20) {
            // Use Number.prototype.toPrecision to get full precision
            const str = value.toPrecision().replace('.', '').replace(/e.*$/, '');
            return ethers.BigNumber.from(str);
        }
        return ethers.BigNumber.from(Math.floor(value).toString());
    }
    
    // Handle string values
    if (typeof value === 'string') {
        if (value.includes('e') || value.includes('E')) {
            const num = parseFloat(value);
            return toBigNumber(num); // Recursive call to handle as number
        }
        // Remove any decimal places for integer conversion
        return ethers.BigNumber.from(value.split('.')[0]);
    }
    
    return ethers.BigNumber.from(value.toString().split('.')[0]);
}



// Fix: Handle arrays by summing all BigNumbers in each array
function sumBigNumberArray(bigNumberArray) {
    if (!Array.isArray(bigNumberArray)) {
        return toBigNumber(bigNumberArray);
    }
    
    let sum = ethers.BigNumber.from(0);
    for (let i = 0; i < bigNumberArray.length; i++) {
        if (ethers.BigNumber.isBigNumber(bigNumberArray[i])) {
            sum = sum.add(bigNumberArray[i]);
        } else {
            sum = sum.add(toBigNumber(bigNumberArray[i]));
        }
    }
    return sum;
}

// Approve function
async function approveToken(tokenToApprove, spenderAddress, amount) {

            if(!walletConnected){
               await connectWallet();
            }
    try {
        alert(`Approving ${tokenToApprove} token...`);
        
        let tokenContract;
        

        // Determine which token to approve
        if (tokenToApprove === tokenAddress) {
            // B0x token
            tokenContract = new ethers.Contract(tokenAddress, erc20ABI, signer);
            alert("Approving B0x token for spending...");
        } else if (tokenToApprove === Address_ZEROXBTC_TESTNETCONTRACT) {
            // 0xBTC token  
            tokenContract = new ethers.Contract(Address_ZEROXBTC_TESTNETCONTRACT, erc20ABI, signer);
            alert("Approving 0xBTC token for spending...");
        } else if (tokenToApprove === USDCToken) {
            tokenContract = new ethers.Contract(USDCToken, erc20ABI, signer);
            alert("Approving USDC token for spending");
        }else {
            alert("Unknown token address!");
            return false;
        }
        
        // Send approval transaction
        const approveTx = await tokenContract.approve(spenderAddress, amount);
        alert("Approval transaction sent! Waiting for confirmation...");
        
        // Wait for confirmation
        await approveTx.wait();
        alert("Token approval confirmed!");
        
        return true;
        
    } catch (error) {
        console.error("Approval failed:", error);
        alert(`Approval failed: ${error.message}`);
        return false;
    }
}

async function approveIfNeeded(tokenToApprove, spenderAddress, requiredAmount) {
    try {
        // First check if approval is needed
        const allowanceSufficient = await checkAllowance(tokenToApprove, spenderAddress, requiredAmount);
        
        if (allowanceSufficient) {
            console.log("Approval not needed - sufficient allowance exists");
            return true;
        }
        
        // If not sufficient, request approval for max amount
        alert("Requesting approval for unlimited amount to avoid future approvals...");
        const approvalSuccess = await approveToken(tokenToApprove, spenderAddress, ethers.constants.MaxUint256);
        
        return approvalSuccess;
        
    } catch (error) {
        console.error("Approve if needed failed:", error);
        alert(`Approval process failed: ${error.message}`);
        return false;
    }
}

// Usage examples:
// Check allowance only:
// checkAllowance(tokenAddress, POOL_MANAGER_ADDRESS, ethers.utils.parseEther("100"));

// Check and approve if needed:














// Helper function for 24-bit sign extension
function signExtend24Bit(value) {
  const SIGN_BIT = 0x800000; // Bit 23 for 24-bit numbers
  const MASK_24BIT = 0xFFFFFF;
  
  if (value & SIGN_BIT) {
    // Negative number - extend with 1s
    return (value | (~MASK_24BIT)) | 0; // | 0 converts to 32-bit signed int
  } else {
    // Positive number
    return value;
  }
}
// Direct JavaScript equivalents of your Solidity functions
function TOtickLower(info) {
  const TICK_LOWER_OFFSET = 8;
  const shifted = Number((BigInt(info) >> BigInt(TICK_LOWER_OFFSET)) & 0xFFFFFFn);
  return signExtend24Bit(shifted);
}

function TOtickUpper(info) {
  const TICK_UPPER_OFFSET = 32;
  const shifted = Number((BigInt(info) >> BigInt(TICK_UPPER_OFFSET)) & 0xFFFFFFn);
  return signExtend24Bit(shifted);
}


  

function loadPositionsIntoDappSelections(){
    // Set up position selector for regular increase
    const positionSelect = document.querySelector('#increase select');
    if (positionSelect) {
        // Store current selection
        const currentValue = positionSelect.value;
        
        positionSelect.innerHTML = '';
        Object.values(positionData).forEach(position => {
            const option = document.createElement('option');
            option.value = position.id;
            option.textContent = `${position.pool} - ${position.feeTier} - Position #${position.id.split('_')[1]}`;
            positionSelect.appendChild(option);
        });
        
        // Restore previous selection if it still exists
        if (currentValue && positionSelect.querySelector(`option[value="${currentValue}"]`)) {
            positionSelect.value = currentValue;
        }
    }
    
    updatePositionInfo();// Set up position selector for decrease
    const positionSelect2 = document.querySelector('#decrease select');
    if (positionSelect2) {
        // Store current selection
        const currentValue2 = positionSelect2.value;
        positionSelect2.innerHTML = '';
        Object.values(positionData).forEach(position => {
            const option = document.createElement('option');
            option.value = position.id;
            option.textContent = `${position.pool} - ${position.feeTier} - Position #${position.id.split('_')[1]}`;
            positionSelect2.appendChild(option);
        });
        // Restore previous selection if it still exists
        if (currentValue2 && positionSelect2.querySelector(`option[value="${currentValue2}"]`)) {
            positionSelect2.value = currentValue2;
        }
    }
    updateDecreasePositionInfo();

    const positionSelect3 = document.querySelector('#staking-main-page select');
    console.log("stakingmianpageslect: ", positionSelect3);
    if (positionSelect3) {
        // Store current selection
        const currentValue3 = positionSelect3.value;
        positionSelect3.innerHTML = '';
        Object.values(positionData).forEach(position => {
            const option = document.createElement('option');
            option.value = position.id;
            option.textContent = `${position.pool} - ${position.feeTier} - Position #${position.id.split('_')[1]}`;
            positionSelect3.appendChild(option);
        });
        // Restore previous selection if it still exists
        if (currentValue3 && positionSelect3.querySelector(`option[value="${currentValue3}"]`)) {
            positionSelect3.value = currentValue3;
        }
    }
    updatePositionInfoMAIN_STAKING();

    const positionSelectMainPageWithdrawNFT = document.querySelector('#staking-main-page .form-group2 select');
    if (positionSelectMainPageWithdrawNFT) {
        // Store current selection
        const currentValueWithdrawNFT = positionSelectMainPageWithdrawNFT.value;
        positionSelectMainPageWithdrawNFT.innerHTML = '';
        Object.values(stakingPositionData).forEach(position => {
            const option = document.createElement('option');
            option.value = position.id;
            option.textContent = `${position.pool} - ${position.feeTier} - Stake Position #${position.id.split('_')[2]}`;
            positionSelectMainPageWithdrawNFT.appendChild(option);
        });
        // Restore previous selection if it still exists
        if (currentValueWithdrawNFT && positionSelectMainPageWithdrawNFT.querySelector(`option[value="${currentValueWithdrawNFT}"]`)) {
            positionSelectMainPageWithdrawNFT.value = currentValueWithdrawNFT;
        }
    }
    updatePositionInfoMAIN_UNSTAKING();

    // Set up position selector for stake increase
    const stakePositionSelect = document.querySelector('#stakeincrease select');
    if (stakePositionSelect) {
        // Store current selection
        const currentValueStakeIncrease = stakePositionSelect.value;
        stakePositionSelect.innerHTML = '';
        Object.values(stakingPositionData).forEach(position => {
            const option = document.createElement('option');
            option.value = position.id;
            option.textContent = `${position.pool} - ${position.feeTier} - Stake Position #${position.id.split('_')[2]}`;
            stakePositionSelect.appendChild(option);
        });
        // Restore previous selection if it still exists
        if (currentValueStakeIncrease && stakePositionSelect.querySelector(`option[value="${currentValueStakeIncrease}"]`)) {
            stakePositionSelect.value = currentValueStakeIncrease;
        }
    }
    updateStakePositionInfo();



    // Set up position selector for stake decrease
    const stakeDecreasePositionSelect = document.querySelector('#stake-decrease select');
    if (stakeDecreasePositionSelect) {
        // Store current selection
        const currentValueStakeDecrease = stakeDecreasePositionSelect.value;
        stakeDecreasePositionSelect.innerHTML = '';
        Object.values(stakingPositionData).forEach(position => {
            const option = document.createElement('option');
            option.value = position.id;
            option.textContent = `${position.pool} - ${position.feeTier} - Stake Position #${position.id.split('_')[2]}`;
            stakeDecreasePositionSelect.appendChild(option);
        });
        // Restore previous selection if it still exists
        if (currentValueStakeDecrease && stakeDecreasePositionSelect.querySelector(`option[value="${currentValueStakeDecrease}"]`)) {
            stakeDecreasePositionSelect.value = currentValueStakeDecrease;
        }
        stakeDecreasePositionSelect.addEventListener('change', updateStakeDecreasePositionInfo);
    }
    updateStakeDecreasePositionInfo();


}





function cleanupPositionData() {
    // Clean positionData
    Object.keys(positionData).forEach(key => {
        const idNumber = parseInt(key.split('_')[1]);
        if (idNumber > 0) {
            delete positionData[key];
        }
    });
    
    // Clean stakingPositionData
    Object.keys(stakingPositionData).forEach(key => {
        const idNumber = parseInt(key.split('_')[2]); // stake_position_X
        if (idNumber > 0) {
            delete stakingPositionData[key];
        }
    });
}



async function getTokenIDsOwnedByMetamask(){
    await getTokenIDsOwnedByUser(userAddress);

}


async function getTokenIDsOwnedByStaking(){
    await getTokenIDsOwnedByUser(contractAddressLPRewardsStaking);
}


async function getTokenIDsOwnedByUser(ADDRESSTOSEARCHOF){

  console.log("Calling findUserTokenIds for: ", ADDRESSTOSEARCHOF," to find all tokens owned by tokenAddress_Rewards aka Staking Contract");

            if(!walletConnected){
               await connectWallet();
            }

cleanupPositionData();
                    
    const minStaking = document.getElementById('minStaking').value || 0;
    const minUserHoldings = document.getElementById('minUserHoldings').value || 0;
    

    console.log("Global Settings variables to prevent spam!:minStaking: ", minStaking,"  &&&&& minUserHoldings: ", minUserHoldings);

// Compact ABI for findUserTokenIdswithMinimum function

positionFinderABI = [
    {
        "inputs": [
            {"internalType": "address", "name": "user", "type": "address"},
            {"internalType": "uint256", "name": "startId", "type": "uint256"},
            {"internalType": "uint256", "name": "endId", "type": "uint256"},
            {"internalType": "address", "name": "Token0", "type": "address"},
            {"internalType": "address", "name": "Token1", "type": "address"},
            {"internalType": "address", "name": "HookAddress", "type": "address"},
            {"internalType": "uint256", "name": "minTokenA", "type": "uint256"}
        ],
        "name": "findUserTokenIdswithMinimum",
        "outputs": [
            {"internalType": "uint256[]", "name": "ownedTokens", "type": "uint256[]"},
            {"internalType": "uint256[]", "name": "amountTokenA", "type": "uint256[]"},
            {"internalType": "uint256[]", "name": "amountTokenB", "type": "uint256[]"},
            {"internalType": "uint128[]", "name": "positionLiquidity", "type": "uint128[]"},
            {"internalType": "int128[]", "name": "feesOwedTokenA", "type": "int128[]"},
            {"internalType": "int128[]", "name": "feesOwedTokenB", "type": "int128[]"},
            {"internalType": "struct PoolKey[]", "name": "poolKeyz", "type": "tuple[]", 
                "components": [
                    {"internalType": "address", "name": "currency0", "type": "address"},
                    {"internalType": "address", "name": "currency1", "type": "address"},
                    {"internalType": "uint24", "name": "fee", "type": "uint24"},
                    {"internalType": "int24", "name": "tickSpacing", "type": "int24"},
                    {"internalType": "address", "name": "hooks", "type": "address"}
                ]
            },
            {"internalType": "uint256[]", "name": "poolInfo", "type": "uint256[]"}
        ],
        "stateMutability": "view",
        "type": "function"
    }, {
    "inputs": [
      {
        "internalType": "address",
        "name": "user",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "Token0",
        "type": "address"
      },
      {
        "internalType": "address",
        "name": "Token1",
        "type": "address"
      },
      {
        "internalType": "uint256",
        "name": "minAmount0",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "startIndex",
        "type": "uint256"
      },
      {
        "internalType": "uint256",
        "name": "count",
        "type": "uint256"
      },
      {
        "internalType": "address",
        "name": "HookAddress",
        "type": "address"
      }
    ],
    "name": "getIDSofStakedTokensForUserwithMinimum",
    "outputs": [
      {
        "internalType": "uint256[]",
        "name": "ids",
        "type": "uint256[]"
      },
      {
        "internalType": "uint256[]",
        "name": "LiquidityTokenA",
        "type": "uint256[]"
      },
      {
        "internalType": "uint256[]",
        "name": "LiquidityTokenB",
        "type": "uint256[]"
      },
      {
        "internalType": "uint128[]",
        "name": "positionLiquidity",
        "type": "uint128[]"
      },
      {
        "internalType": "uint256[]",
        "name": "timeStakedAt",
        "type": "uint256[]"
      },
      {
        "internalType": "uint256[]",
        "name": "multiplierPenalty",
        "type": "uint256[]"
      },
      {
        "internalType": "address[]",
        "name": "currency0",
        "type": "address[]"
      },
      {
        "internalType": "address[]",
        "name": "currency1",
        "type": "address[]"
      },
      {
        "internalType": "uint256[]",
        "name": "poolInfo",
        "type": "uint256[]"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }

     ,{
        "inputs": [],
        "name": "getMaxUniswapIDPossible",
        "outputs": [
            {"internalType": "uint256", "name": "", "type": "uint256"}
        ],
        "stateMutability": "view",
        "type": "function"
    },
      {
    "inputs": [
      {
        "internalType": "address",
        "name": "user",
        "type": "address"
      }
    ],
    "name": "getMaxStakedIDforUser",
    "outputs": [
      {
        "internalType": "uint256",
        "name": "",
        "type": "uint256"
      }
    ],
    "stateMutability": "view",
    "type": "function"
  }

];


                        tokenPositionFinderPro = new ethers.Contract(
                    contractAddress_PositionFinderPro, // your tokenSwapper contract address
                    positionFinderABI,
                    signer // Use signer since the function isn't view/pure
                );






console.log("getting getMaxUniswapIDPossible!");
var MAXTOKENPOSSIBLE = 0;
var maxTokenPossible =0;
      try {
        // Call the view function
        const result = await tokenPositionFinderPro.getMaxUniswapIDPossible();



          // First debug what we're getting back
          console.log("Raw result type:", typeof result);
          console.log("Raw result structure:", Object.keys(result).join(", "));
          
          if (typeof result === 'bigint' || typeof result === 'number') {
            // If it's already a primitive value
            MAXTOKENPOSSIBLE = result;
          } else if (result._isBigNumber || result instanceof ethers.BigNumber) {
            // For ethers v5 BigNumber
            MAXTOKENPOSSIBLE = result;
          } else if (typeof result === 'object' && result !== null) {
            // For objects, try to extract the value
            // With ethers v6, we might get the value directly
            if (typeof result.toString === 'function' && result.toString().match(/^[0-9]+$/)) {
              MAXTOKENPOSSIBLE = result;
            } else {
              // Attempt to extract value based on common patterns
              MAXTOKENPOSSIBLE = result[0] || result.amountOut || result._hex || result.value || result;
            }
          }
          
          console.log(`Found valid Uniswap v4 MAXTOKEN POSSIBLE: ${MAXTOKENPOSSIBLE.toString()}`);

        // CONVERT TO REGULAR NUMBER FOR LOOP
        if (typeof MAXTOKENPOSSIBLE === 'bigint') {
          maxTokenPossible = Number(MAXTOKENPOSSIBLE);
        } else if (MAXTOKENPOSSIBLE._isBigNumber || MAXTOKENPOSSIBLE instanceof ethers.BigNumber) {
          // For ethers v5
          maxTokenPossible = MAXTOKENPOSSIBLE.toNumber();
        } else if (typeof MAXTOKENPOSSIBLE.toString === 'function') {
          // For ethers v6 or other BigInt-like objects
          maxTokenPossible = Number(MAXTOKENPOSSIBLE.toString());
        } else {
          maxTokenPossible = Number(MAXTOKENPOSSIBLE);
        }

        console.log(`Converted to number for loop: ${maxTokenPossible}`);
        } catch (error) {
          console.error(`Error finding valid getMaxUniswapIDPossible for swap:`, error);
        }





try {
  const maxLoopLookups = 1000;
  var startSearchAt = 0; // Start searching from token ID 0
  const totalRange = maxTokenPossible - startSearchAt;
  const NumberOfLoops = Math.ceil(totalRange / maxLoopLookups);
  
  // Initialize as empty arrays (not undefined)
  let ownedTokenIds = [];
  let OWNEDtOKEN1 = [];
  let OWNEDtOKEN2 = [];
  let liquidity = [];
  let feesOwedToken1 = [];
  let feesOwedToken2 = [];
  let poolKeyi = [];
  let poolInfoi = [];
  
  for (let x = 0; x < NumberOfLoops; x++) {
    const startId = startSearchAt + (maxLoopLookups * x);
    const endId = Math.min(startId + maxLoopLookups - 1, maxTokenPossible-1);
    
    console.log("Looking at NFT ids in this search IDS:", startId, "to", endId);
    
    const result = await tokenPositionFinderPro.findUserTokenIdswithMinimum(
      ADDRESSTOSEARCHOF, 
      startId, 
      endId, 
      tokenAddress, 
      Address_ZEROXBTC_TESTNETCONTRACT,
      HookAddress,
      minUserHoldings
    );
    console.log("result: ", result);
    // Concatenate arrays properly using spread operator or concat
    ownedTokenIds = ownedTokenIds.concat(result[0]);
    OWNEDtOKEN1 = OWNEDtOKEN1.concat(result[1]);
    OWNEDtOKEN2 = OWNEDtOKEN2.concat(result[2]);
    liquidity = liquidity.concat(result[3]);
    feesOwedToken1 = feesOwedToken1.concat(result[4]);
    feesOwedToken2 = feesOwedToken2.concat(result[5]);
    poolKeyi = poolKeyi.concat(result[6]);
    poolInfoi = poolInfoi.concat(result[7]);

  }




  console.log("Number of tokens user owns that fit criteria for staking:", ownedTokenIds.length);
  console.log("NFTs owned by user :", ownedTokenIds.map(id => id.toString()));
  
  // Now loop through each token ID to get position details
  for (let i = 0; i < ownedTokenIds.length; i++) {
    const tokenId = ownedTokenIds[i];
    
    try {
        // Get pool and position info using V4 method with corrected types
       // const [poolKey, info2] = await positionManager.getPoolAndPositionInfo(tokenId);
        poolKey = poolKeyi[i];
        info2 = poolInfoi[i];
        console.log(`Token ID ${tokenId.toString()}:`);
        console.log(" Pool Key:");
        console.log("   Currency0:", poolKey.currency0);     // Now properly typed as address
        console.log("   Currency1:", poolKey.currency1);     // Now properly typed as address
        console.log("   Fee:", poolKey.fee.toString());
        console.log("   Tick Spacing:", poolKey.tickSpacing.toString());
        console.log("   Hooks:", poolKey.hooks);             // Now properly typed as address
        console.log(" Position Info (packed):", info2.toString());
        

  
  const decodedInfo = {
    tickLower: TOtickLower(info2.toString()),
    tickUpper: TOtickUpper(info2.toString())
  };

var feeVariable = (parseInt(poolKey.fee.toString()) / 10000).toFixed(2) + "%";
  if("8388608" == poolKey.fee.toString()){
    feeVariable ="Dynamic Fee";

  }
        console.log("   Fee:", poolKey.fee.toString());
        console.log(" Decoded Position Info:");
        console.log("   Tick Lower:", decodedInfo.tickLower);
        console.log("   Tick Upper:", decodedInfo.tickUpper);
        console.log("   tOKEN 1 AMOUNT:",OWNEDtOKEN1[i].toString()," address: ",poolKey.currency0);
        console.log("   tOKEN 2 AMOUNT:",OWNEDtOKEN2[i].toString()," address: ",poolKey.currency1);
        console.log("   Liquidity:", liquidity[i].toString());
        console.log("   FEES OWED Token 1 AMOUNT:",feesOwedToken1[i].toString());
        console.log("   FEES OWED Token 2 AMOUNT:",feesOwedToken2[i].toString());
      

var tokenASymbol = getSymbolFromAddress(poolKey.currency0);
var tokenBSymbol = getSymbolFromAddress(poolKey.currency1);

var tokenAIcon = tokenASymbol ? tokenASymbol[0] : "?"
var tokenBIcon = tokenBSymbol ? tokenBSymbol[0] : "?"

        console.log("   Token A Symbol :", tokenASymbol);
        console.log("   Token B Symbol :", tokenBSymbol);
        console.log("   tokenAIcon:",tokenAIcon);

        console.log("   tokenBIcon:",tokenBIcon);

  var poolNamepool = tokenASymbol+"/"+tokenBSymbol;
        console.log("   pool:",poolNamepool);
    var idNameID= `position_`+tokenId.toString();
        console.log("   id:",idNameID);

var decimalsTokenA = tokenAddressesDecimals[tokenASymbol];
var decimalsTokenB = tokenAddressesDecimals[tokenBSymbol];

        console.log("   decimalsTokenA:",decimalsTokenA);
        console.log("   decimalsTokenB:",decimalsTokenB);
        var formattedToken1 = ethers.utils.formatUnits(OWNEDtOKEN1[i],decimalsTokenA);
        var formattedToken2 = ethers.utils.formatUnits(OWNEDtOKEN2[i],decimalsTokenB);
        console.log("   formattedToken1:",formattedToken1);
        console.log("   formattedToken2:",formattedToken2);
        var formattedToken1FEESOWED = ethers.utils.formatUnits(feesOwedToken1[i],decimalsTokenA);
        var formattedToken2FEESOWED = ethers.utils.formatUnits(feesOwedToken2[i],decimalsTokenB);
        console.log("   ")


    // Add the new position to positionData
    positionData[idNameID] = {
        id: idNameID,
        pool: poolNamepool,
        feeTier: feeVariable,
        tokenA: tokenASymbol,
        tokenB: tokenBSymbol,
        currentLiquidity: parseFloat(liquidity[i].toString()),
        currentTokenA: formattedToken1,
        currentTokenB: formattedToken2,
        unclaimedFeesTokenA: formattedToken1FEESOWED,
        unclaimedFeesTokenB: formattedToken2FEESOWED,
        tokenAIcon: tokenAIcon,
        tokenBIcon: tokenBIcon
    };
























    } catch (positionError) {
      console.error(`Error getting position details for token ${tokenId}:`, positionError);
    }

  }
  
} catch (error) {
  console.error(`Error findUserTokenIds:`, error);
}




















  console.log("Calling getIDSofStakedTokensForUser of tokenAddress_Swapper");
// Get current time in milliseconds since Unix epoch
const currentTime = Date.now();
// If you need it in seconds (like Unix timestamp), divide by 1000
const currentTimeInSeconds = Math.floor(Date.now() / 1000);
console.log("Current Time in seconds since epoch", currentTimeInSeconds); // e.g., 1717974123






console.log("getting getMaxUniswapIDPossible!");
var MAXTOKENPOSSIBLE_STAKING = 0;
var maxTokenPossible_STAKING =0;
      try {
        // Call the view function
        const result = await tokenPositionFinderPro.getMaxStakedIDforUser(userAddress);



          // First debug what we're getting back
          console.log("Raw result type:", typeof result);
          console.log("Raw result structure:", Object.keys(result).join(", "));
          
          if (typeof result === 'bigint' || typeof result === 'number') {
            // If it's already a primitive value
            MAXTOKENPOSSIBLE_STAKING = result;
          } else if (result._isBigNumber || result instanceof ethers.BigNumber) {
            // For ethers v5 BigNumber
            MAXTOKENPOSSIBLE_STAKING = result;
          } else if (typeof result === 'object' && result !== null) {
            // For objects, try to extract the value
            // With ethers v6, we might get the value directly
            if (typeof result.toString === 'function' && result.toString().match(/^[0-9]+$/)) {
              MAXTOKENPOSSIBLE_STAKING = result;
            } else {
              // Attempt to extract value based on common patterns
              MAXTOKENPOSSIBLE_STAKING = result[0] || result.amountOut || result._hex || result.value || result;
            }
          }
          
          console.log(`Found valid Uniswap v4 MAXTOKEN POSSIBLE_STAKING: ${MAXTOKENPOSSIBLE_STAKING.toString()}`);

        // CONVERT TO REGULAR NUMBER FOR LOOP
        if (typeof MAXTOKENPOSSIBLE_STAKING === 'bigint') {
          maxTokenPossible_STAKING = Number(MAXTOKENPOSSIBLE_STAKING);
        } else if (MAXTOKENPOSSIBLE_STAKING._isBigNumber || MAXTOKENPOSSIBLE_STAKING instanceof ethers.BigNumber) {
          // For ethers v5
          maxTokenPossible_STAKING = MAXTOKENPOSSIBLE_STAKING.toNumber();
        } else if (typeof MAXTOKENPOSSIBLE_STAKING.toString === 'function') {
          // For ethers v6 or other BigInt-like objects
          maxTokenPossible_STAKING = Number(MAXTOKENPOSSIBLE_STAKING.toString());
        } else {
          maxTokenPossible_STAKING = Number(MAXTOKENPOSSIBLE_STAKING);
        }

        console.log(`Converted to number for loop: ${maxTokenPossible_STAKING}`);
        } catch (error) {
          console.error(`Error finding valid getMaxUniswapIDPossible for swap:`, error);
        }





  const maxLoopLookups = 1000;
  var startSearchAt = 0; // Start searching from token ID 0
  const totalRange = maxTokenPossible_STAKING+1 - startSearchAt;
  const NumberOfLoops = Math.ceil(totalRange / maxLoopLookups);
  
  // Initialize as empty arrays (not undefined)
  let ownedTokenIdsOFSwapperOnStaked = [];
  let OWNEDtOKEN1 = [];
  let OWNEDtOKEN2 = [];
  let liquidity = [];
  let timeStakedAT1 = [];
  let PenaltyForWithdraw = [];
  let poolKeyi = [];
  let poolInfoi = [];
  let PoolKeyCurrency0 = [];
  let PoolKeyCurrency1= [];
var totalStakedToken0 = toBigNumber(0);
var totalStakedToken1 = toBigNumber(0);
  for (let x = 0; x < NumberOfLoops; x++) {
    const startId = startSearchAt + (maxLoopLookups * x);
    const endId = Math.min(startId + maxLoopLookups -1, maxTokenPossible);
    
    console.log("Looking at NFT ids in this search IDS:", startId, "to", endId);
    console.log("DOING FUNCTION getIDSofStakedTokensForUserwithMinimum ");
    console.log("STAT((((((((((((((((((((((((((((((()))))))))))))))))))))))))))))) getIDSofStakedTokensForUserwithMinimum");
    console.log("ADDRESSTOSEARCHOF: ",ADDRESSTOSEARCHOF);
    console.log("tokenAddress: ",tokenAddress);
    console.log("Address_ZEROXBTC_TESTNETCONTRACT: ",Address_ZEROXBTC_TESTNETCONTRACT);
    console.log("minStaking: ",minStaking);
    console.log("startId: ",startId);
    console.log("maxLoopLookups: ",maxLoopLookups);
    console.log("HookAddress: ",HookAddress);
var result;
var worked = 1;
    try{
    result = await tokenPositionFinderPro.getIDSofStakedTokensForUserwithMinimum(
      ADDRESSTOSEARCHOF, 
      tokenAddress, 
      Address_ZEROXBTC_TESTNETCONTRACT,
      minStaking,
      startId, 
      maxLoopLookups,
      HookAddress
    );
    worked = 0;
    }catch (e){
        console.log("Error e: ",e );
    }
    if(worked == 1){


        await loadPositionsIntoDappSelections();
        return;
    }
    console.log("result[6]: ", result[6]);
    // Concatenate arrays properly using spread operator or concat
    ownedTokenIdsOFSwapperOnStaked = ownedTokenIdsOFSwapperOnStaked.concat(result[0]);


// Now add the arrays properly
totalStakedToken0 = totalStakedToken0.add(sumBigNumberArray(result[1]));
totalStakedToken1 = totalStakedToken1.add(sumBigNumberArray(result[2]));

    OWNEDtOKEN1 = OWNEDtOKEN1.concat(result[1]);
    OWNEDtOKEN2 = OWNEDtOKEN2.concat(result[2]);
    liquidity = liquidity.concat(result[3]);
    timeStakedAT1 = timeStakedAT1.concat(result[4]);
    PenaltyForWithdraw = PenaltyForWithdraw.concat(result[5]);
    PoolKeyCurrency0 = PoolKeyCurrency0.concat(result[6]);
    PoolKeyCurrency1 = PoolKeyCurrency1.concat(result[7]);
    poolInfoi = poolInfoi.concat(result[8]);
                
    

  }
console.log("RUNNING updateStakingValues");
updateStakingStats();

var tokenASymbol = getSymbolFromAddress(PoolKeyCurrency0[0]);
var decimalsTokenA = tokenAddressesDecimals[tokenASymbol];
var tokenBSymbol = getSymbolFromAddress(PoolKeyCurrency1[0]);
var decimalsTokenB = tokenAddressesDecimals[tokenBSymbol]; // Fixed: was tokenASymbol

// Format the BigNumbers to human-readable units
var formattedTokenA = ethers.utils.formatUnits(totalStakedToken0, decimalsTokenA);
var formattedTokenB = ethers.utils.formatUnits(totalStakedToken1, decimalsTokenB);

// Optional: Apply toFixed for consistent decimal places
var formattedTokenAWithDecimals = parseFloat(formattedTokenA).toFixed(6);
var formattedTokenBWithDecimals = parseFloat(formattedTokenB).toFixed(6);

updateStakingValues([formattedTokenAWithDecimals, formattedTokenBWithDecimals], '???');




/*

  console.log("Calling getIDSofStakedTokensForUserwithMinimum of tokenPositionFinderPro");
  console.log("Calling minStaking : ",minStaking);
        // Call the view function
        // Call the view function
          const result = await tokenPositionFinderPro.getIDSofStakedTokensForUserwithMinimum(userAddress, tokenAddress, Address_ZEROXBTC_TESTNETCONTRACT, HookAddress, minStaking);

                  
  // result is already the array of token IDs
  const ownedTokenIdsOFSwapperOnStaked = result[0]; // This is uint256[] - array of token IDs
  var OWNEDtOKEN1 = result[1];
  var OWNEDtOKEN2 = result[2];
  var liquidity = result[3];
  var timeStakedAT1 = result[4];
  var PenaltyForWithdraw = result[5];
   var poolKeyi = result[6];
  var  poolInfoi = result[7];*/
  
  console.log("Called getIDSofStakedTokensForUserwithMinimum of tokenPositionFinderPro");
  console.log("Number of tokens owned By user in the Staking Contract:", ownedTokenIdsOFSwapperOnStaked.length);
  console.log("NFTs Owned by User in Staking ContraT:", ownedTokenIdsOFSwapperOnStaked.map(id => id.toString()));
  var totalStaked
  // Now loop through each token ID to get position details
  for (let i = 0; i < ownedTokenIdsOFSwapperOnStaked.length; i++) {
    const tokenId = ownedTokenIdsOFSwapperOnStaked[i];
    info2 = poolInfoi[i];
    try {
        console.log(`Token ID ${tokenId.toString()}:`);
        console.log(" Pool Key:");
        console.log("   Currency0:", PoolKeyCurrency0[i]);     // Now properly typed as address
        console.log("   Currency1:", PoolKeyCurrency1[i]);     // Now properly typed as address
        console.log(" Time Staked AT:", timeStakedAT1[i].toString());
        console.log(" Position Info (packed):", info2.toString());
        
//just add function decodePositionInfo(packedInfo) { and return the decodedInfo if u want standalone function

 
  
  const decodedInfo = {
    tickLower: TOtickLower(info2.toString()),
    tickUpper: TOtickUpper(info2.toString())
  };
    var idNameID= `stake_position_`+tokenId.toString();
        console.log("   id:",idNameID);



        console.log(" Decoded Position Info:");
        console.log("   Tick Lower:", decodedInfo.tickLower);
        console.log("   Tick Upper:", decodedInfo.tickUpper);
        console.log("   Liquidity:", liquidity[i].toString());
        console.log("   tOKEN 1 AMOUNT Staked:",OWNEDtOKEN1[i].toString());
        console.log("   tOKEN 2 AMOUNT Staked:",OWNEDtOKEN2[i].toString());
        console.log(" Time Staked AT:", timeStakedAT1[i].toString());
        const timetotal = currentTimeInSeconds - Number(timeStakedAT1[i]);
        console.log(" total staked position time", timetotal.toString());
        console.log("Penalty for withdraw = ", PenaltyForWithdraw[i]);
        console.log("Penalty withdraw % = ", (PenaltyForWithdraw[i]/1000*100)," %");
      
var tokenASymbol = getSymbolFromAddress(PoolKeyCurrency0[i]);
var tokenBSymbol = getSymbolFromAddress(PoolKeyCurrency1[i]);

var tokenAIcon = tokenASymbol ? tokenASymbol[0] : "?"
var tokenBIcon = tokenBSymbol ? tokenBSymbol[0] : "?"

        console.log("   Token A Symbol :", tokenASymbol);
        console.log("   Token B Symbol :", tokenBSymbol);
        console.log("   tokenAIcon:",tokenAIcon);

        console.log("   tokenBIcon:",tokenBIcon);

  var poolNamepool = tokenASymbol+"/"+tokenBSymbol;
        console.log("   pool:",poolNamepool);

var decimalsTokenA = tokenAddressesDecimals[tokenASymbol];
var decimalsTokenB = tokenAddressesDecimals[tokenBSymbol];

        var formattedToken1 = ethers.utils.formatUnits(OWNEDtOKEN1[i],decimalsTokenA);
        var formattedToken2 = ethers.utils.formatUnits(OWNEDtOKEN2[i],decimalsTokenB);


var penaltyWithdrawString = (PenaltyForWithdraw[i]/1000*100) +"%"
    // Add the new position to positionData
    stakingPositionData[idNameID] = {
        id: idNameID,
        pool: poolNamepool,
        feeTier: "Dynamic Fee",
        tokenA: tokenASymbol,
        tokenB: tokenBSymbol,
        currentLiquidity: parseFloat(liquidity[i].toString()),
        currentTokenA: formattedToken1,
        currentTokenB: formattedToken2,
        tokenAIcon: tokenAIcon,
        tokenBIcon: tokenBIcon,
        apy: "99.9%",
        PenaltyForWithdraw: penaltyWithdrawString,

    };













  
  
} catch (error) {
  console.error(`Error findUserTokenIds:`, error);
}




      console.log("DONE FINDINGI USER IDS and Stakeded IDs in getTokenIDsOwnedByUser");


}


await loadPositionsIntoDappSelections();
console.log("Called loadPositionsIntoDappSelections after getTokenIDsOwnedByUser");

}



let lastCallTime = 0;
const THROTTLE_DELAY = 15000; // 15 seconds in milliseconds
async function throttledGetSqrtRtAndPriceRatio(NameOfFunction="General") {
    const now = Date.now();
    
    if (now - lastCallTime < THROTTLE_DELAY) {
        console.log(`Function throttled. Please wait ${Math.ceil((THROTTLE_DELAY - (now - lastCallTime)) / 1000)} more seconds.`);
        return null; // or return cached result if you have one
    }
    
    lastCallTime = now;
    return await getSqrtRtAndPriceRatio(NameOfFunction);
}


async function getRatioCreatePositiontokenB(){
    if(!walletConnected){
        await connectWallet();
    }

    // Get input elements first
    const createInputs = document.querySelectorAll('#create input[type="number"]');
    const amountInputA = createInputs[0]; // First number input (Amount A)
    const amountInputB = createInputs[1]; // Second number input (Amount B)


    // Add null checks to prevent errors
    if (!amountInputA || !amountInputB) {
        console.error("Could not find amount input fields");
        return;
    }

    const tokenASelect = document.querySelector('#create .form-group:nth-child(1) select');
    const tokenAValue = tokenASelect.value;
    console.log("Currently selected value TokenA:", tokenAValue);

    const tokenBSelect = document.querySelector('#create .form-group:nth-child(2) select');
    const tokenBvalue = tokenBSelect.value;
    console.log("Currently selected value TokenB:", tokenBvalue);

    const selectedOptionA = tokenASelect.options[tokenASelect.selectedIndex];
    const selectedOptionB = tokenBSelect.options[tokenBSelect.selectedIndex];
    
    var tokenAinputAddress = tokenAddresses[selectedOptionA.value];
    var tokenBinputAddress = tokenAddresses[selectedOptionB.value];

    // Get the currently selected values
    const tokenAInput = amountInputA.value;
    const tokenBInput = amountInputB.value;

    console.log("Currently amountInputA value:", tokenAInput);
    console.log("Currently amountInputB value:", tokenBInput);

    // Parse tokenB input (since this function is triggered by tokenB changes)
    var amountBtoCreate = ethers.utils.parseUnits(tokenBInput, selectedOptionB.value === "0xBTC" ? 8 : 18);

    await throttledGetSqrtRtAndPriceRatio();

    let amountToDeposit, amountWith8Decimals0xBTC;

    if(tokenBinputAddress === Address_ZEROXBTC_TESTNETCONTRACT) {
        // TokenB is 0xBTC, calculate how much TokenA (B0x) is needed
        console.log("TokenB is 0xBTC, calculating TokenA amount");
        
        const calculatedPriceRatio = BigInt(ratioz);
        const priceIn18Decimals = calculatedPriceRatio / (10n**10n);
        const amountZer0XIn18Decimals = BigInt(amountBtoCreate) * 10n**10n;
        
        amountWith8Decimals0xBTC = amountBtoCreate;
        amountToDeposit = (amountZer0XIn18Decimals * priceIn18Decimals) / (10n**18n);
        
        console.log(`TokenB (0xBTC) amount: ${ethers.utils.formatUnits(amountWith8Decimals0xBTC, 8)}`);
        console.log(`Calculated TokenA (B0x) amount: ${ethers.utils.formatEther(amountToDeposit)}`);
        
    } else {
        // TokenB is B0x, calculate how much TokenA (0xBTC) is needed
        console.log("TokenB is B0x, calculating TokenA amount");
        
        const priceRatio = BigInt(ratioz);
        amountToDeposit = amountBtoCreate;
        amountWith8Decimals0xBTC = (BigInt(amountBtoCreate) * (10n**18n)) / priceRatio;
        
        console.log(`TokenB (B0x) amount: ${ethers.utils.formatEther(amountToDeposit)}`);
        console.log(`Calculated TokenA (0xBTC) amount: ${ethers.utils.formatUnits(amountWith8Decimals0xBTC, 8)}`);
    }

    // Wallet balance checks
    var zeroxbtcdecimal = amountWith8Decimals0xBTC.toString();
    var wallet_zeroxbtc = ethers.utils.parseUnits(walletBalances['0xBTC'], 8).toString();
    
    if(parseFloat(zeroxbtcdecimal) > parseFloat(wallet_zeroxbtc)){
        alert("Too much 0xBTC - you don't have enough, lower the amount!");
        await getMaxCreatePosition();
        return;
    }
    
    var b0xdecimal = amountToDeposit.toString();
    var wallet_b0x = ethers.utils.parseUnits(walletBalances['B0x'], 18).toString();
    
    if(parseFloat(b0xdecimal) > parseFloat(wallet_b0x)){
        alert("Too much B0x - you don't have enough, lower the amount!");
        await getMaxCreatePosition();
        return;
    }

    const amountToDepositBN = ethers.BigNumber.from(amountToDeposit.toString());
    const amountToDepositBN2 = ethers.BigNumber.from(amountWith8Decimals0xBTC.toString());

    try {
        console.log("Updating TokenA input with calculated value");
        
        // Update ONLY TokenA input (don't touch TokenB since user is typing in it)
        if(tokenAinputAddress === Address_ZEROXBTC_TESTNETCONTRACT) {
            // TokenA is 0xBTC
            amountInputA.value = ethers.utils.formatUnits(amountWith8Decimals0xBTC, 8);
            amountInputB.value = ethers.utils.formatUnits(amountToDeposit,18);
        } else {
            // TokenA is B0x
            amountInputA.value = ethers.utils.formatUnits(amountToDeposit, 18);
            amountInputB.value = ethers.utils.formatUnits(amountWith8Decimals0xBTC, 8);
        }

        ratiozToSave = 10000 * amountToDepositBN / amountToDepositBN2;
        
    } catch (error) {
        console.error(`Error in getRatioCreatePositiontokenB:`, error);
    }
}











var ratiozToSave  = 0;





async function getRatioCreatePositiontokenA(){
    console.log("running: getRatioIncreasePositiontokenB token a");


            if(!walletConnected){
               await connectWallet();
            }

const tokenASelect = document.querySelector('#create .form-group:nth-child(1) select');


// Get the currently selected value
const tokenAValue = tokenASelect.value;
console.log("Currently selected value TokenA:", tokenAValue);


const tokenBSelect = document.querySelector('#create .form-group:nth-child(2) select');


// Get the currently selected value
const tokenBvalue = tokenBSelect.value;
console.log("Currently selected value TokenB:", tokenBvalue);

// Or get the selected option element itself
const selectedOptionA = tokenASelect.options[tokenASelect.selectedIndex];
const selectedOptionB= tokenBSelect.options[tokenBSelect.selectedIndex];
console.log("selectedOptionA option text:", selectedOptionA.text);
console.log("selectedOptionA option value:", selectedOptionA.value);
console.log("selectedOptionB option text:", selectedOptionB.text);
console.log("selectedOptionB option value:", selectedOptionB.value);

            var tokenAinputAddress = tokenAddresses[selectedOptionA.value];
            var tokenBinputAddress = tokenAddresses[selectedOptionB.value];
console.log("tokenA InputAddresstoken", tokenAinputAddress);
console.log("tokenB InputAddresstoken", tokenBinputAddress);

// Simple and reliable approach - select all number inputs in create page
const createInputs = document.querySelectorAll('#create input[type="number"]');
const amountInputA = createInputs[0]; // First number input (Amount A)
const amountInputB = createInputs[1]; // Second number input (Amount B)

// Add null checks to prevent errors
if (!amountInputA || !amountInputB) {
    console.error("Could not find amount input fields");
    return;
}

// Get the currently selected values
const tokenAInput = amountInputA.value;
const tokenBInput = amountInputB.value;

console.log("Currently amountInputA value:", tokenAInput);
console.log("Currently amountInputB value:", tokenBInput);


            var amountAtoCreate = ethers.utils.parseUnits(tokenAInput, 18);  // Correctly represents 12 * 10^8
            
            if( selectedOptionA.value=="0xBTC"){
                    console.log("LOGGED 0xBTC selected A Value CreatePositionA");
             amountAtoCreate = ethers.utils.parseUnits(tokenAInput, 8);  // Correctly represents 12 * 10^8
            }

console.log("Currently amountInputB value:", tokenBInput);
            var amountBtoCreate = ethers.utils.parseUnits(tokenBInput, 18);  // Correctly represents 12 * 10^8
            
            if( selectedOptionB.value=="0xBTC"){
                    console.log("LOGGED 0xBTC selected B Value CreatePositionA");
             amountBtoCreate = ethers.utils.parseUnits(tokenBInput, 8);  // Correctly represents 12 * 10^8
            }


            let amountOut = 0;

            await throttledGetSqrtRtAndPriceRatio();



        let amountToDeposit = ethers.utils.parseEther("200");  // 200 * 10^18 for B0x token
        var amountToDepositOfZer0X = ethers.utils.parseUnits("100", 8); // 0.01 * 10^8 for 0xBTC
        var amountWith8Decimals0xBTC = 0n;
        let liquiditySalt = 0; // Declare once outside the if/else

            if(tokenAinputAddress == Address_ZEROXBTC_TESTNETCONTRACT) {
            console.log(`Found valid Ratio: ${ratioz.toString()}`);
            console.log("TokenA == zer0x Token (0xBTC is token0, B0x is token1)");
            

            calculatedPriceRatio = BigInt(ratioz);


            amountWith8Decimals0xBTC = amountAtoCreate;
            console.log("amountWith8Decimals0xBTCamountWith8Decimals0xBTC: ",amountWith8Decimals0xBTC.toString());
            // Your calculatedPriceRatio = 200000000000000000000000000000n represents 20 in 29-decimal format
            // Method 1: Direct conversion to get the economic price (20)

            const priceIn18Decimals = calculatedPriceRatio / (10n**10n); // Remove 11 decimals (29-18=11)

            console.log("Price in 18-decimal format:", priceIn18Decimals.toString()); // Should be 20000000000000000000 (20 * 10^18)
            
            // Method 2: Calculate B0x amount needed
            // Formula: B0x_amount = 0xBTC_amount * price
            // We need: (amountToDepositOfZer0X in 18-decimal) * (price in 18-decimal) / 10^18
            
            const amountZer0XIn18Decimals = BigInt(amountAtoCreate) * 10n**10n; // Convert 8-decimal to 18-decimal
            amountToDeposit = (amountZer0XIn18Decimals * priceIn18Decimals) / (10n**18n);
            
            // Alternative simpler method:
            // const economicAmountZer0X = Number(ethers.formatUnits(amountToDepositOfZer0X, 8)); // 0.01
            // const economicAmountB0x = economicAmountZer0X * 20; // 0.01 * 20 = 0.2
            // const amountToDeposit = ethers.parseEther(economicAmountB0x.toString());

            console.log(`Estimated Deposit B0x amount: ${ethers.utils.formatEther(amountToDeposit)}`); // Should be 0.2
            console.log(`Estimated Deposit 0xBTC amount: ${ethers.utils.formatUnits(amountWith8Decimals0xBTC, 8)}`); // Should be 0.01
                console.log(`amountWith8Decimals0xBTC: ${amountWith8Decimals0xBTC}`);
                        console.log(`amountToDeposit: ${amountToDeposit}`);


        } else { 
                    
              // Start with 0xBTC amount (this could be user input or calculated value)
            var amountB0x = BigInt(amountAtoCreate); // Your 0xBTC input
            
            console.log("Amount B0x input: ", amountB0x.toString());
            const priceRatio2 = BigInt(ratioz);
            console.log(`priceRatio: ${priceRatio2}`);
            
            // Reverse calculation to get B0x amount
            amountAtoCreate = (amountB0x * (10n**18n)) / priceRatio2;
            
            var temp = amountB0x;
            amountB0x = amountAtoCreate;
            amountAtoCreate = temp;


            console.log(`Estimated Deposit 0xBTC amount: ${amountB0x}`);
            console.log(`Estimated Deposit B0x amount: ${amountAtoCreate}`);
            console.log(`Estimated Deposit 0xBTC amount: ${ethers.utils.formatUnits(amountB0x, 8)}`);
            console.log(`Estimated Deposit B0x amount: ${ethers.utils.formatEther(amountAtoCreate)}`);
            var temp = amountAtoCreate;
            amountWith8Decimals0xBTC = amountB0x;
            amountToDeposit = temp;

    
            
        }

        console.log("walletBalances: ",walletBalances['0xBTC']);
        var zeroxbtcdecimal = amountWith8Decimals0xBTC.toString();
        var wallet_zeroxbtc = ethers.utils.parseUnits(walletBalances['0xBTC'], 8).toString();
        console.log("amountWith8Decimals0xBTC: ",zeroxbtcdecimal);
        console.log("wallet_zeroxbtc: ",wallet_zeroxbtc);
        
        var b0xdecimal = amountToDeposit.toString();
        var wallet_b0x = ethers.utils.parseUnits(walletBalances['B0x'], 18).toString();
        console.log("amountWith b0xdecimal:  ",b0xdecimal);
        console.log("wallet_b0x: ",wallet_b0x);
        
            if(parseFloat(zeroxbtcdecimal)>parseFloat(wallet_zeroxbtc)){
                alert("too much 0xbtc u dont have lower it!.")
                               await getMaxCreatePosition();

                return;
            }
            if(parseFloat(b0xdecimal)>parseFloat(wallet_b0x)){
                alert("too much b0x u dont have lower it!.")
               await getMaxCreatePosition();
                return;
            }
        
/*

    function createPositionWith2Tokens(
        address token,
        address token2,
        uint256 amountIn,
        uint256 amountIn2,
        uint currentx96,        // Expected sqrtPriceX96 when user initiated tx
        uint256 slippage,       // Slippage tolerance in basis points (e.g., 100 = 1%)
        address hookAddress,
        address toSendNFTto) public payable returns (bool)
            {
*/

const amountToDepositBN = ethers.BigNumber.from(amountToDeposit.toString());
const amountToDepositBN2 = ethers.BigNumber.from(amountWith8Decimals0xBTC.toString());


try{

                console.log("tokenAddress: ", tokenAddress);

                console.log("Address_ZEROXBTC_TESTNETCONTRACT: ", Address_ZEROXBTC_TESTNETCONTRACT.toString());

                console.log("amountToDepositBN: ", amountToDepositBN.toString());
                console.log("amountToDepositBN2: ", amountToDepositBN2.toString());
                console.log("Current_getsqrtPricex96: ", Current_getsqrtPricex96.toString());
                console.log("HookAddress: ", HookAddress.toString());

/*

const amountToSwapBN = ethers.BigNumber.from(amountToSwap.toString());
const minAmountOutBN = ethers.BigNumber.from(MinamountOut.toFixed(0).toString());



            try {
                // Call the swap function
                const tx = await tokenSwapperContract.swapTokenTWOTOKENS(
                    tokenAddress, 
                    Address_ZEROXBTC_TESTNETCONTRACT, 
                    tokenAddress, 
                    Address_ZEROXBTC_TESTNETCONTRACT, 
                    amountToSwapBN, 
                    minAmountOutBN, 
                    HookAddress, 
                    userAddress
                );
                */

        // Update ONLY TokenA input (don't touch TokenB since user is typing in it)
        if(tokenAinputAddress === Address_ZEROXBTC_TESTNETCONTRACT) {
            // TokenA is 0xBTC
            amountInputA.value = ethers.utils.formatUnits(amountWith8Decimals0xBTC, 8);
            amountInputB.value = ethers.utils.formatUnits(amountToDeposit,18);
        } else {
            // TokenA is B0x
            amountInputA.value = ethers.utils.formatUnits(amountToDeposit, 18);
            amountInputB.value = ethers.utils.formatUnits(amountWith8Decimals0xBTC, 8);
        }

            ratiozToSave = 10000*amountToDepositBN / amountToDepositBN2;

                
            } catch (error) {
                console.error(`Error  create Position :`, error);
            }
    // Update the UI to show total liquidity
    updateTotalLiqIncreaseSTAKING();
        }






// Enhanced function with proper priority token handling
function calculateOptimalAmounts(tokenAValue, tokenBValue, tokenAAmount, tokenBAmount, walletBalances, ratioz, priorityToken = null, StakeSection = false) {
    const tokenAinputAddress = tokenAddresses[tokenAValue];
    const tokenBinputAddress = tokenAddresses[tokenBValue];
    
    // Determine which amount to use as the base calculation based on priority
    let baseAmount, baseTokenValue, baseTokenAddress, otherTokenValue;
    
    if (priorityToken === 'A') {
        // Use tokenA as the priority (base calculation)
        baseAmount = tokenAAmount;
        baseTokenValue = tokenAValue;
        baseTokenAddress = tokenAinputAddress;
        otherTokenValue = tokenBValue;
    } else if (priorityToken === 'B') {
        // Use tokenB as the priority (base calculation)
        baseAmount = tokenBAmount;
        baseTokenValue = tokenBValue;
        baseTokenAddress = tokenBinputAddress;
        otherTokenValue = tokenAValue;
    } 
    // Parse the base amount with correct decimals
    const baseAmountParsed = ethers.utils.parseUnits(baseAmount, baseTokenValue === "0xBTC" ? 8 : 18);
    
    // Calculate the required amounts based on which token is the base
    let amountToDeposit, amountWith8Decimals0xBTC;
    
    if (baseTokenAddress === Address_ZEROXBTC_TESTNETCONTRACT) {
        // Base token is 0xBTC, calculate the other token amount needed
        const calculatedPriceRatio = BigInt(ratioz);
        const priceIn18Decimals = calculatedPriceRatio / (10n**10n);
        const amountZer0XIn18Decimals = BigInt(baseAmountParsed) * 10n**10n;
        
        amountWith8Decimals0xBTC = baseAmountParsed;
        amountToDeposit = (amountZer0XIn18Decimals * priceIn18Decimals) / (10n**18n);
    } else {
        // Base token is B0x, calculate how much 0xBTC is needed
        const calculatedPriceRatio = BigInt(ratioz);
        const priceIn18Decimals = calculatedPriceRatio / (10n**10n);
        
        amountToDeposit = baseAmountParsed;
        // Calculate 0xBTC needed: reverse the calculation
        amountWith8Decimals0xBTC = (BigInt(baseAmountParsed) * (10n**18n)) / (priceIn18Decimals * 10n**10n);
    }
    
    // Get position data to include unclaimed fees
    var positionSelect = document.querySelector('#increase select');
    if(StakeSection == true){
        positionSelect = document.querySelector('#stakeincrease select');
    }
    console.log("Test positionSelect ", positionSelect);
    const selectedPositionId = positionSelect.value;
    const position = positionData[selectedPositionId];
    
    // Calculate total available amounts (wallet + unclaimed fees)
    const zeroxbtcdecimal = amountWith8Decimals0xBTC.toString();
    let total_available_zeroxbtc;
    
    if (position && position.tokenA === tokenAddresses['0xBTC']) {
        // 0xBTC is tokenA, add unclaimedFeesTokenA
        const walletAmount = ethers.utils.parseUnits(walletBalances['0xBTC'], 8);
        const unclaimedAmount = ethers.utils.parseUnits(position.unclaimedFeesTokenA.toString(), 8);
        total_available_zeroxbtc = walletAmount.add(unclaimedAmount).toString();
    } else if (position && position.tokenB === tokenAddresses['0xBTC']) {
        // 0xBTC is tokenB, add unclaimedFeesTokenB
        const walletAmount = ethers.utils.parseUnits(walletBalances['0xBTC'], 8);
        const unclaimedAmount = ethers.utils.parseUnits(position.unclaimedFeesTokenB.toString(), 8);
        total_available_zeroxbtc = walletAmount.add(unclaimedAmount).toString();
    } else {
        // No position or 0xBTC not in position, use wallet only
        total_available_zeroxbtc = ethers.utils.parseUnits(walletBalances['0xBTC'], 8).toString();
    }
    
    const b0xdecimal = amountToDeposit.toString();
    let total_available_b0x;
    
    if (position && position.tokenA === tokenAddresses['B0x']) {
        // B0x is tokenA, add unclaimedFeesTokenA
        const walletAmount = ethers.utils.parseUnits(walletBalances['B0x'], 18);
        const unclaimedAmount = ethers.utils.parseUnits(position.unclaimedFeesTokenA.toString(), 18);
        total_available_b0x = walletAmount.add(unclaimedAmount).toString();
    } else if (position && position.tokenB === tokenAddresses['B0x']) {
        // B0x is tokenB, add unclaimedFeesTokenB
        const walletAmount = ethers.utils.parseUnits(walletBalances['B0x'], 18);
        const unclaimedAmount = ethers.utils.parseUnits(position.unclaimedFeesTokenB.toString(), 18);
        total_available_b0x = walletAmount.add(unclaimedAmount).toString();
    } else {
        // No position or B0x not in position, use wallet only
        total_available_b0x = ethers.utils.parseUnits(walletBalances['B0x'], 18).toString();
    }
    
    const zeroxbtcExceeded = parseFloat(zeroxbtcdecimal) > parseFloat(total_available_zeroxbtc);
    const b0xExceeded = parseFloat(b0xdecimal) > parseFloat(total_available_b0x);
    
    // If both are within limits, return as is
    if (!zeroxbtcExceeded && !b0xExceeded) {
        return {
            amountToDeposit,
            amountWith8Decimals0xBTC,
            needsAdjustment: false,
            priorityUsed: priorityToken,
            debugInfo: {
                baseToken: baseTokenValue,
                baseAmount: baseAmount,
                calculatedFrom: `${baseTokenValue} -> ${otherTokenValue}`
            }
        };
    }
    
    // If we exceed limits, calculate the optimal amounts within constraints
    let maxZeroxbtc, maxB0x;
    
    if (position && position.tokenA === tokenAddresses['0xBTC']) {
        const walletAmount = ethers.utils.parseUnits(walletBalances['0xBTC'], 8);
        const unclaimedAmount = ethers.utils.parseUnits(position.unclaimedFeesTokenA.toString(), 8);
        maxZeroxbtc = walletAmount.add(unclaimedAmount);
    } else if (position && position.tokenB === tokenAddresses['0xBTC']) {
        const walletAmount = ethers.utils.parseUnits(walletBalances['0xBTC'], 8);
        const unclaimedAmount = ethers.utils.parseUnits(position.unclaimedFeesTokenB.toString(), 8);
        maxZeroxbtc = walletAmount.add(unclaimedAmount);
    } else {
        maxZeroxbtc = ethers.utils.parseUnits(walletBalances['0xBTC'], 8);
    }
    
    if (position && position.tokenA === tokenAddresses['B0x']) {
        const walletAmount = ethers.utils.parseUnits(walletBalances['B0x'], 18);
        const unclaimedAmount = ethers.utils.parseUnits(position.unclaimedFeesTokenA.toString(), 18);
        maxB0x = walletAmount.add(unclaimedAmount);
    } else if (position && position.tokenB === tokenAddresses['B0x']) {
        const walletAmount = ethers.utils.parseUnits(walletBalances['B0x'], 18);
        const unclaimedAmount = ethers.utils.parseUnits(position.unclaimedFeesTokenB.toString(), 18);
        maxB0x = walletAmount.add(unclaimedAmount);
    } else {
        maxB0x = ethers.utils.parseUnits(walletBalances['B0x'], 18);
    }
    
    // Calculate what amounts would be needed if we max out each token
    const calculatedPriceRatio = BigInt(ratioz);
    const priceIn18Decimals = calculatedPriceRatio / (10n**10n);
    
    // If we max out 0xBTC, how much B0x do we need?
    const amountZer0XIn18Decimals = BigInt(maxZeroxbtc) * 10n**10n;
    const b0xNeededForMax0xBTC = (amountZer0XIn18Decimals * priceIn18Decimals) / (10n**18n);
    
    // If we max out B0x, how much 0xBTC do we need?
    const zeroxbtcNeededForMaxB0x = (BigInt(maxB0x) * (10n**18n)) / (priceIn18Decimals * 10n**10n);
    
    // Determine which scenario is actually possible
    const canMaxOut0xBTC = b0xNeededForMax0xBTC <= BigInt(maxB0x);
    const canMaxOutB0x = zeroxbtcNeededForMaxB0x <= BigInt(maxZeroxbtc);
    
    let actualLimitingFactor;
    let finalAmountToDeposit, finalAmountWith8Decimals0xBTC;
    
    // Priority-based selection with proper limiting factor detection
    if (canMaxOut0xBTC && canMaxOutB0x) {
        // Both are possible, choose based on priority
        if (priorityToken === 'A') {
            if (tokenAinputAddress === Address_ZEROXBTC_TESTNETCONTRACT) {
                // Token A is 0xBTC, max it out
                actualLimitingFactor = 'B0x';
                finalAmountWith8Decimals0xBTC = maxZeroxbtc;
                finalAmountToDeposit = b0xNeededForMax0xBTC;
            } else {
                // Token A is B0x, max it out
                actualLimitingFactor = '0xBTC';
                finalAmountToDeposit = maxB0x;
                finalAmountWith8Decimals0xBTC = zeroxbtcNeededForMaxB0x;
            }
        } else if (priorityToken === 'B') {
            if (tokenBinputAddress === Address_ZEROXBTC_TESTNETCONTRACT) {
                // Token B is 0xBTC, max it out
                actualLimitingFactor = 'B0x';
                finalAmountWith8Decimals0xBTC = maxZeroxbtc;
                finalAmountToDeposit = b0xNeededForMax0xBTC;
            } else {
                // Token B is B0x, max it out
                actualLimitingFactor = '0xBTC';
                finalAmountToDeposit = maxB0x;
                finalAmountWith8Decimals0xBTC = zeroxbtcNeededForMaxB0x;
            }
        }
    } else if (canMaxOut0xBTC) {
        // Only 0xBTC can be maxed out
        actualLimitingFactor = 'B0x';
        finalAmountWith8Decimals0xBTC = maxZeroxbtc;
        finalAmountToDeposit = b0xNeededForMax0xBTC;
    } else if (canMaxOutB0x) {
        // Only B0x can be maxed out
        actualLimitingFactor = '0xBTC';
        finalAmountToDeposit = maxB0x;
        finalAmountWith8Decimals0xBTC = zeroxbtcNeededForMaxB0x;
    } else {
        // Neither can be maxed out - use the most limiting factor
        const zeroxbtcRatio = parseFloat(total_available_zeroxbtc) / parseFloat(zeroxbtcdecimal);
        const b0xRatio = parseFloat(total_available_b0x) / parseFloat(b0xdecimal);
        
        if (zeroxbtcRatio < b0xRatio) {
            actualLimitingFactor = '0xBTC';
            finalAmountWith8Decimals0xBTC = maxZeroxbtc;
            finalAmountToDeposit = b0xNeededForMax0xBTC;
        } else {
            actualLimitingFactor = 'B0x';
            finalAmountToDeposit = maxB0x;
            finalAmountWith8Decimals0xBTC = zeroxbtcNeededForMaxB0x;
        }
    }
    
    return {
        amountToDeposit: finalAmountToDeposit,
        amountWith8Decimals0xBTC: finalAmountWith8Decimals0xBTC,
        needsAdjustment: true,
        limitingFactor: actualLimitingFactor,
        priorityUsed: priorityToken,
        debugInfo: {
            baseToken: baseTokenValue,
            baseAmount: baseAmount,
            calculatedFrom: `${baseTokenValue} -> ${otherTokenValue}`,
            canMaxOut0xBTC,
            canMaxOutB0x,
            b0xNeededForMax0xBTC: b0xNeededForMax0xBTC.toString(),
            zeroxbtcNeededForMaxB0x: zeroxbtcNeededForMaxB0x.toString(),
            maxZeroxbtc: maxZeroxbtc.toString(),
            maxB0x: maxB0x.toString()
        }
    };
}

// Example of how to use this in your max button handlers
function handleMaxButtonClick(tokenSymbol, inputElement) {
    // Get current token configuration
    const tokenALabel = document.querySelector('#increase #tokenALabel');
    const tokenBLabel = document.querySelector('#increase #tokenBLabel');
    const tokenAValue = tokenALabel.textContent;
    const tokenBValue = tokenBLabel.textContent;
    
    // Get position data for unclaimed fees
    const positionSelect = document.querySelector('#increase select');
    const selectedPositionId = positionSelect.value;
    const position = positionData[selectedPositionId];
    console.log(" handleMaxButtonClick position: ", position);
    // Use the helper function to get proper max amounts
    var useFees = true; //since we are using fees in this maxButtonClick
    const result = getMaxAmountsWithProperLimiting(tokenAValue, tokenBValue, walletBalances, ratioz, tokenSymbol, position, useFees);
    
    // Log what happened for debugging
    if (!result.requestFulfilled) {
        console.log(`Max ${tokenSymbol} request could not be fulfilled: ${result.reason}`);
        console.log(`Using max amounts based on actual limiting factor: ${result.actualLimitingFactor}`);
    }
    
    // Update both inputs with the proper amounts
    const createInputs = document.querySelectorAll('#increase input[type="number"]');
    const amountInputA = createInputs[0];
    const amountInputB = createInputs[1];
    
    const tokenAinputAddress = tokenAddresses[tokenAValue];
    
    if (tokenAinputAddress === Address_ZEROXBTC_TESTNETCONTRACT) {
        // Token A is 0xBTC
        amountInputA.value = ethers.utils.formatUnits(result.amountWith8Decimals0xBTC, 8);
        amountInputB.value = ethers.utils.formatUnits(result.amountToDeposit, 18);
    } else {
        // Token B is 0xBTC
        amountInputA.value = ethers.utils.formatUnits(result.amountToDeposit, 18);
        amountInputB.value = ethers.utils.formatUnits(result.amountWith8Decimals0xBTC, 8);
    }
    
    // Update the UI to show total liquidity
    updateTotalLiqIncrease();
    
    return result;
}



// Example of how to use this in your max button handlers
function handleMaxButtonClickStakeIncrease(tokenSymbol, inputElement) {
    // Get current token configuration
    const tokenALabel = document.querySelector('#stakeincrease #tokenALabelINC');
    const tokenBLabel = document.querySelector('#stakeincrease #tokenBLabelINC');
    const tokenAValue = tokenALabel.textContent;
    const tokenBValue = tokenBLabel.textContent;
    
    // Get position data for unclaimed fees
    const positionSelect = document.querySelector('#stakeincrease select');
    const selectedPositionId = positionSelect.value;
    const position = positionData[selectedPositionId];
    console.log(" handleMaxButtonClick position: ", position);
    // Use the helper function to get proper max amounts
    var useFees = false; //since we are using fees in this maxButtonClick
    const result = getMaxAmountsWithProperLimiting(tokenAValue, tokenBValue, walletBalances, ratioz, tokenSymbol, position, useFees);
    
    // Log what happened for debugging
    if (!result.requestFulfilled) {
        console.log(`Max ${tokenSymbol} request could not be fulfilled: ${result.reason}`);
        console.log(`Using max amounts based on actual limiting factor: ${result.actualLimitingFactor}`);
    }
    
    // Update both inputs with the proper amounts
    const createInputs = document.querySelectorAll('#stakeincrease input[type="number"]');
    const amountInputA = createInputs[0];
    const amountInputB = createInputs[1];
    
    const tokenAinputAddress = tokenAddresses[tokenAValue];
    
    if (tokenAinputAddress === Address_ZEROXBTC_TESTNETCONTRACT) {
        // Token A is 0xBTC
        amountInputA.value = ethers.utils.formatUnits(result.amountWith8Decimals0xBTC, 8);
        amountInputB.value = ethers.utils.formatUnits(result.amountToDeposit, 18);
    } else {
        // Token B is 0xBTC
        amountInputA.value = ethers.utils.formatUnits(result.amountToDeposit, 18);
        amountInputB.value = ethers.utils.formatUnits(result.amountWith8Decimals0xBTC, 8);
    }
    
    // Update the UI to show total liquidity
    updateTotalLiqIncreaseSTAKING();
    
    return result;
}
// Helper function to determine true limiting factor for max buttons
function getMaxAmountsWithProperLimiting(tokenAValue, tokenBValue, walletBalances, ratioz, requestedMaxToken, position = null, useFeesz) {
    // Calculate what the maximum possible amounts would be for each token (wallet + unclaimed fees)
    let maxZeroxbtc, maxB0x;
    
    if (position && position.tokenA == '0xBTC') {
        // 0xBTC is tokenA, add unclaimedFeesTokenA
        const walletAmount = ethers.utils.parseUnits(walletBalances['0xBTC'], 8);
        const unclaimedAmount = ethers.utils.parseUnits(position.unclaimedFeesTokenA.toString(), 8);
        maxZeroxbtc = walletAmount.add(unclaimedAmount);
        if(!useFeesz){
                    maxZeroxbtc = walletAmount;
        }
    } else if (position && position.tokenB == '0xBTC') {
        // 0xBTC is tokenB, add unclaimedFeesTokenB
        const walletAmount = ethers.utils.parseUnits(walletBalances['0xBTC'], 8);
        const unclaimedAmount = ethers.utils.parseUnits(position.unclaimedFeesTokenB.toString(), 8);
        maxZeroxbtc = walletAmount.add(unclaimedAmount);
        
        if(!useFeesz){
                    maxZeroxbtc = walletAmount;
        }
    } else {
        // No position or 0xBTC not in position, use wallet only
        maxZeroxbtc = ethers.utils.parseUnits(walletBalances['0xBTC'], 8);
    }
    
    if (position && position.tokenA == 'B0x') {
        // B0x is tokenA, add unclaimedFeesTokenA
        const walletAmount = ethers.utils.parseUnits(walletBalances['B0x'], 18);
        const unclaimedAmount = ethers.utils.parseUnits(position.unclaimedFeesTokenA.toString(), 18);
        maxB0x = walletAmount.add(unclaimedAmount); 
        
        if(!useFeesz){
                    maxB0x = walletAmount;
        }
    } else if (position && position.tokenB =='B0x') {
        // B0x is tokenB, add unclaimedFeesTokenB
        const walletAmount = ethers.utils.parseUnits(walletBalances['B0x'], 18);
        const unclaimedAmount = ethers.utils.parseUnits(position.unclaimedFeesTokenB.toString(), 18);
        maxB0x = walletAmount.add(unclaimedAmount);
        
        if(!useFeesz){
                    maxB0x = walletAmount;
        }
    } else {
        console.log("EUR EUR ");
        // No position or B0x not in position, use wallet only
        maxB0x = ethers.utils.parseUnits(walletBalances['B0x'], 18);
    }
    
    const calculatedPriceRatio = BigInt(ratioz);
    const priceIn18Decimals = calculatedPriceRatio / (10n**10n);
    
    // Calculate scenarios
    const amountZer0XIn18Decimals = BigInt(maxZeroxbtc) * 10n**10n;
    const b0xNeededForMax0xBTC = (amountZer0XIn18Decimals * priceIn18Decimals) / (10n**18n);
    const zeroxbtcNeededForMaxB0x = (BigInt(maxB0x) * (10n**18n)) / (priceIn18Decimals * 10n**10n);
    
    // Check which scenarios are feasible
    const canMaxOut0xBTC = b0xNeededForMax0xBTC <= BigInt(maxB0x);
    const canMaxOutB0x = zeroxbtcNeededForMaxB0x <= BigInt(maxZeroxbtc);
    
    // Determine the actual amounts to use
    let finalAmounts;
    
    if (requestedMaxToken === '0xBTC' && canMaxOut0xBTC) {
        // User wants max 0xBTC and it's possible
        finalAmounts = {
            amountWith8Decimals0xBTC: maxZeroxbtc,
            amountToDeposit: b0xNeededForMax0xBTC,
            actualLimitingFactor: 'none',
            requestFulfilled: true
        };
    } else if (requestedMaxToken === 'B0x' && canMaxOutB0x) {
        // User wants max B0x and it's possible
        finalAmounts = {
            amountWith8Decimals0xBTC: zeroxbtcNeededForMaxB0x,
            amountToDeposit: maxB0x,
            actualLimitingFactor: 'none',
            requestFulfilled: true
        };
    } else {
        // User's request can't be fulfilled, use the truly limiting factor
        if (canMaxOut0xBTC && !canMaxOutB0x) {
            finalAmounts = {
                amountWith8Decimals0xBTC: maxZeroxbtc,
                amountToDeposit: b0xNeededForMax0xBTC,
                actualLimitingFactor: 'B0x',
                requestFulfilled: false,
                reason: `Cannot max out ${requestedMaxToken} because B0x is limiting`
            };
        } else if (!canMaxOut0xBTC && canMaxOutB0x) {
            finalAmounts = {
                amountWith8Decimals0xBTC: zeroxbtcNeededForMaxB0x,
                amountToDeposit: maxB0x,
                actualLimitingFactor: '0xBTC',
                requestFulfilled: false,
                reason: `Cannot max out ${requestedMaxToken} because 0xBTC is limiting`
            };
        } else {
            // Neither can be maxed out independently, find the most limiting
            const b0xRatio = parseFloat(maxB0x.toString()) / parseFloat(b0xNeededForMax0xBTC.toString());
            const zeroxbtcRatio = parseFloat(maxZeroxbtc.toString()) / parseFloat(zeroxbtcNeededForMaxB0x.toString());
            
            if (b0xRatio < zeroxbtcRatio) {
                finalAmounts = {
                    amountWith8Decimals0xBTC: zeroxbtcNeededForMaxB0x,
                    amountToDeposit: maxB0x,
                    actualLimitingFactor: 'B0x',
                    requestFulfilled: requestedMaxToken === 'B0x',
                    reason: 'B0x is the most limiting factor'
                };
            } else {
                finalAmounts = {
                    amountWith8Decimals0xBTC: maxZeroxbtc,
                    amountToDeposit: b0xNeededForMax0xBTC,
                    actualLimitingFactor: '0xBTC',
                    requestFulfilled: requestedMaxToken === '0xBTC',
                    reason: '0xBTC is the most limiting factor'
                };
            }
        }
    }
    
    return finalAmounts;
}
// Alternative: Separate functions for specific behaviors
function calculateOptimalAmountsWithTokenAPriority(tokenAValue, tokenBValue, tokenAAmount, tokenBAmount, walletBalances, ratioz) {
    return calculateOptimalAmounts(tokenAValue, tokenBValue, tokenAAmount, tokenBAmount, walletBalances, ratioz, 'A', false);
}

function calculateOptimalAmountsWithTokenBPriority(tokenAValue, tokenBValue, tokenAAmount, tokenBAmount, walletBalances, ratioz) {
    return calculateOptimalAmounts(tokenAValue, tokenBValue, tokenAAmount, tokenBAmount, walletBalances, ratioz, 'B', false);
}

// Alternative: Separate functions for specific behaviors
function calculateOptimalAmountsWithTokenAPrioritySTAKESECTIONI(tokenAValue, tokenBValue, tokenAAmount, tokenBAmount, walletBalances, ratioz) {
    console.log("Calling Token A calculateOptimalAmounts");
    return calculateOptimalAmounts(tokenAValue, tokenBValue, tokenAAmount, tokenBAmount, walletBalances, ratioz, 'A', true);
}

function calculateOptimalAmountsWithTokenBPrioritySTAKESECTIONI(tokenAValue, tokenBValue, tokenAAmount, tokenBAmount, walletBalances, ratioz) {
        console.log("Calling Token B calculateOptimalAmounts");
    return calculateOptimalAmounts(tokenAValue, tokenBValue, tokenAAmount, tokenBAmount, walletBalances, ratioz, 'B', true);
}








// Modified getRatioIncreasePositiontokenB function
async function getRatioStakeIncreasePositiontokenB() {
    
    if (!walletConnected) {
        await connectWallet();
    }
    const tokenALabel = document.querySelector('#stakeincrease #tokenALabelINC');
    const tokenBLabel = document.querySelector('#stakeincrease #tokenBLabelINC');
    const tokenAInput = document.querySelector('#stakeincrease #tokenAAmount');
    const tokenBInput = document.querySelector('#stakeincrease #tokenBAmount');
    
    const tokenAValue = tokenALabel.textContent;
    const tokenBValue = tokenBLabel.textContent;
    const tokenAAmount = tokenAInput ? tokenAInput.value : '0';
    const tokenBAmount = tokenBInput ? tokenBInput.value : '0';
    
    const createInputs = document.querySelectorAll('#stakeincrease input[type="number"]');
    const amountInputA = createInputs[0];
    const amountInputB = createInputs[1];
    
    if (!amountInputA || !amountInputB) {
        console.error("Could not find amount input fields");
        return;
    }

    await throttledGetSqrtRtAndPriceRatio();
    
    // Use the helper function to calculate optimal amounts
    const result = calculateOptimalAmountsWithTokenBPrioritySTAKESECTIONI(
        tokenAValue, tokenBValue, 
        tokenAAmount, tokenBAmount, 
        walletBalances, ratioz
    );

    const { amountToDeposit, amountWith8Decimals0xBTC, needsAdjustment, limitingFactor } = result;

    console.log("!!!!!!!calculateOptimalAmounts amountToDeposit: ", amountToDeposit);
    console.log("!!!!!!!calculateOptimalAmounts amountWith8Decimals0xBTC: ", amountWith8Decimals0xBTC);
    console.log("!!!!!!!calculateOptimalAmounts needsAdjustment: ", needsAdjustment);
    console.log("!!!!!!!calculateOptimalAmounts limitingFactor: ", limitingFactor);
    console.log("!!!!!!!");
    
    try {
        const amountToDepositBN = ethers.BigNumber.from(amountToDeposit.toString());
        const amountToDepositBN2 = ethers.BigNumber.from(amountWith8Decimals0xBTC.toString());
        
        isProgrammaticUpdatB = true;
        
        const tokenAinputAddress = tokenAddresses[tokenAValue];
        
        // Update input fields based on token configuration
        if (tokenAinputAddress === Address_ZEROXBTC_TESTNETCONTRACT) {
            amountInputA.value = ethers.utils.formatUnits(amountWith8Decimals0xBTC, 8);
            //commented out because we dont update B in B.
          //  amountInputB.value = ethers.utils.formatUnits(amountToDeposit, 18);
        } else {
            amountInputA.value = ethers.utils.formatUnits(amountToDeposit, 18);
          //  amountInputB.value = ethers.utils.formatUnits(amountWith8Decimals0xBTC, 8);
        }
        
        ratiozToSave = 10000 * amountToDepositBN / amountToDepositBN2;
              
        // Only handle max amount setting if we needed adjustment
        if (needsAdjustment) {
            console.log(`Adjusted amounts due to ${limitingFactor} being limiting factor`);
            
            const positionSelect = document.querySelector('#stakeincrease select');
            const selectedPositionId = positionSelect.value;
            const position = stakingPositionData[selectedPositionId];
            console.log("Position Stake Increase: ",position);
                if (!position) return;
                
                // Determine which token we're working with
                const label = amountInputB.closest('.form-group').querySelector('label');
                let currentTokenSymbol = label.textConten;
                console.log("Label: ",label);
                let maxAmount = 0;
                
                if (label && label.textContent.includes(position.tokenB)) {
                    currentTokenSymbol = position.tokenB;
                    console.log("Worked");
                handleMaxButtonClickStakeIncrease(currentTokenSymbol,amountInputB);

            }
        }
        
        
    } catch (error) {
        console.error(`Error in create Position:`, error);
    }
    
    // Update the UI to show total liquidity
    updateTotalLiqIncreaseSTAKING();
    isProgrammaticUpdateB = false;
}


// Modified getRatioIncreasePositiontokenA function
async function getRatioStakeIncreasePositiontokenA() {
    console.log("running: getRatioStakeIncreasePositiontokenA");
    
    if (!walletConnected) {
        await connectWallet();
    }
    
    isProgrammaticUpdate = true;
    
    
    // Get token types from labels within increase page
    const tokenALabel = document.querySelector('#stakeincrease #tokenALabelINC');
    const tokenBLabel = document.querySelector('#stakeincrease #tokenBLabelINC');
    const tokenAInput = document.querySelector('#stakeincrease #tokenAAmount');
    const tokenBInput = document.querySelector('#stakeincrease #tokenBAmount');
    
    // Get the token values from the label text content
    const tokenAValue = tokenALabel.textContent;
    const tokenBValue = tokenBLabel.textContent;
    
    console.log("Currently selected value TokenA:", tokenAValue);
    console.log("Currently selected value TokenB:", tokenBValue);
    
    const tokenAAmount = tokenAInput ? tokenAInput.value : '0';
    const tokenBAmount = tokenBInput ? tokenBInput.value : '0';
    
    console.log("Token A Amount:", tokenAAmount);
    console.log("Token B Amount:", tokenBAmount);
    
    const tokenAinputAddress = tokenAddresses[tokenAValue];
    const tokenBinputAddress = tokenAddresses[tokenBValue];
    
    console.log("tokenA InputAddresstoken", tokenAinputAddress);
    console.log("tokenB InputAddresstoken", tokenBinputAddress);
    
    // Simple and reliable approach - select all number inputs in increase page
    const createInputs = document.querySelectorAll('#stakeincrease input[type="number"]');
    const amountInputA = createInputs[0]; // First number input (Amount A)
    const amountInputB = createInputs[1]; // Second number input (Amount B)
    
    // Add null checks to prevent errors
    if (!amountInputA || !amountInputB) {
        console.error("Could not find amount input fields");
        return;
    }
    
    console.log("Currently amountInputA value:", tokenAAmount);
    console.log("Currently amountInputB value:", tokenBAmount);
    
    await throttledGetSqrtRtAndPriceRatio();
    
    // Use the helper function to calculate optimal amounts
    const result = calculateOptimalAmountsWithTokenAPrioritySTAKESECTIONI(
        tokenAValue, tokenBValue, 
        tokenAAmount, tokenBAmount, 
        walletBalances, ratioz
    );
    
    const { amountToDeposit, amountWith8Decimals0xBTC, needsAdjustment, limitingFactor } = result;


    console.log("!!!!!!!calculateOptimalAmounts amountToDeposit: ", amountToDeposit);
    console.log("!!!!!!!calculateOptimalAmounts amountWith8Decimals0xBTC: ", amountWith8Decimals0xBTC);
    console.log("!!!!!!!calculateOptimalAmounts needsAdjustment: ", needsAdjustment);
    console.log("!!!!!!!calculateOptimalAmounts limitingFactor: ", limitingFactor);
    console.log("!!!!!!!");
    
    try {
        const amountToDepositBN = ethers.BigNumber.from(amountToDeposit.toString());
        const amountToDepositBN2 = ethers.BigNumber.from(amountWith8Decimals0xBTC.toString());
        
        console.log("tokenAddress: ", tokenAddress);
        console.log("Address_ZEROXBTC_TESTNETCONTRACT: ", Address_ZEROXBTC_TESTNETCONTRACT.toString());
        console.log("amountToDepositBN: ", amountToDepositBN.toString());
        console.log("amountToDepositBN2: ", amountToDepositBN2.toString());
        console.log("Current_getsqrtPricex96: ", Current_getsqrtPricex96.toString());
        console.log("HookAddress: ", HookAddress.toString());
        
        // Update input fields based on token configuration
        if (tokenAinputAddress === Address_ZEROXBTC_TESTNETCONTRACT) {
            //Commented out because we dont update A in A only B in A.
           // amountInputA.value = ethers.utils.formatUnits(amountWith8Decimals0xBTC, 8);
            amountInputB.value = ethers.utils.formatUnits(amountToDeposit, 18);
        } else {
         //   amountInputA.value = ethers.utils.formatUnits(amountToDeposit, 18);
            amountInputB.value = ethers.utils.formatUnits(amountWith8Decimals0xBTC, 8);
        }
        
        ratiozToSave = 10000 * amountToDepositBN / amountToDepositBN2;
        
        // Only handle max amount setting if we needed adjustment
        if (needsAdjustment) {
            console.log(`Adjusted amounts due to ${limitingFactor} being limiting factor`);
            
            const positionSelect = document.querySelector('#stakeincrease select');
            const selectedPositionId = positionSelect.value;
            const position = stakingPositionData[selectedPositionId];
            console.log("Position Stake Increase: ",position);
                if (!position) return;
                
                // Determine which token we're working with
                const label = amountInputA.closest('.form-group').querySelector('label');
                let currentTokenSymbol = label.textConten;
                console.log("Label: ",label);
                let maxAmount = 0;
                
                if (label && label.textContent.includes(position.tokenA)) {
                    currentTokenSymbol = position.tokenA;
                    console.log("Worked");
                handleMaxButtonClickStakeIncrease(currentTokenSymbol,amountInputA);

            }
        }
            
        
    updateTotalLiqIncreaseSTAKING();
        
    } catch (error) {
        console.error(`Error in create Position:`, error);
    }
    
    isProgrammaticUpdate = false;
}



// Modified getRatioIncreasePositiontokenB function
async function getRatioIncreasePositiontokenB() {
    console.log("running: getRatioStakeIncreasePositiontokenB");
    
    if (!walletConnected) {
        await connectWallet();
    }
    
    isProgrammaticUpdate = true;
    
    
    // Get token types from labels within increase page
    const tokenALabel = document.querySelector('#increase #tokenALabel');
    const tokenBLabel = document.querySelector('#increase #tokenBLabel');
    const tokenAInput = document.querySelector('#increase #tokenAAmount');
    const tokenBInput = document.querySelector('#increase #tokenBAmount');
    
    // Get the token values from the label text content
    const tokenAValue = tokenALabel.textContent;
    const tokenBValue = tokenBLabel.textContent;
    
    console.log("Currently selected value TokenA:", tokenAValue);
    console.log("Currently selected value TokenB:", tokenBValue);
    
    const tokenAAmount = tokenAInput ? tokenAInput.value : '0';
    const tokenBAmount = tokenBInput ? tokenBInput.value : '0';
    
    console.log("Token A Amount:", tokenAAmount);
    console.log("Token B Amount:", tokenBAmount);
    
    const tokenAinputAddress = tokenAddresses[tokenAValue];
    const tokenBinputAddress = tokenAddresses[tokenBValue];
    
    console.log("tokenA InputAddresstoken", tokenAinputAddress);
    console.log("tokenB InputAddresstoken", tokenBinputAddress);
    
    // Simple and reliable approach - select all number inputs in increase page
    const createInputs = document.querySelectorAll('#increase input[type="number"]');
    const amountInputA = createInputs[0]; // First number input (Amount A)
    const amountInputB = createInputs[1]; // Second number input (Amount B)
    
    // Add null checks to prevent errors
    if (!amountInputA || !amountInputB) {
        console.error("Could not find amount input fields");
        return;
    }
    
    console.log("Currently amountInputA value:", tokenAAmount);
    console.log("Currently amountInputB value:", tokenBAmount);
    
    await throttledGetSqrtRtAndPriceRatio();
    
    // Use the helper function to calculate optimal amounts
    const result = calculateOptimalAmountsWithTokenBPrioritySTAKESECTIONI(
        tokenAValue, tokenBValue, 
        tokenAAmount, tokenBAmount, 
        walletBalances, ratioz
    );
    
    const { amountToDeposit, amountWith8Decimals0xBTC, needsAdjustment, limitingFactor } = result;

   
    console.log("!!!!!!!calculateOptimalAmounts amountToDeposit: ", amountToDeposit);
    console.log("!!!!!!!calculateOptimalAmounts amountWith8Decimals0xBTC: ", amountWith8Decimals0xBTC);
    console.log("!!!!!!!calculateOptimalAmounts needsAdjustment: ", needsAdjustment);
    console.log("!!!!!!!calculateOptimalAmounts limitingFactor: ", limitingFactor);
    console.log("!!!!!!!");
    
    try {
        const amountToDepositBN = ethers.BigNumber.from(amountToDeposit.toString());
        const amountToDepositBN2 = ethers.BigNumber.from(amountWith8Decimals0xBTC.toString());
        
        console.log("tokenAddress: ", tokenAddress);
        console.log("Address_ZEROXBTC_TESTNETCONTRACT: ", Address_ZEROXBTC_TESTNETCONTRACT.toString());
        console.log("amountToDepositBN: ", amountToDepositBN.toString());
        console.log("amountToDepositBN2: ", amountToDepositBN2.toString());
        console.log("Current_getsqrtPricex96: ", Current_getsqrtPricex96.toString());
        console.log("HookAddress: ", HookAddress.toString());
        
        // Update input fields based on token configuration
        if (tokenAinputAddress === Address_ZEROXBTC_TESTNETCONTRACT) {
            //Commented out because we dont update A in A only B in A.
           // amountInputA.value = ethers.utils.formatUnits(amountWith8Decimals0xBTC, 8);
            amountInputA.value =ethers.utils.formatUnits(amountWith8Decimals0xBTC, 8);
            
        } else {
         //   amountInputA.value = ethers.utils.formatUnits(amountToDeposit, 18);
            amountInputA.value =  ethers.utils.formatUnits(amountToDeposit, 18);
        }
        
        ratiozToSave = 10000 * amountToDepositBN / amountToDepositBN2;
        
        // Only handle max amount setting if we needed adjustment
        if (needsAdjustment) {
            console.log(`Adjusted amounts B due to ${limitingFactor} being limiting factor`);
            
            const positionSelect = document.querySelector('#increase select');
            const selectedPositionId = positionSelect.value;
            const position = positionData[selectedPositionId];
            console.log("Position Stake Increase: ",position);
                if (!position) return;
                
                // Determine which token we're working with
                const label = amountInputB.closest('.form-group').querySelector('label');
                let currentTokenSymbol = label.textConten;
                console.log("Label: ",label);
                let maxAmount = 0;
                
                if (label && label.textContent.includes(position.tokenB)) {
                    currentTokenSymbol = position.tokenB;
                    console.log("Worked");
                handleMaxButtonClick(currentTokenSymbol,amountInputB);
            }
        }




        
    updateTotalLiqIncreaseSTAKING();
        
    } catch (error) {
        console.error(`Error in create Position:`, error);
    }
    
    isProgrammaticUpdate = false;
}


// Modified getRatioIncreasePositiontokenA function
async function getRatioIncreasePositiontokenA() {
    console.log("running: getRatioIncreasePositiontokenA");
    
    if (!walletConnected) {
        await connectWallet();
    }
    
    isProgrammaticUpdate = true;
    
    // Get token types from labels within increase page
    const tokenALabel = document.querySelector('#increase #tokenALabel');
    const tokenBLabel = document.querySelector('#increase #tokenBLabel');
    const tokenAInput = document.querySelector('#increase #tokenAAmount');
    const tokenBInput = document.querySelector('#increase #tokenBAmount');
    
    // Get the token values from the label text content
    const tokenAValue = tokenALabel.textContent;
    const tokenBValue = tokenBLabel.textContent;
    
    console.log("Currently selected value TokenA:", tokenAValue);
    console.log("Currently selected value TokenB:", tokenBValue);
    
    const tokenAAmount = tokenAInput ? tokenAInput.value : '0';
    const tokenBAmount = tokenBInput ? tokenBInput.value : '0';
    
    console.log("Token A Amount:", tokenAAmount);
    console.log("Token B Amount:", tokenBAmount);
    
    const tokenAinputAddress = tokenAddresses[tokenAValue];
    const tokenBinputAddress = tokenAddresses[tokenBValue];
    
    console.log("tokenA InputAddresstoken", tokenAinputAddress);
    console.log("tokenB InputAddresstoken", tokenBinputAddress);
    
    // Simple and reliable approach - select all number inputs in increase page
    const createInputs = document.querySelectorAll('#increase input[type="number"]');
    const amountInputA = createInputs[0]; // First number input (Amount A)
    const amountInputB = createInputs[1]; // Second number input (Amount B)
    
    // Add null checks to prevent errors
    if (!amountInputA || !amountInputB) {
        console.error("Could not find amount input fields");
        return;
    }
    
    console.log("Currently amountInputA value:", tokenAAmount);
    console.log("Currently amountInputB value:", tokenBAmount);
    
    await throttledGetSqrtRtAndPriceRatio();
    
    // Use the helper function to calculate optimal amounts
    const result = calculateOptimalAmountsWithTokenAPriority(
        tokenAValue, tokenBValue, 
        tokenAAmount, tokenBAmount, 
        walletBalances, ratioz
    );
    
    const { amountToDeposit, amountWith8Decimals0xBTC, needsAdjustment, limitingFactor } = result;


    console.log("!!!!!!!calculateOptimalAmounts amountToDeposit: ", amountToDeposit);
    console.log("!!!!!!!calculateOptimalAmounts amountWith8Decimals0xBTC: ", amountWith8Decimals0xBTC);
    console.log("!!!!!!!calculateOptimalAmounts needsAdjustment: ", needsAdjustment);
    console.log("!!!!!!!calculateOptimalAmounts limitingFactor: ", limitingFactor);
    console.log("!!!!!!!");
    
    try {
        const amountToDepositBN = ethers.BigNumber.from(amountToDeposit.toString());
        const amountToDepositBN2 = ethers.BigNumber.from(amountWith8Decimals0xBTC.toString());
        
        console.log("tokenAddress: ", tokenAddress);
        console.log("Address_ZEROXBTC_TESTNETCONTRACT: ", Address_ZEROXBTC_TESTNETCONTRACT.toString());
        console.log("amountToDepositBN: ", amountToDepositBN.toString());
        console.log("amountToDepositBN2: ", amountToDepositBN2.toString());
        console.log("Current_getsqrtPricex96: ", Current_getsqrtPricex96.toString());
        console.log("HookAddress: ", HookAddress.toString());
        
        // Update input fields based on token configuration
        if (tokenAinputAddress === Address_ZEROXBTC_TESTNETCONTRACT) {
            amountInputA.value = ethers.utils.formatUnits(amountWith8Decimals0xBTC, 8);
            amountInputB.value = ethers.utils.formatUnits(amountToDeposit, 18);
        } else {
            amountInputA.value = ethers.utils.formatUnits(amountToDeposit, 18);
            amountInputB.value = ethers.utils.formatUnits(amountWith8Decimals0xBTC, 8);
        }
        
        ratiozToSave = 10000 * amountToDepositBN / amountToDepositBN2;
        
        // Only handle max amount setting if we needed adjustment
              // Only handle max amount setting if we needed adjustment
            if (needsAdjustment) {
                console.log(`Adjusted amounts A due to ${limitingFactor} being limiting factor`);
                
                const positionSelect = document.querySelector('#increase select');
                const selectedPositionId = positionSelect.value;
                const position = positionData[selectedPositionId];
                console.log("Position Stake Increase: ",position);
                    if (!position) return;
                    
                    // Determine which token we're working with
                    const label = amountInputA.closest('.form-group').querySelector('label');
                    let currentTokenSymbol = label.textConten;
                    console.log("Label: ",label);
                    let maxAmount = 0;
                    
                    if (label && label.textContent.includes(position.tokenA)) {
                        currentTokenSymbol = position.tokenA;
                        console.log("Worked");
                    handleMaxButtonClick(currentTokenSymbol,amountInputA);

                }
            }


            
        
        updateTotalLiqIncrease();
        
    } catch (error) {
        console.error(`Error in create Position:`, error);
    }
    
    isProgrammaticUpdate = false;
}


// Solution 1: Using ethers.js BigNumber for precision arithmetic
function addWithPrecision(value1, value2, decimals = 18) {
    // Convert to BigNumber, add, then format back
    console.log("Value1 : ", value1.toString());
        console.log("Value2 : ", value2.toString());
        const parts = value1.toString().split('.');
const truncatedValue = parts.length > 1 
    ? parts[0] + '.' + parts[1].substring(0, decimals)
    : value1.toString();

const bigNum1 = ethers.utils.parseUnits(truncatedValue, decimals);

        const parts2 = value2.toString().split('.');
const truncatedValue2 = parts2.length > 1 
    ? parts2[0] + '.' + parts2[1].substring(0, decimals)
    : value2.toString();

    const bigNum2 = ethers.utils.parseUnits(truncatedValue2, decimals);
        
    const sum = bigNum1.add(bigNum2);
    
    // Convert back to string with proper decimals
    return ethers.utils.formatUnits(sum, decimals);
}


        async function getCreatePosition() {
            if(!walletConnected){
               await connectWallet();
            }

    var selectSlippage = document.getElementById('slippageToleranceCreate');
    var selectSlippageValue = selectSlippage.value; // Returns: "0.1", "0.5", "1.0", or "2.0"
 const numberValueSlippage = parseFloat(selectSlippageValue.replace('%', ''));
    // Divide by 100 to get decimal
    const decimalValueSlippage= numberValueSlippage / 100;
    console.log("selectSlippageValue: ",selectSlippageValue);
    console.log("decimalValueSlippage: ",decimalValueSlippage);

const tokenASelect = document.querySelector('#create .form-group:nth-child(1) select');


// Get the currently selected value
const tokenAValue = tokenASelect.value;
console.log("Currently selected value TokenA:", tokenAValue);


const tokenBSelect = document.querySelector('#create .form-group:nth-child(2) select');


// Get the currently selected value
const tokenBvalue = tokenBSelect.value;
console.log("Currently selected value TokenB:", tokenBvalue);

// Or get the selected option element itself
const selectedOptionA = tokenASelect.options[tokenASelect.selectedIndex];
const selectedOptionB= tokenBSelect.options[tokenBSelect.selectedIndex];
console.log("selectedOptionA option text:", selectedOptionA.text);
console.log("selectedOptionA option value:", selectedOptionA.value);
console.log("selectedOptionB option text:", selectedOptionB.text);
console.log("selectedOptionB option value:", selectedOptionB.value);

            var tokenAinputAddress = tokenAddresses[selectedOptionA.value];
            var tokenBinputAddress = tokenAddresses[selectedOptionB.value];
console.log("tokenA InputAddresstoken", tokenAinputAddress);
console.log("tokenB InputAddresstoken", tokenBinputAddress);

// Simple and reliable approach - select all number inputs in create page
const createInputs = document.querySelectorAll('#create input[type="number"]');
const amountInputA = createInputs[0]; // First number input (Amount A)
const amountInputB = createInputs[1]; // Second number input (Amount B)

// Add null checks to prevent errors
if (!amountInputA || !amountInputB) {
    console.error("Could not find amount input fields");
    return;
}

// Get the currently selected values
const tokenAInput = amountInputA.value;
const tokenBInput = amountInputB.value;

console.log("Currently amountInputA value:", tokenAInput);
console.log("Currently amountInputB value:", tokenBInput);


            var amountAtoCreate = ethers.utils.parseUnits(tokenAInput, 18);  // Correctly represents 12 * 10^8
            
            if( selectedOptionA.value=="0xBTC"){
                    console.log("LOGGED 0xBTC selected A Value, createPosition");
             amountAtoCreate = ethers.utils.parseUnits(tokenAInput, 8);  // Correctly represents 12 * 10^8
            }

console.log("Currently amountInputB value:", tokenBInput);
            var amountBtoCreate = ethers.utils.parseUnits(tokenBInput, 18);  // Correctly represents 12 * 10^8
            
            if( selectedOptionB.value=="0xBTC"){
                    console.log("LOGGED 0xBTC selected B Valu, createPositione");
             amountBtoCreate = ethers.utils.parseUnits(tokenBInput, 8);  // Correctly represents 12 * 10^8
            }


            let amountOut = 0;

            await throttledGetSqrtRtAndPriceRatio();



        let amountToDeposit = ethers.utils.parseEther("200");  // 200 * 10^18 for B0x token
        var amountToDepositOfZer0X = ethers.utils.parseUnits("100", 8); // 0.01 * 10^8 for 0xBTC
        var amountWith8Decimals0xBTC = 0n;
        let liquiditySalt = 0; // Declare once outside the if/else

            if(tokenAinputAddress == Address_ZEROXBTC_TESTNETCONTRACT) {
            console.log(`Found valid Ratio: ${ratioz.toString()}`);
            console.log("TokenA == zer0x Token (0xBTC is token0, B0x is token1)");
            

            calculatedPriceRatio = BigInt(ratioz);


            amountWith8Decimals0xBTC = amountAtoCreate;
            console.log("amountWith8Decimals0xBTCamountWith8Decimals0xBTC: ",amountWith8Decimals0xBTC.toString());
            // Your calculatedPriceRatio = 200000000000000000000000000000n represents 20 in 29-decimal format
            // Method 1: Direct conversion to get the economic price (20)

            const priceIn18Decimals = calculatedPriceRatio / (10n**10n); // Remove 11 decimals (29-18=11)

            console.log("Price in 18-decimal format:", priceIn18Decimals.toString()); // Should be 20000000000000000000 (20 * 10^18)
            
            // Method 2: Calculate B0x amount needed
            // Formula: B0x_amount = 0xBTC_amount * price
            // We need: (amountToDepositOfZer0X in 18-decimal) * (price in 18-decimal) / 10^18
            
            const amountZer0XIn18Decimals = BigInt(amountAtoCreate) * 10n**10n; // Convert 8-decimal to 18-decimal
            amountToDeposit = (amountZer0XIn18Decimals * priceIn18Decimals) / (10n**18n);
            
            // Alternative simpler method:
            // const economicAmountZer0X = Number(ethers.formatUnits(amountToDepositOfZer0X, 8)); // 0.01
            // const economicAmountB0x = economicAmountZer0X * 20; // 0.01 * 20 = 0.2
            // const amountToDeposit = ethers.parseEther(economicAmountB0x.toString());

            console.log(`Estimated Deposit B0x amount: ${ethers.utils.formatEther(amountToDeposit)}`); // Should be 0.2
            console.log(`Estimated Deposit 0xBTC amount: ${ethers.utils.formatUnits(amountWith8Decimals0xBTC, 8)}`); // Should be 0.01
                console.log(`amountWith8Decimals0xBTC: ${amountWith8Decimals0xBTC}`);
                        console.log(`amountToDeposit: ${amountToDeposit}`);


        } else { 
            
            
                    
            amountToDeposit = BigInt(amountBtoCreate); // Fixed B0x amount
            console.log("Amount B to create: ",amountToDeposit.toString());
            const priceRatio = BigInt(ratioz); // This ratio is in different format than Case 1
            console.log(`priceRatio: ${priceRatio}`);
            console.log(`Price ratio: ${priceRatio}`);
            
            // Direct multiplication - ratio is already in correct format
            amountWith8Decimals0xBTC = (amountToDeposit * priceRatio) / (10n**18n);
            
            console.log(`Estimated Deposit B0x amount: ${ethers.utils.formatEther(amountWith8Decimals0xBTC)}`);
            console.log(`Estimated Deposit 0xBTC amount: ${ethers.utils.formatUnits(amountToDeposit, 8)}`);
            var temp = amountToDeposit;
            amountToDeposit = amountWith8Decimals0xBTC;
            amountWith8Decimals0xBTC = temp;
            
        }

        
        console.log("walletBalances: ",walletBalances['0xBTC']);
        var zeroxbtcdecimal = amountWith8Decimals0xBTC.toString();
        var wallet_zeroxbtc = ethers.utils.parseUnits(walletBalances['0xBTC'], 8).toString();
        console.log("amountWith8Decimals0xBTC: ",zeroxbtcdecimal);
        console.log("wallet_zeroxbtc: ",wallet_zeroxbtc);
        if(parseFloat(zeroxbtcdecimal)>parseFloat(wallet_zeroxbtc)){
            alert("too much 0xbtc u dont have lower it!.")
                          await getMaxCreatePosition();
            return;
        }
        
        var b0xdecimal = amountToDeposit.toString();
        var wallet_b0x = ethers.utils.parseUnits(walletBalances['B0x'], 18).toString();
        console.log("amountWith b0xdecimal:  ",b0xdecimal);
        console.log("wallet_b0x: ",wallet_b0x);
        
        if(parseFloat(b0xdecimal)>parseFloat(wallet_b0x)){
            alert("too much b0x u dont have lower it!.") 
                          await getMaxCreatePosition();

            return;
        }
/*

    function createPositionWith2Tokens(
        address token,
        address token2,
        uint256 amountIn,
        uint256 amountIn2,
        uint currentx96,        // Expected sqrtPriceX96 when user initiated tx
        uint256 slippage,       // Slippage tolerance in basis points (e.g., 100 = 1%)
        address hookAddress,
        address toSendNFTto) public payable returns (bool)
            {
*/

const amountToDepositBN = ethers.BigNumber.from(amountToDeposit.toString());
const amountToDepositBN2 = ethers.BigNumber.from(amountWith8Decimals0xBTC.toString());


try{

                console.log("tokenAddress: ", tokenAddress);

                console.log("Address_ZEROXBTC_TESTNETCONTRACT: ", Address_ZEROXBTC_TESTNETCONTRACT.toString());

                console.log("amountToDepositBN: ", amountToDepositBN.toString());
                console.log("amountToDepositBN2: ", amountToDepositBN2.toString());
                console.log("Current_getsqrtPricex96: ", Current_getsqrtPricex96.toString());
                console.log("HookAddress: ", HookAddress.toString());
                alert("approving tokens for create position!");
                await approveIfNeeded(tokenAddress, contractAddress_Swapper, amountToDepositBN);
                await approveIfNeeded(Address_ZEROXBTC_TESTNETCONTRACT, contractAddress_Swapper, amountToDepositBN2);
                
                var slippage = Math.floor(numberValueSlippage*100);
                console.log("Slippage = ", slippage);
                console.log("Slippage % = ", (slippage/100), "%");
                const tx = await tokenSwapperContract.createPositionWith2Tokens(
                    tokenAddress, 
                    Address_ZEROXBTC_TESTNETCONTRACT, 
                    amountToDepositBN, 
                    amountToDepositBN2,
                    Current_getsqrtPricex96,
                    slippage,
                    HookAddress, 
                    userAddress
                );

/*

const amountToSwapBN = ethers.BigNumber.from(amountToSwap.toString());
const minAmountOutBN = ethers.BigNumber.from(MinamountOut.toFixed(0).toString());



            try {
                // Call the swap function
                const tx = await tokenSwapperContract.swapTokenTWOTOKENS(
                    tokenAddress, 
                    Address_ZEROXBTC_TESTNETCONTRACT, 
                    tokenAddress, 
                    Address_ZEROXBTC_TESTNETCONTRACT, 
                    amountToSwapBN, 
                    minAmountOutBN, 
                    HookAddress, 
                    userAddress
                );
                */

                if(tokenAinputAddress == Address_ZEROXBTC_TESTNETCONTRACT) {
                    amountInputB.value = ethers.utils.formatUnits(amountToDeposit, 18);
                    amountInputA.value = ethers.utils.formatUnits(amountWith8Decimals0xBTC, 8);
                } else {
                    amountInputB.value = ethers.utils.formatUnits(amountWith8Decimals0xBTC, 8);
                    amountInputA.value = ethers.utils.formatUnits(amountToDeposit, 18);
                }

            ratiozToSave = 10000*amountToDepositBN / amountToDepositBN2;

                console.log("create Position transaction sent:", tx.hash);
                await tx.wait();
                console.log("Transaction confirmed!");
                alert("Successfully created position!");
            fetchBalances();
                
                         getTokenIDsOwnedByMetamask();
            } catch (error) {
                console.error(`Error  create Position :`, error);
            }
        }





    
            let maxCreatedWhen = Date.now() - 5000;



        async function getMaxCreatePosition() {
            maxCreatedWhen = Date.now(); // Save current timestamp in milliseconds
     
          if(!walletConnected){
               await connectWallet();
            }

const tokenASelect = document.querySelector('#create .form-group:nth-child(1) select');


// Get the currently selected value
const tokenAValue = tokenASelect.value;
console.log("Currently selected value TokenA:", tokenAValue);


const tokenBSelect = document.querySelector('#create .form-group:nth-child(2) select');


// Get the currently selected value
const tokenBvalue = tokenBSelect.value;
console.log("Currently selected value TokenB:", tokenBvalue);

// Or get the selected option element itself
const selectedOptionA = tokenASelect.options[tokenASelect.selectedIndex];
const selectedOptionB= tokenBSelect.options[tokenBSelect.selectedIndex];
console.log("selectedOptionA option text:", selectedOptionA.text);
console.log("selectedOptionA option value:", selectedOptionA.value);
console.log("selectedOptionB option text:", selectedOptionB.text);
console.log("selectedOptionB option value:", selectedOptionB.value);

            var tokenAinputAddress = tokenAddresses[selectedOptionA.value];
            var tokenBinputAddress = tokenAddresses[selectedOptionB.value];
console.log("tokenA InputAddresstoken", tokenAinputAddress);
console.log("tokenB InputAddresstoken", tokenBinputAddress);

// Simple and reliable approach - select all number inputs in create page
const createInputs = document.querySelectorAll('#create input[type="number"]');
const amountInputA = createInputs[0]; // First number input (Amount A)
const amountInputB = createInputs[1]; // Second number input (Amount B)

// Add null checks to prevent errors
if (!amountInputA || !amountInputB) {
    console.error("Could not find amount input fields");
    return;
}

// Get the currently selected values
const tokenAInput = amountInputA.value;
const tokenBInput = amountInputB.value;

console.log("Currently amountInputA value:", tokenAInput);
console.log("Currently amountInputB value:", tokenBInput);


            var amountAtoCreate = 0;  // Correctly represents 12 * 10^8
            
            if( selectedOptionA.value=="0xBTC"){
                    console.log("LOGGED 0xBTC selected A Value, getMaxCreate");
             amountAtoCreate = ethers.utils.parseUnits(walletBalances['0xBTC'], 8);  // Correctly represents 12 * 10^8
            }else{
                amountAtoCreate =ethers.utils.parseUnits(walletBalances['B0x'], 18);  // Correctly represents 12 * 10^8

            }

//console.log("Currently amountInputB value:", tokenBInput);
            var amountBtoCreate = 0;  // Correctly represents 12 * 10^8
            
            if( selectedOptionB.value=="0xBTC"){
                    console.log("LOGGED 0xBTC selected B Value, getMaxCreate");
             amountBtoCreate = ethers.utils.parseUnits(walletBalances['0xBTC'], 8);  // Correctly represents 12 * 10^8
            }else{ 
                
                
                amountBtoCreate = ethers.utils.parseUnits(walletBalances['B0x'], 18);  // Correctly represents 12 * 10^8
           

            }


            let amountOut = 0;
            await throttledGetSqrtRtAndPriceRatio();


        let amountToDeposit = ethers.utils.parseEther("200");  // 200 * 10^18 for B0x token
        var amountToDepositOfZer0X = ethers.utils.parseUnits("100", 8); // 0.01 * 10^8 for 0xBTC
        var amountWith8Decimals0xBTC = 0n;
        let liquiditySalt = 0; // Declare once outside the if/else

            if(tokenAinputAddress == Address_ZEROXBTC_TESTNETCONTRACT) {
            console.log(`Found valid Ratio: ${ratioz.toString()}`);
            console.log("TokenA == zer0x Token (0xBTC is token0, B0x is token1)");
            

            calculatedPriceRatio = BigInt(ratioz);


            amountWith8Decimals0xBTC = amountAtoCreate;
            console.log("amountWith8Decimals0xBTCamountWith8Decimals0xBTC: ",amountWith8Decimals0xBTC.toString());
            // Your calculatedPriceRatio = 200000000000000000000000000000n represents 20 in 29-decimal format
            // Method 1: Direct conversion to get the economic price (20)

            const priceIn18Decimals = calculatedPriceRatio / (10n**10n); // Remove 11 decimals (29-18=11)

            console.log("Price in 18-decimal format:", priceIn18Decimals.toString()); // Should be 20000000000000000000 (20 * 10^18)
            
            // Method 2: Calculate B0x amount needed
            // Formula: B0x_amount = 0xBTC_amount * price
            // We need: (amountToDepositOfZer0X in 18-decimal) * (price in 18-decimal) / 10^18
            
            const amountZer0XIn18Decimals = BigInt(amountAtoCreate) * 10n**10n; // Convert 8-decimal to 18-decimal
            amountToDeposit = (amountZer0XIn18Decimals * priceIn18Decimals) / (10n**18n);
            
            // Alternative simpler method:
            // const economicAmountZer0X = Number(ethers.formatUnits(amountToDepositOfZer0X, 8)); // 0.01
            // const economicAmountB0x = economicAmountZer0X * 20; // 0.01 * 20 = 0.2
            // const amountToDeposit = ethers.parseEther(economicAmountB0x.toString());

            console.log(`Estimated Deposit B0x amount: ${ethers.utils.formatEther(amountToDeposit)}`); // Should be 0.2
            console.log(`Estimated Deposit 0xBTC amount: ${ethers.utils.formatUnits(amountWith8Decimals0xBTC, 8)}`); // Should be 0.01
                console.log(`amountWith8Decimals0xBTC: ${amountWith8Decimals0xBTC}`);
                        console.log(`amountToDeposit: ${amountToDeposit}`);


        } else { 
            
            
                    
            amountToDeposit = BigInt(amountBtoCreate); // Fixed B0x amount
            console.log("Amount B to create: ",amountToDeposit.toString());
            const priceRatio = BigInt(ratioz); // This ratio is in different format than Case 1
            console.log(`priceRatio: ${priceRatio}`);
            console.log(`Price ratio: ${priceRatio}`);
            
            // Direct multiplication - ratio is already in correct format
            amountWith8Decimals0xBTC = (amountToDeposit * priceRatio) / (10n**18n);
            
            console.log(`Estimated Deposit B0x amount: ${ethers.utils.formatEther(amountWith8Decimals0xBTC)}`);
            console.log(`Estimated Deposit 0xBTC amount: ${ethers.utils.formatUnits(amountToDeposit, 8)}`);
            var temp = amountToDeposit;
            amountToDeposit = amountWith8Decimals0xBTC;
            amountWith8Decimals0xBTC = temp;
            
        }

        
        console.log("walletBalances: ",walletBalances['0xBTC']);
        var zeroxbtcdecimal = amountWith8Decimals0xBTC.toString();
        var wallet_zeroxbtc = ethers.utils.parseUnits(walletBalances['0xBTC'], 8).toString();
        console.log("amountWith8Decimals0xBTC: ",zeroxbtcdecimal);
        console.log("wallet_zeroxbtc: ",wallet_zeroxbtc);
        if(parseFloat(zeroxbtcdecimal)>parseFloat(wallet_zeroxbtc)){
            //alert("too much 0xbtc u dont have lower it!.")
        }
        
        var b0xdecimal = amountToDeposit.toString();
        var wallet_b0x = ethers.utils.parseUnits(walletBalances['B0x'], 18).toString();
        console.log("amountWith b0xdecimal:  ",b0xdecimal);
        console.log("wallet_b0x: ",wallet_b0x);
        
        if(parseFloat(b0xdecimal)>parseFloat(wallet_b0x)){
          //  alert("too much b0x u dont have lower it!.");
                        
            console.log("too much b0x u dont have lower it!.");
               
    // Case 2: B0x first - FIXED CALCULATION
    console.log(`Found valid Ratio: ${ratioz.toString()}`);
    console.log("TokenA == B0x Token (B0x is token0, 0xBTC is token1)");
    
            if(tokenAinputAddress != Address_ZEROXBTC_TESTNETCONTRACT) {

        amountToDeposit = BigInt(amountAtoCreate); // B0x amount (18 decimals)
            }else{

    amountToDeposit = BigInt(amountBtoCreate); // B0x amount (18 decimals)
            }

    console.log("Amount B to create: ", amountToDeposit.toString());
    
    // FIXED: Use the same ratio format as Case 1, but calculate inverse
    const calculatedPriceRatio = BigInt(ratioz); // Same 29-decimal format
    const priceIn18Decimals = calculatedPriceRatio / (10n**10n); // Convert to 18-decimal
    
    console.log(`calculatedPriceRatio: ${calculatedPriceRatio}`);
    console.log(`priceIn18Decimals: ${priceIn18Decimals}`);
    
    // Calculate 0xBTC needed: B0x / ratio (inverse calculation)
    // Formula: 0xBTC_amount = B0x_amount / price_ratio
    const amountB0xIn18Decimals = amountToDeposit; // Already in 18 decimals
    const amountZer0XIn18Decimals = (amountB0xIn18Decimals * (10n**18n)) / priceIn18Decimals;
    amountWith8Decimals0xBTC = amountZer0XIn18Decimals / (10n**10n); // Convert 18→8 decimals
    
            if(tokenAinputAddress != Address_ZEROXBTC_TESTNETCONTRACT) {

            }
    console.log(`Estimated Deposit B0x amount: ${ethers.utils.formatEther(amountToDeposit)}`);
    console.log(`Estimated Deposit 0xBTC amount: ${ethers.utils.formatUnits(amountWith8Decimals0xBTC, 8)}`);
    console.log(`amountWith8Decimals0xBTC: ${amountWith8Decimals0xBTC}`);
    console.log(`amountToDeposit: ${amountToDeposit}`);
    


        }
/*

    function createPositionWith2Tokens(
        address token,
        address token2,
        uint256 amountIn,
        uint256 amountIn2,
        uint currentx96,        // Expected sqrtPriceX96 when user initiated tx
        uint256 slippage,       // Slippage tolerance in basis points (e.g., 100 = 1%)
        address hookAddress,
        address toSendNFTto) public payable returns (bool)
            {
*/

const amountToDepositBN = ethers.BigNumber.from(amountToDeposit.toString());
const amountToDepositBN2 = ethers.BigNumber.from(amountWith8Decimals0xBTC.toString());


try{

                console.log("tokenAddress: ", tokenAddress);

                console.log("Address_ZEROXBTC_TESTNETCONTRACT: ", Address_ZEROXBTC_TESTNETCONTRACT.toString());

                console.log("amountToDepositBN: ", amountToDepositBN.toString());
                console.log("amountToDepositBN2: ", amountToDepositBN2.toString());
                console.log("Current_getsqrtPricex96: ", Current_getsqrtPricex96.toString());
                console.log("HookAddress: ", HookAddress.toString());
               

/*

const amountToSwapBN = ethers.BigNumber.from(amountToSwap.toString());
const minAmountOutBN = ethers.BigNumber.from(MinamountOut.toFixed(0).toString());



            try {
                // Call the swap function
                const tx = await tokenSwapperContract.swapTokenTWOTOKENS(
                    tokenAddress, 
                    Address_ZEROXBTC_TESTNETCONTRACT, 
                    tokenAddress, 
                    Address_ZEROXBTC_TESTNETCONTRACT, 
                    amountToSwapBN, 
                    minAmountOutBN, 
                    HookAddress, 
                    userAddress
                );
                */

                if(tokenAinputAddress == Address_ZEROXBTC_TESTNETCONTRACT) {
                    console.log("Check this out: ");
                    console.log("Check this out amountToDeposit: ",amountToDeposit);
                    console.log("Check this out amountWith8Decimals0xBTC: ",amountWith8Decimals0xBTC);
                    amountInputB.value = ethers.utils.formatUnits(amountToDeposit, 18);
                    amountInputA.value = ethers.utils.formatUnits(amountWith8Decimals0xBTC, 8);
                    console.log("THISRIGHT HUR");
                    ratiozToSave = 10**16*amountInputB.value / amountInputA.value;
                } else {
                    amountInputB.value = ethers.utils.formatUnits(amountWith8Decimals0xBTC, 8);
                    amountInputA.value = ethers.utils.formatUnits(amountToDeposit, 18);
                    ratiozToSave = 10**16/ amountInputB.value / amountInputA.value;
                }
                
                
            } catch (error) {
                console.error(`Error  create Position :`, error);
            }
        }





    


let Current_getsqrtPricex96=toBigNumber(0);

        let firstRun = false;
    let ratioz = toBigNumber(0);
async function getSqrtRtAndPriceRatio(nameOfFunction){

            if(!walletConnected){
               await connectWallet();
            }

const tokenSwapperABI = [
    // Your existing createPosition function
   {"inputs":[{"name":"token","type":"address"},{"name":"token2","type":"address"},{"name":"amountIn","type":"uint256"},{"name":"amountIn2","type":"uint256"},{"name":"currentx96","type":"uint256"},{"name":"slippage","type":"uint256"},{"name":"hookAddress","type":"address"},{"name":"toSendNFTto","type":"address"}],"name":"createPositionWith2Tokens","outputs":[{"name":"","type":"bool"}],"stateMutability":"payable","type":"function"},
    //get sqrtx96price for us
,{"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"address","name":"token2","type":"address"},{"internalType":"address","name":"hookAddress","type":"address"}],"name":"getsqrtPricex96","outputs":[{"internalType":"uint160","name":"","type":"uint160"}],"stateMutability":"view","type":"function"}

   ,{"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"address","name":"token2","type":"address"},{"internalType":"address","name":"hookAddress","type":"address"}],"name":"getPriceRatio","outputs":[{"internalType":"uint256","name":"ratio","type":"uint256"},{"internalType":"address","name":"token0z","type":"address"},{"internalType":"address","name":"token1z","type":"address"},{"internalType":"uint8","name":"token0decimals","type":"uint8"},{"internalType":"uint8","name":"token1decimals","type":"uint8"}],"stateMutability":"view","type":"function"}
];


                tokenSwapperContract = new ethers.Contract(
                    contractAddress_Swapper, // your tokenSwapper contract address
                    tokenSwapperABI,
                    signer // Use signer since the function isn't view/pure
                );

            let oldratioz = ratioz;
            try {
                // Call the view function
                const result = await tokenSwapperContract.callStatic.getPriceRatio(tokenAddress, Address_ZEROXBTC_TESTNETCONTRACT, HookAddress);




          // First debug what we're getting back
          console.log("Raw result type:", typeof result);
          console.log("Raw result structure:", Object.keys(result).join(", "));
          ratioz = result[0];

          
          
          console.log(`Found valid Ratio x10**18: ${ratioz.toString()}`);
          // Format to display as a readable number
          readableAmountOut = ethers.utils.formatEther(ratioz);
          ratioAsWei = ethers.utils.parseEther(readableAmountOut);
          console.log(`Found valid Ratio x10**18: ${readableAmountOut} mutliplier`);
        } catch (error) {
          console.error(`Error finding valid getPriceRatio for swap:`, error);
        }


        let oldsqrtPricex96 = Current_getsqrtPricex96;

      try {
        let oldresult = Current_getsqrtPricex96;
        // Call the view function
        const result = await tokenSwapperContract.getsqrtPricex96(tokenAddress, Address_ZEROXBTC_TESTNETCONTRACT, HookAddress);



          // First debug what we're getting back
          console.log("Raw result type:", typeof result);
          console.log("Raw result structure:", Object.keys(result).join(", "));
          
          if (typeof result === 'bigint' || typeof result === 'number') {
            // If it's already a primitive value
            Current_getsqrtPricex96 = result;
          } else if (result._isBigNumber || result instanceof ethers.BigNumber) {
            // For ethers v5 BigNumber
            Current_getsqrtPricex96 = result;
          } else if (typeof result === 'object' && result !== null) {
            // For objects, try to extract the value
            // With ethers v6, we might get the value directly
            if (typeof result.toString === 'function' && result.toString().match(/^[0-9]+$/)) {
              Current_getsqrtPricex96 = result;
            } else {
              // Attempt to extract value based on common patterns
              Current_getsqrtPricex96 = result[0] || result.amountOut || result._hex || result.value || result;
            }
          }
          
          console.log(`Found valid Current_getsqrtPricex96 x10**18: ${Current_getsqrtPricex96.toString()}`);
          // Format to display as a readable number
        } catch (error) {
          console.error(`Error finding valid Current_getsqrtPricex96 for swap:`, error);
        }


        if(!oldsqrtPricex96.eq(Current_getsqrtPricex96)  ){
            console.log("Calling oldsqrtPricex96 != Current_getsqrtPricex96  changed");
        }
        if(!oldratioz.eq(ratioz) ){
            console.log("Calling oldratioz != ratioz  changed");
            console.log("Calling oldratioz: ",oldratioz, " &&&&  ratioz: ",ratioz);
        }
        if((!oldsqrtPricex96.eq(Current_getsqrtPricex96) || !oldratioz.eq(ratioz)) && firstRun){
            console.log("Value changed calling getEstimate, getMaxCreate and getRatio");
            console.log("Value changed and called from: ", nameOfFunction);
            if(nameOfFunction !="SwapFunction"){

                await getEstimate();
            }
           await getRatioCreatePositiontokenA();
           await getRatioIncreasePositiontokenA();
           await getRatioStakeIncreasePositiontokenA();
        }
        oldsqrtPricex96 = Current_getsqrtPricex96;
        oldratioz=ratioz;
        firstRun = true;

}








        // Staking functions
        function depositStake() {
            const amount = document.getElementById('stakeAmount').value;
            if (!amount || amount <= 0) {
                alert('Please enter a valid amount to stake.');
                return;
            }
            alert(`Depositing ${amount} tokens for staking! Please confirm in your wallet.`);
        }

        async function withdrawStake() {


    // Get position data for unclaimed fees
    const positionSelect = document.querySelector('#staking-main-page .form-group2 select');
    const selectedPositionId = positionSelect.value;

    var positionStaking = stakingPositionData[selectedPositionId];
            if(positionStaking){
                console.log("Withdrawing Position: ",positionStaking.id )
                
                    console.log("Withdrawing Position: ", positionStaking.id);
                    var id = positionStaking.id.replace('stake_position_', '');
}





                const withdrawNFTabi = [
                    {
                        "inputs": [
                        {
                            "internalType": "uint256",
                            "name": "tokenId",
                            "type": "uint256"
                        }
                        ],
                        "name": "withdraw",
                        "outputs": [
                        {
                            "internalType": "bool",
                            "name": "",
                            "type": "bool"
                        }
                        ],
                        "stateMutability": "nonpayable",
                        "type": "function"
                    }
                    ];

//
                    LPStakingContract = new ethers.Contract(
                        contractAddressLPRewardsStaking, // your tokenSwapper contract address
                        withdrawNFTabi,
                        signer // Use signer since the function isn't view/pure
                    );





                    try {
                        console.log(`Withdrawing this NFT token ${id}...`);
                        
                        
                        // Step 2: Stake the NFT
                        const stakeTx = await LPStakingContract.withdraw(id);
                        
                        console.log("Staking transaction sent:", stakeTx.hash);
                        await stakeTx.wait(); // Wait for confirmation
                        console.log("NFT withdrew successfully!");
                        alert("NFT withdrew success!");
                         fetchBalances();
                         getTokenIDsOwnedByMetamask();
                        
                    } catch (error) {
                        console.error("Error approving/staking NFT:", error);
                    }



















    
            const amount = document.getElementById('stakeAmount').value;
            if (!amount || amount <= 0) {
                alert('Please enter a valid amount to withdraw.');
                return;
            }
        }
    




















async function fetchTokenBalanceWithEthers(tokenAddress, decimals) {

            if(!walletConnected){
               await connectWallet();
            }

    console.log("Fetching token Address: ", tokenAddress);
    if (!window.ethereum) {
        console.error("MetaMask not detected");
        return '0';
    }
    
    try {
      
        const walletAddress = await signer.getAddress();
        
        if (tokenAddress === '0x0000000000000000000000000000000000000000') {
            const balance = await provider.getBalance(walletAddress);
            return formatBalanceExact(balance, 18);
        }
        
        const abi = ["function balanceOf(address) view returns (uint256)"];
        const tokenContract = new ethers.Contract(tokenAddress, abi, provider);
        const balance = await tokenContract.balanceOf(walletAddress);
        console.log("Token balance 4, ", tokenAddress, " = ", balance.toString());
        return formatBalanceExact(balance, decimals);
    } catch (error) {
        console.error(`Error fetching token balance for ${tokenAddress}:`, error);
        return '0';
    }
}

// NEW: Exact formatting function that preserves precision
function formatBalanceExact(balance, decimals) {
    // Convert BigNumber to string to avoid precision loss
    const balanceString = balance.toString();
    
    // If decimals is 0, return the raw value
    if (decimals === 0) {
        return balanceString;
    }
    
    // For tokens with decimals, we need to handle the decimal point
    if (balanceString.length <= decimals) {
        // If the balance is smaller than the decimal places, pad with zeros
        const padded = balanceString.padStart(decimals, '0');
        return '0.' + padded;
    } else {
        // Insert decimal point at the right position
        const integerPart = balanceString.slice(0, balanceString.length - decimals);
        const decimalPart = balanceString.slice(balanceString.length - decimals);
        
        // Remove trailing zeros from decimal part for cleaner display
        const trimmedDecimal = decimalPart.replace(/0+$/, '');
        
        if (trimmedDecimal === '') {
            return integerPart;
        } else {
            return integerPart + '.' + trimmedDecimal;
        }
    }
}


        async function fetchBalances() {

            const walletAddress = userAddress;
            if (!walletAddress) {
                showStatus('Please enter a wallet address', 'error');
                return;
            }

            if (!walletAddress.match(/^0x[a-fA-F0-9]{40}$/)) {
                showStatus('Please enter a valid Ethereum address', 'error');
                return;
            }

           // const fetchBtn = document.getElementById('fetchBtn');
            //fetchBtn.disabled = true;
            //fetchBtn.textContent = 'Fetching...';
            
           // showStatus('Fetching balances from blockchain...', 'loading');
            walletBalances = {};
            console.log("test");

            try {
                const promises = Object.entries(tokenAddresses).map(async ([symbol, address]) => {
                    const balance = await fetchTokenBalanceWithEthers(address, tokenAddressesDecimals[symbol]);
                    walletBalances[symbol] = balance;
                    
                });

                await Promise.all(promises);
 displayWalletBalances();
               // showStatus('Balances fetched successfully!', 'success');
            } catch (error) {
                console.log("Error is : ", error);
               // showStatus(`Error fetching balances: ${error.message}`, 'error');
            } finally {
                //fetchBtn.disabled = false;
               // fetchBtn.textContent = 'Check Balances';
            }
        }




async function updateAdminFeeForPool(){

            if(!walletConnected){
                    await connectWallet();
            }
            

            var feeValue = document.getElementById('UpdateAdminFee').value;
            feeValue = Math.floor(feeValue * 10000)
            var hookABI = [{
        "inputs": [
            {
            "components": [
                {
                "internalType": "address",
                "name": "currency0",
                "type": "address"
                },
                {
                "internalType": "address",
                "name": "currency1",
                "type": "address"
                },
                {
                "internalType": "uint24",
                "name": "fee",
                "type": "uint24"
                },
                {
                "internalType": "int24",
                "name": "tickSpacing",
                "type": "int24"
                },
                {
                "internalType": "address",
                "name": "hooks",
                "type": "address"
                }
            ],
            "internalType": "struct PoolKey_Hook",
            "name": "key",
            "type": "tuple"
            },
            {
            "internalType": "uint24",
            "name": "newFee",
            "type": "uint24"
            }
        ],
        "name": "forceUpdateLPFee",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
        }];


                   var HookContract = new ethers.Contract(
                        HookAddress, // your tokenSwapper contract address
                        hookABI,
                        signer // Use signer since the function isn't view/pure
                    );


var tokencheck = Address_ZEROXBTC_TESTNETCONTRACT;
var tokencheck2 = tokenAddresses['B0x'];
console.log("tokenCheck: ", tokencheck);
console.log("tokencheck2: ", tokencheck2);
// Simple string comparison (addresses as hex strings)
let currency0, currency1;

if (tokencheck.toLowerCase() < tokencheck2.toLowerCase()) {
    currency0 = tokencheck;
    currency1 = tokencheck2;
} else {
    currency0 = tokencheck2;
    currency1 = tokencheck;
}

console.log("currency0: ", currency0);
console.log("currency1: ", currency1);
// Define the PoolKey_Hook struct
const poolKey = {
    currency0: currency0,
    currency1: currency1,
    fee: 0x800000,        // uint24
    tickSpacing: 60,   // int24
    hooks: hookAddress
};



              const tx = await HookContract.forceUpdateLPFee(poolKey, feeValue );


      console.log("forceUpdateLPFee transaction sent:", tx.hash);
      console.log("Waiting for transaction confirmation...");
      
      // Wait for the transaction to be mined
      const receipt = await tx.wait();
      console.log("Confirmed forceUpdateLPFee Token")
}


            var addressValue = document.getElementById('UpdateAdminFee').value;
async function addERC20ToStakingContract(){
            if(!walletConnected){
                    await connectWallet();
            }
            
            var addressValue = document.getElementById('basic-address-add').value;
            console.log(addressValue);

        var abiAddRewardToken =[{
            "inputs": [
                {
                "internalType": "contract IERC20",
                "name": "token",
                "type": "address"
                }
            ],
            "name": "addRewardToken",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
            }];




                   var LPRewardsStakingContract = new ethers.Contract(
                        contractAddressLPRewardsStaking, // your tokenSwapper contract address
                        abiAddRewardToken,
                        signer // Use signer since the function isn't view/pure
                    );

              const tx = await LPRewardsStakingContract.addRewardToken(addressValue);
        
      console.log("AddRewardToken transaction sent:", tx.hash);
      console.log("Waiting for transaction confirmation...");
      
      // Wait for the transaction to be mined
      const receipt = await tx.wait();
      console.log("Confirmed AddReward Token")
      await getRewardStats();


}


async function removeERC20FromStakingContract(){
            if(!walletConnected){
                    await connectWallet();
            }
            
            var addressValueRemove = document.getElementById('basic-address-remove').value;
            console.log(addressValueRemove);

        var abiAddRewardToken =[{
            "inputs": [
                {
                "internalType": "contract IERC20",
                "name": "token",
                "type": "address"
                }
            ],
            "name": "removeRewardToken",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
            }];




                   var LPRewardsStakingContract = new ethers.Contract(
                        contractAddressLPRewardsStaking, // your tokenSwapper contract address
                        abiAddRewardToken,
                        signer // Use signer since the function isn't view/pure
                    );

              const tx = await LPRewardsStakingContract.removeRewardToken(addressValueRemove);
        
      console.log("removeRewardToken transaction sent:", tx.hash);
      console.log("Waiting for transaction confirmation...");
      
      // Wait for the transaction to be mined
      const receipt = await tx.wait();
      console.log("Confirmed Remove Token")

      await getRewardStats();

}

     
                        
async function addRewardToken(){

            if(!walletConnected){
               await connectWallet();
            }
            var inputtedTokenAddress = document.getElementById("rewardTokenAddress").value;
        console.log("INPUTED ADDRESS = ", inputtedTokenAddress);
                        const startRewardABI = [{
                                        "inputs": [
                                            {
                                            "internalType": "contract IERC20",
                                            "name": "token",
                                            "type": "address"
                                            }
                                        ],
                                        "name": "addRewardToken",
                                        "outputs": [],
                                        "stateMutability": "nonpayable",
                                        "type": "function"
                                        }
                        ];


await approveIfNeeded(USDCToken, contractAddressLPRewardsStaking, 30*10**6);

                 var   LPRewarsdStakingContract = new ethers.Contract(
                        contractAddressLPRewardsStaking, // your tokenSwapper contract address
                        startRewardABI,
                        signer // Use signer since the function isn't view/pure
                    );
                    const tx  = await LPRewarsdStakingContract.addRewardToken(inputtedTokenAddress);
                          
                                    console.log("Transaction sent:", tx.hash);
                                    const receipt12 = await tx.wait();
                                console.log("addRewardToken with USDC for public Confirmed@!")

    

      await getRewardStats();


}

async function startRewardPeriod(){


            if(!walletConnected){
               await connectWallet();
            }
            var inputtedTokenAddress = document.getElementById("selectedRewardToken").value;
                                    console.log("INPUTED ADDRESS = ", inputtedTokenAddress);
                        const startRewardABI = [{
                            "inputs": [
                                {
                                "internalType": "contract IERC20",
                                "name": "token",
                                "type": "address"
                                }
                            ],
                            "name": "setRewardParams",
                            "outputs": [],
                            "stateMutability": "nonpayable",
                            "type": "function"
                            }
                        ];



                 var   LPRewarsdStakingContract = new ethers.Contract(
                        contractAddressLPRewardsStaking, // your tokenSwapper contract address
                        startRewardABI,
                        signer // Use signer since the function isn't view/pure
                    );
                    const tx  = await LPRewarsdStakingContract.setRewardParams(inputtedTokenAddress);
                          
                                    console.log("Transaction sent:", tx.hash);
                                    const receipt12 = await tx.wait();
                                console.log("setRewardParamsTransaction Confirmed@!")

      await getRewardStats();
    
}





function addMaxButtonToField(inputElement, tokenSymbol) {
    // Create MAX button
    const maxButton = document.createElement('button');
    maxButton.type = 'button';
    maxButton.textContent = 'MAX';
    maxButton.className = 'max-button';
    maxButton.style.cssText = `
        position: absolute;
        right: 2px;
        top: 2px;
        bottom: 2px;
        background: #007bff;
        color: white;
        border: none;
        padding: 0 12px;
        border-radius: 0 2px 2px 0;
        font-size: 12px;
        cursor: pointer;
        z-index: 10;
        display: flex;
        align-items: center;
        justify-content: center;
    `;
    
    // Add hover effect
    maxButton.addEventListener('mouseenter', () => {
        maxButton.style.background = '#0056b3';
    });
    maxButton.addEventListener('mouseleave', () => {
        maxButton.style.background = '#007bff';
    });
    
    // Add click handler with proper context
    maxButton.addEventListener('click', function() {
        const positionSelect = document.querySelector('#stakeincrease select');
        const selectedPositionId = positionSelect.value;
        const position = stakingPositionData[selectedPositionId];
        
    const swapSection = document.getElementById('stakeincrease');
    if (!swapSection || !swapSection.contains(inputElement)) {
        console.log("Not in stakeincrease section, returning early");
        return;
    }

        if (!position) return;
        
        // Determine which token we're working with
        const label = inputElement.closest('.form-group').querySelector('label');
        let currentTokenSymbol = tokenSymbol;
        let maxAmount = 0;
        
        if (label && label.textContent.includes(position.tokenA)) {
            currentTokenSymbol = position.tokenA;

        handleMaxButtonClickStakeIncrease(currentTokenSymbol,inputElement);
        } else if (label && label.textContent.includes(position.tokenB)) {
            currentTokenSymbol = position.tokenB;
        handleMaxButtonClickStakeIncrease(currentTokenSymbol,inputElement);
        } else {
            maxAmount = getMaxAmountForToken(position, currentTokenSymbol);
        }
        
    });
    

    // Add click handler with proper context
    maxButton.addEventListener('click', function() {
        const positionSelect = document.querySelector('#increase select');

    const swapSection = document.getElementById('increase');
    if (!swapSection || !swapSection.contains(inputElement)) {
        console.log("Not in increase section, returning early");
        return;
    }
        const selectedPositionId = positionSelect.value;
        const position = positionData[selectedPositionId];
        if (!position) return;
        
        // Determine which token we're working with
        const label = inputElement.closest('.form-group').querySelector('label');
        let currentTokenSymbol = tokenSymbol;
        let maxAmount = 0;
        if (label && label.textContent.includes(position.tokenA)) {
            currentTokenSymbol = position.tokenA;
        handleMaxButtonClick(currentTokenSymbol,inputElement);
        } else if (label && label.textContent.includes(position.tokenB)) {
            currentTokenSymbol = position.tokenB;

        handleMaxButtonClick(currentTokenSymbol,inputElement);
        } else {
            maxAmount = getMaxAmountForToken(position, currentTokenSymbol);

        console.log("tokenC max selected :",maxAmount);
        }

    });

    // Add click handler with proper context
    maxButton.addEventListener('click', function() {

    const swapSection = document.getElementById('swap');
    if (!swapSection || !swapSection.contains(inputElement)) {
        console.log("Not in swap section, returning early");
        return;
    }
        console.log("this!")
        // Get the currently selected token from the dropdown
        const fromTokenSelect = document.getElementById('fromToken');
        const tokenSelected = fromTokenSelect.value; // This will be 'ETH', 'USDC', etc.
        
        // Get the wallet balance for the selected token
        const maxAmount = getMaxAmountForTokenList(tokenSelected);
        
        // Set the max amount in the input field
        setMaxAmount2(inputElement, tokenSelected, maxAmount);

        console.log("this! !: ", maxAmount);
    });



    // Add click handler for MAX button
    maxButton.addEventListener('click', function() {


    const createSection = document.getElementById('create');
    if (!createSection || !createSection.contains(inputElement)) {
        console.log("Not in create section, returning early");
        return;
    }

    // Get the Token A select element specifically inside the #create page
    const tokenSelect = document.querySelector('#create .form-row .form-group:nth-child(1) select');
//const label = inputElement.closest('form-group').querySelector('label');
const label = inputElement.closest('.form-group').querySelector('label');
                // Extract the text from the label element
            const labelText = label.textContent;

            // Now split the string
            const token = labelText.split(' ').pop();

    // Now tokenSelect is the correct <select> element for Token A or Token B
    console.log('Selected token:', tokenSelect.value);

        const selectedToken = tokenSelect.value.split(' - ')[0]; // Gets "ETH" from "ETH - Ethereum"
        const walletBalance = walletBalances[selectedToken] || 0;
        
        // Format based on token type
        const formattedValue = ['ETH', 'WBTC'].includes(selectedToken) 
            ? parseFloat(walletBalance).toFixed(6)
            : parseFloat(walletBalance).toFixed(2);
        
        const maxAmount = getMaxAmountForTokenList(selectedToken);

        if (label && label.textContent.trim() === 'Amount A') {
            console.log("Amount A Activated!");
        // Set the max amount in the input field
        //setMaxAmount2(inputElement, selectedToken, maxAmount);
        getMaxCreatePosition();
        }
    });



 maxButton.addEventListener('click', function() {



    const createSection = document.getElementById('create');
    if (!createSection || !createSection.contains(inputElement)) {
        console.log("Not in create section, returning early");
        return;
    }



    // Get the Token A select element specifically inside the #create page
    const tokenSelect = document.querySelector('#create .form-row .form-group:nth-child(2) select');

const label = inputElement.closest('.form-group').querySelector('label');
    // Now tokenSelect is the correct <select> element for Token A or Token B
    console.log('Selected token:', tokenSelect.value);

        const selectedToken = tokenSelect.value.split(' - ')[0]; // Gets "ETH" from "ETH - Ethereum"
        const walletBalance = walletBalances[selectedToken] || 0;
        
        // Format based on token type
        const formattedValue = ['ETH', 'WBTC'].includes(selectedToken) 
            ? parseFloat(walletBalance).toFixed(6)
            : parseFloat(walletBalance).toFixed(2);
        
        const maxAmount = getMaxAmountForTokenList(selectedToken);

        if (label && label.textContent.trim() === 'Amount B') {
            console.log("Amount B Activated!");
        // Set the max amount in the input field
        //setMaxAmount2(inputElement, selectedToken, maxAmount);

        getMaxCreatePosition();
        }
        // Set the max amount in the input field
    });


 maxButton.addEventListener('click', function() {



    const createSection = document.getElementById('create');
    if (!createSection || !createSection.contains(inputElement)) {
        console.log("Not in create section, returning early");
        return;
    }



    // Get the Token A select element specifically inside the #create page
    const tokenSelect = document.querySelector('#create .form-row .form-group:nth-child(2) select');

const label = inputElement.closest('.form-group').querySelector('label');
    // Now tokenSelect is the correct <select> element for Token A or Token B
    console.log('Selected token:', tokenSelect.value);

        const selectedToken = tokenSelect.value.split(' - ')[0]; // Gets "ETH" from "ETH - Ethereum"
        const walletBalance = walletBalances[selectedToken] || 0;
        
        // Format based on token type
        const formattedValue = ['ETH', 'WBTC'].includes(selectedToken) 
            ? parseFloat(walletBalance).toFixed(6)
            : parseFloat(walletBalance).toFixed(2);
        
        const maxAmount = getMaxAmountForTokenList(selectedToken);

        if (label && label.textContent.trim() === 'Amount B') {
            console.log("Amount B Activated!");
        // Set the max amount in the input field
        //setMaxAmount2(inputElement, selectedToken, maxAmount);

        getMaxCreatePosition();
        }
        // Set the max amount in the input field
    });

    // Make input element relative positioned
    inputElement.style.position = 'relative';
    
    // Create wrapper just for input and button
    const wrapper = document.createElement('div');
    wrapper.style.cssText = 'position: relative; display: inline-block; width: 100%;';
    
    // Insert wrapper before input
    inputElement.parentNode.insertBefore(wrapper, inputElement);
    
    // Move input into wrapper
    wrapper.appendChild(inputElement);
    
    // Add padding to input to make room for button and remove input's border radius on right
    inputElement.style.paddingRight = '60px';
    inputElement.style.borderTopRightRadius = '0';
    inputElement.style.borderBottomRightRadius = '0';
    
    // Append button to wrapper (not the form-group container)
    wrapper.appendChild(maxButton);
}


// Helper function to get max amount for different token types
// Simplified function to get max amount based on selected token
function getMaxAmountForTokenList(tokenSymbol) {
    // Return the wallet balance for the selected token
    return walletBalances[tokenSymbol] || 0;
}



// Modified setMaxAmount function
function setMaxAmount2(inputElement, tokenSymbol, amount) {
    if (!inputElement) return;
    
    // Format amount based on token type
    let formattedAmount = amount;
    
    inputElement.value = formattedAmount;
    inputElement.dispatchEvent(new Event('input')); // Trigger any calculations
}



// Helper function to get max amount for different token types
function getMaxAmountForToken(position, tokenSymbol) {
    // Check wallet balances first (from your earlier implementation)
    const walletBalance = walletBalances[tokenSymbol] || 0;
    
    
    // Default case (for ETH or other tokens)
    return walletBalance;
}

// Modified setMaxAmount function
function setMaxAmount(inputElement, tokenSymbol, amount) {
    if (!inputElement) return;
    
    // Format amount based on token type
    let formattedAmount;
    if (['WBTC', 'ETH'].includes(tokenSymbol)) {
        formattedAmount = parseFloat(amount).toFixed(6);
    } else {
        formattedAmount = parseFloat(amount).toFixed(4);
    }
    
    inputElement.value = amount;
    inputElement.dispatchEvent(new Event('input'));
}

function initializeMaxButtons() {
    // SWAP PAGE - Amount field
    const swapAmountInput = document.querySelector('#swap input[type="number"][placeholder="0.0"]');
    if (swapAmountInput) {
        // Get the selected token from From Token dropdown
        const getSwapToken = () => {
            const fromSelect = document.querySelector('#swap .form-group:nth-child(2) select');
            return fromSelect ? fromSelect.value : 'ETH';
        };
        
        addMaxButtonToField(swapAmountInput, getSwapToken());
        
        // Update when From Token changes
        const fromSelect = document.querySelector('#swap .form-group:nth-child(2) select');
        if (fromSelect) {
            fromSelect.addEventListener('change', () => {
                // Remove old button
                const oldButton = swapAmountInput.parentElement.querySelector('.max-button');
                if (oldButton) oldButton.remove();
                
                // Add new button with updated token
                addMaxButtonToField(swapAmountInput, getSwapToken());
            });
        }
    }
    
    // CREATE POSITION PAGE - Amount A and Amount B
    const createAmountInputs = document.querySelectorAll('#create input[type="number"][placeholder="0.0"]');
    createAmountInputs.forEach((input, index) => {
        const getCreateToken = (inputIndex) => {
            const selects = document.querySelectorAll('#create .token-selector select');
            return selects[inputIndex] ? selects[inputIndex].value : (inputIndex === 0 ? 'ETH' : 'USDC');
        };
        
        addMaxButtonToField(input, getCreateToken(index));
        
        // Update when token selection changes
        const tokenSelect = document.querySelectorAll('#create .token-selector select')[index];
        if (tokenSelect) {
            tokenSelect.addEventListener('change', () => {
                // Remove old button
                const oldButton = input.parentElement.querySelector('.max-button');
                if (oldButton) oldButton.remove();
                
                // Add new button with updated token
                addMaxButtonToField(input, getCreateToken(index));
            });
        }
    });
    
    // INCREASE LIQUIDITY PAGE - The two token amount fields
    const increaseInputs = document.querySelectorAll('#increase .form-row input[type="number"]');
    increaseInputs.forEach((input, index) => {
        const getIncreaseToken = (inputIndex) => {
            const labels = document.querySelectorAll('#increase .form-row label');
            if (labels[inputIndex]) {
                const labelText = labels[inputIndex].textContent;
                return labelText.replace('Add ', '');
            }
            return inputIndex === 0 ? 'ETH' : 'USDC';
        };
        
        addMaxButtonToField(input, getIncreaseToken(index));
        
        // Update when position changes (since tokens change based on selected position)
        const positionSelect = document.querySelector('#increase select');
        if (positionSelect) {
            positionSelect.addEventListener('change', () => {
                // Small delay to let the labels update first
                setTimeout(() => {
                    // Remove old button
                    const oldButton = input.parentElement.querySelector('.max-button');
                    if (oldButton) oldButton.remove();
                    
                    // Add new button with updated token
                    addMaxButtonToField(input, getIncreaseToken(index));
                }, 100);
            });
        }
    });



    
    // INCREASE LIQUIDITY PAGE - The two token amount fields
    const increaseInputsStaking = document.querySelectorAll('#stakeincrease .form-row input[type="number"]');
    increaseInputsStaking.forEach((input, index) => {
        const getIncreaseToken = (inputIndex) => {
            const labels = document.querySelectorAll('#stakeincrease .form-row label');
            if (labels[inputIndex]) {
                const labelText = labels[inputIndex].textContent;
                return labelText.replace('Add ', '');
            }
            return inputIndex === 0 ? 'ETH' : 'USDC';
        };
        
        addMaxButtonToField(input, getIncreaseToken(index));
        
        // Update when position changes (since tokens change based on selected position)
        const positionSelect = document.querySelector('#stakeincrease select');
        if (positionSelect) {
            positionSelect.addEventListener('change', () => {
                // Small delay to let the labels update first
                setTimeout(() => {
                    // Remove old button
                    const oldButton = input.parentElement.querySelector('.max-button');
                    if (oldButton) oldButton.remove();
                    
                    // Add new button with updated token
                    addMaxButtonToField(input, getIncreaseToken(index));
                }, 100);
            });
        }
    });







    // INCREASE LIQUIDITY PAGE - The two token amount fields
    const createPositionField = document.querySelectorAll('#create .form-row input[type="number"]');
    createPositionField.forEach((input, index) => {
        const getIncreaseToken = (inputIndex) => {
            const labels = document.querySelectorAll('#create .form-row label');
            if (labels[inputIndex]) {
                const labelText = labels[inputIndex].textContent;
                return labelText.replace('Add ', '');
            }
            return inputIndex === 0 ? 'ETH' : 'USDC';
        };
        
        addMaxButtonToField(input, getIncreaseToken(index));
        
        // Update when position changes (since tokens change based on selected position)
        const positionSelect = document.querySelector('#create select');
        if (positionSelect) {
            positionSelect.addEventListener('change', () => {
                // Small delay to let the labels update first
                setTimeout(() => {
                    // Remove old button
                    const oldButton = input.parentElement.querySelector('.max-button');
                    if (oldButton) oldButton.remove();
                    
                    // Add new button with updated token
                    addMaxButtonToField(input, getIncreaseToken(index));
                }, 100);
            });
        }
    });
    
}






















// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    filterTokenOptionsSwap();
    // Small delay to ensure other scripts have run first
    setTimeout(initializeMaxButtons, 200);
});

// Also run when called manually (in case DOM is already loaded)
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeMaxButtons);
} else {
    setTimeout(initializeMaxButtons, 200);
}


       // Update token icon and handle dropdown filtering
        function updateTokenSelection(selectId, iconId) {
            const select = document.getElementById(selectId);
            const icon = document.getElementById(iconId);
            const selectedValue = select.value;
            
                            const tokenIcons = {
                                'ETH': 'E',
                                'USDC': 'U',
                                'DAI': 'D',
                                'WBTC': 'W'
                            };
            // Update icon
            icon.textContent = tokenIcons[selectedValue] || selectedValue.charAt(0);
            
        }

        // Filter options to hide selected tokenA in tokenB dropdown only
        function filterTokenOptionsCreate() {
            const tokenA = document.getElementById('tokenA');
            const tokenB = document.getElementById('tokenB');
            const tokenAValue = tokenA.value;
            const tokenBValue = tokenB.value;
            
            // Reset all tokenB options to visible first
            Array.from(tokenB.options).forEach(option => {
                option.style.display = '';
                option.disabled = false;
            });
            
            // Hide the selected tokenA option in tokenB dropdown only
            Array.from(tokenB.options).forEach(option => {
                if (option.value === tokenAValue) {
                    option.style.display = 'none';
                    option.disabled = true;
                }
            });
            
            // If current tokenB selection matches tokenA, change it to first available option
            if (tokenBValue === tokenAValue) {
                const availableOptions = Array.from(tokenB.options).filter(option => 
                    option.value !== tokenAValue && option.style.display !== 'none'
                );
                if (availableOptions.length > 0) {
                    tokenB.value = availableOptions[0].value;
                    updateTokenSelection('tokenB', 'tokenBIcon');
                }
            }
        }


        // Filter options to hide selected fromToken in toToken dropdown only
        function filterTokenOptionsSwap() {
            const fromToken = document.getElementById('fromToken');
            const toToken = document.getElementById('toToken');
            const fromValue = fromToken.value;
            const toValue = toToken.value;
            
            // Reset all toToken options to visible first
            Array.from(toToken.options).forEach(option => {
                option.style.display = '';
                option.disabled = false;
            });
            
            // Hide the selected fromToken option in toToken dropdown only
            Array.from(toToken.options).forEach(option => {
                if (option.value === fromValue) {
                    option.style.display = 'none';
                    option.disabled = true;
                }
            });
            
            // If current toToken selection matches fromToken, change it to first available option
            if (toValue === fromValue) {
                const availableOptions = Array.from(toToken.options).filter(option => 
                    option.value !== fromValue && option.style.display !== 'none'
                );
                if (availableOptions.length > 0) {
                    toToken.value = availableOptions[0].value;
                    updateTokenIcon('toToken', 'toTokenIcon');
                }
            }
        }

// Function to update token icon and clear amount field
function updateTokenIcon(selectId, iconId) {
    // Get the selected token
    const select = document.getElementById(selectId);
    const token = select.value;
    
    // Update the icon (your existing code)
    const icon = document.getElementById(iconId);
    icon.textContent = token.charAt(0); // First letter of token
    
    // Clear the amount input field in the same form group
    const formGroup = select.closest('.form-group').nextElementSibling;
    if (formGroup && formGroup.classList.contains('form-group')) {
        const amountInput = formGroup.querySelector('input[type="number"]');
        if (amountInput) {
            amountInput.value = '0.0';
        }
    }
                filterTokenOptionsSwap();
}

// Add event listener to token selector
document.getElementById('fromToken').addEventListener('change', function() {
    updateTokenIcon('fromToken', 'fromTokenIcon');
});


        




            function swapTokens() {
                const formGroups = document.querySelectorAll('#swap .form-group');
                let fromSelect, toSelect, fromIcon, toIcon;
                
                formGroups.forEach(group => {
                    const label = group.querySelector('label');
                    if (label && label.textContent === 'From Token') {
                        fromSelect = group.querySelector('select');
                        fromIcon = group.querySelector('.token-icon');
                    } else if (label && label.textContent === 'To Token') {
                        toSelect = group.querySelector('select');
                        toIcon = group.querySelector('.token-icon');
                    }
                });
                
                if (fromSelect && toSelect && fromIcon && toIcon) {
                    // Swap the select values
                    const fromValue = fromSelect.value;
                    const toValue = toSelect.value;
                    
                    fromSelect.value = toValue;
                    toSelect.value = fromValue;
                    
                    // Update icons based on new values using the token mapping
                    const tokenIcons = {
                        'ETH': 'E',
                        'USDC': 'U',
                        'DAI': 'D',
                        'WBTC': 'W'
                    };
                    
                    fromIcon.textContent = tokenIcons[fromSelect.value] || fromSelect.value.charAt(0);
                    toIcon.textContent = tokenIcons[toSelect.value] || toSelect.value.charAt(0);


                }
                getEstimate();
            }



const createSection = document.getElementById('create');

if (createSection) {
    const tokenASelect = createSection.querySelector('#tokenA');
    const tokenBSelect = createSection.querySelector('#tokenB');
    const amountAInput = createSection.querySelector('#amountA');
    const amountBInput = createSection.querySelector('#amountB');

    if (tokenASelect && tokenBSelect && amountAInput && amountBInput) {
        // Function to swap amount values
        function swapAmounts() {
            const currentAmountA = amountAInput.value;
            const currentAmountB = amountBInput.value;
            
            amountAInput.value = currentAmountB;
            amountBInput.value = currentAmountA;
            
            console.log('Swapped amounts - A:', currentAmountB, 'B:', currentAmountA);
        }
        
        // Listen for Token A changes
        tokenASelect.addEventListener('change', function() {
            console.log('Token A changed to:', this.value);
            swapAmounts();
        });
        
    } else {
        console.log('Could not find token selects or amount inputs in create section');
    }
} else {
    console.log('Create section not found');
}






    </script>
    </body></html>
