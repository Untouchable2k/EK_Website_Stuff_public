<!DOCTYPE html>
<html lang="en">
<head>
<script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DeFi Operations</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(45deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 300;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }

        .nav-tabs {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(2, 1fr);
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
            gap: 1px;
        }

        .nav-tab {
            padding: 20px 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border: none;
            background: transparent;
            font-size: 1em;
            font-weight: 500;
            color: #6c757d;
            white-space: nowrap;
        }

        .nav-tab:hover {
            background: #e9ecef;
            color: #495057;
        }

        .nav-tab.active {
            background: white;
            color: #007bff;
            border-bottom: 3px solid #007bff;
        }

        @media (max-width: 768px) {
            .nav-tabs {
                grid-template-columns: repeat(2, 1fr);
                grid-template-rows: repeat(4, 1fr);
            }
        }
        .content {
            padding: 40px;
            min-height: 500px;
        }

        .page {
            display: none;
            animation: fadeIn 0.3s ease-in;
        }

        .page.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .form-group {
            margin-bottom: 25px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }

        .form-group input, .form-group select {
            width: 100%;
            padding: 15px;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            font-size: 1em;
            transition: all 0.3s ease;
        }

        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);
        }






















        .form-group2 {
            margin-bottom: 25px;
        }

        .form-group2 label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }

        .form-group2 input, .form-group2 select {
            width: 100%;
            padding: 15px;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            font-size: 1em;
            transition: all 0.3s ease;
        }

        .form-group2 input:focus, .form-group2 select:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .btn-primary, .btn-success, .btn-warning {
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;#
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            margin-top: 20px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #007bff, #0056b3);
        }

        .btn-success {
            background: linear-gradient(45deg, #28a745, #1e7e34);
        }

        .btn-warning {
            background: linear-gradient(45deg, #ffc107, #e0a800);
        }

        .btn-primary:hover, .btn-success:hover, .btn-warning:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0, 123, 255, 0.3);
        }

        .btn-row {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
        }

        .swap-direction {
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 20px 0;
        }

        .swap-arrow {
            background: #007bff;
            color: white;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 1.5em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .swap-arrow:hover {
            transform: rotate(180deg);
            background: #0056b3;
        }

        .token-selector {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .token-icon {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: linear-gradient(45deg, #ffd700, #ffed4a);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #333;
        }

        .info-card {
            background: #f8f9fa;
            border-left: 4px solid #007bff;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .info-card h3 {
            color: #007bff;
            margin-bottom: 10px;
        }

        .info-card2 {
            background: #f8f9fa;
            border-left: 4px solid #007bff;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .info-card2 h3 {
            color: #007bff;
            margin-bottom: 10px;
        }


        .info-card3 {
            background: #f8f9fa;
            border-left: 4px solid #007bff;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .info-card3 h3 {
            color: #007bff;
            margin-bottom: 10px;
        }

        .rewards-card {
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 25px;
            text-align: center;
        }

        .rewards-card h3 {
            font-size: 1.8em;
            margin-bottom: 15px;
        }

        .rewards-amount {
            font-size: 2.5em;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .rewards-usd {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .staking-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 25px;
        }

        .stat-card {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #007bff;
            margin-bottom: 5px;
        }

        .stat-label {
            color: #6c757d;
            font-size: 0.9em;
        }

        .slider-container {
            margin: 20px 0;
        }

        .slider {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
        }

        .percentage-display {
            text-align: center;
            font-size: 1.2em;
            font-weight: bold;
            color: #007bff;
            margin-top: 10px;
        }

        @media (max-width: 768px) {
            .nav-tabs {
                flex-wrap: wrap;
            }
            
            .nav-tab {
                flex: 1 1 150px;
                min-width: 100px;
            }
            
            .form-row, .staking-stats {
                grid-template-columns: 1fr;
            }

            .btn-row {
                grid-template-columns: 1fr;
            }
            
            .container {
                margin: 10px;
            }
        }

            #connectBtn {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                border: none;
                padding: 12px 24px;
                border-radius: 8px;
                font-size: 28px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.3s ease;
                box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
                }

                #connectBtn:hover {
                transform: translateY(-2px);
                box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
                background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
                }

                #connectBtn:active {
                transform: translateY(0);
                }

                /* Connected state */
                #connectBtn.connected {
                background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
                box-shadow: 0 4px 15px rgba(17, 153, 142, 0.3);
                }

                #connectBtn.connected:hover {
                background: linear-gradient(135deg, #38ef7d 0%, #11998e 100%);
                box-shadow: 0 6px 20px rgba(17, 153, 142, 0.4);
                }

                /* Disconnect Button */
                #walletInfo button {
                background: #ff4757;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 6px;
                font-size: 22px;
                cursor: pointer;
                margin-left: 10px;
                transition: all 0.3s ease;
                }

                #walletInfo button:hover {
                background: #ff3742;
                transform: translateY(-1px);
                }

#walletAddress {
  font-size: 16px;
  font-weight: 600;
  font-family: 'Courier New', monospace;
  padding: 12px 16px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  border-radius: 10px;
  display: inline-block;
  margin-right: 12px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  border: none;
  letter-spacing: 0.5px;
}











.token-list {
    list-style: none;
    padding: 0;
    margin: 0;
}

.token-list li {
    display: flex;
    justify-content: space-between;
    padding: 8px 12px;
    border-bottom: 1px solid #eee;
}

.token-symbol {
    font-weight: bold;
    color: #333;
}

.token-address {
    font-family: monospace;
    font-size: 0.9em;
    color: #666;
}

.periods-table {
    width: 100%;
    border-collapse: collapse;
}

.periods-table th, .periods-table td {
    padding: 10px;
    text-align: left;
    border-bottom: 1px solid #eee;
}

.periods-table th {
    background-color: #f8f9fa;
}










.wallet-balances {
    margin-bottom: 20px;
}

.balances-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
    gap: 15px;
    margin-top: 15px;
}

.balance-item {
    background: #f8f9fa;
    border-radius: 8px;
    padding: 12px;
    display: flex;
    flex-direction: column;
}

.token-name {
    font-weight: bold;
    color: #333;
    margin-bottom: 5px;
}

.token-amount {
    font-size: 1.1em;
    color: #212529;
}
        















        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 24px;
            margin-bottom: 24px;
        }

        .settings-form {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .settings-form h3 {
            color: #2d3748;
            margin-bottom: 8px;
            font-size: 1.25rem;
        }

        .settings-form p {
            color: #4a5568;
            margin-bottom: 20px;
            line-height: 1.5;
            font-size: 0.9rem;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: #2d3748;
            font-weight: 500;
        }

        .input-group {
            display: flex;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            overflow: hidden;
            transition: border-color 0.3s;
        }

        .input-group:focus-within {
            border-color: #667eea;
        }

        .input-group input {
            flex: 1;
            padding: 12px 16px;
            border: none;
            outline: none;
            font-size: 1rem;
        }

        .input-group .unit {
            background: #f7fafc;
            padding: 12px 16px;
            color: #4a5568;
            font-weight: 500;
            border-left: 1px solid #e2e8f0;
        }

        textarea {
            width: 100%;
            padding: 16px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
            resize: vertical;
            min-height: 120px;
            transition: border-color 0.3s;
        }

        textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .btn-secondary {
            background: #e2e8f0;
            color: #2d3748;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s;
            margin-right: 12px;
        }

        .btn-secondary:hover {
            background: #cbd5e0;
            transform: translateY(-1px);
        }

        .button-group {
            display: flex;
            gap: 12px;
            margin-top: 16px;
        }

        .address-config {
            grid-column: 1 / -1;
        }

        .success-message {
            background: #c6f6d5;
            color: #22543d;
            padding: 12px 16px;
            border-radius: 8px;
            margin-top: 12px;
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>DeFi Operations</h1>
            <p>Swap, Stake, and Manage Your Liquidity Positions</p>
        </div>

        <div class="nav-tabs">
            <button class="nav-tab active" onclick="switchTab('swap')">Swap</button>
            <button class="nav-tab" onclick="switchTab('create')">Create Position</button>
            <button class="nav-tab" onclick="switchTab('increase')">Increase Liquidity</button>
            <button class="nav-tab" onclick="switchTab('decrease')">Decrease Liquidity</button>
            <button class="nav-tab" onclick="switchTab('staking-main-page')">Staking</button>
            <button class="nav-tab" onclick="switchTab('stake-increase')">Stake Increase</button>
            <button class="nav-tab" onclick="switchTab('stake-decrease')">Stake Decrease</button>
            <button class="nav-tab" onclick="switchTab('settings')">Settings</button>
            <button class="nav-tab" onclick="switchTab('staking-management')">Stake Management</button>
            <button class="nav-tab" onclick="switchTab('testnet-faucet')">Testnet Token Facuet</button>
        </div>
        <center>
        <div class="wallet-section">
        <button id="connectBtn" onclick="connectWallet()">Connect Wallet</button>
        <div id="walletInfo" style="display: none;">
            <span id="walletAddress"></span>
            <button onclick="disconnectWallet()">Disconnect</button>
        </div>
        </center>
        <div class="content">
             <!-- Settings Page -->
    <div id="testnet-faucet" class="page">
        <div class="info-card">
            <h3>Testnet Facuet</h3>
            <p>Collect 10 0xBTC and 10 B0x for testing!</p>
        </div>

                <button class="btn-primary" onclick="getFacuetTokens()">Get 10 0xBTC + 10 B0x for Testnet Two Transactions</button>


            </div>

             <!-- Settings Page -->
    <div id="settings" class="page">
        <div class="info-card">
            <h3>System Settings</h3>
            <p>Configure minimum staking amounts and user holding requirements for the platform. To prevent Spam Attacks!</p>
        </div>

        <div class="settings-grid">

            <div class="settings-form address-config">
                <h3>🏦 Staking Rewards Contract Address Configuration</h3>
                <p>Configure the Reward contract addresses used by the platform. Enter reward addresses in JSON array format.</p>
                
                <div class="form-group">
                    <label>Reward Contract Addresses (JSON Array)</label>
                    <textarea id="contractAddresses" placeholder='["0x4200000000000000000000000000000000000006", "0x0000000000000000000000000000000000000000"]'>["0x4200000000000000000000000000000000000006", "0x0000000000000000000000000000000000000000"]</textarea>
                </div>
                
                <div class="button-group">
                    <button class="btn-secondary" onclick="restoreDefaultAddressesfromContract()">Get Defaults from Contract</button>
                    <button class="btn-secondary" onclick="restoreDefaultAddressesfromGithub()">Get Defaults from Github</button>
                    <button class="btn-secondary" onclick="restoreDefaultAddresses()">Restore Defaults </button>
                    <button class="btn-primary" onclick="saveAddresses()">Save Addresses</button>
                </div>
                <div id="addressSuccess" class="success-message">Contract addresses saved successfully!</div>
            </div>
            <div class="settings-form">
                <h3>🔒 Minimum Staking Configuration</h3>
                <p>Set the minimum amount of tokenA required for users Staked Position.  Used to prevent spam.  Units is Wei</p>
                
                <div class="form-group">
                    <label>Minimum Staking Amount</label>
                    <div class="input-group">
                        <input type="number" id="minStaking" placeholder="0" step="1" min="0">
                        <div class="unit">Tokens</div>
                    </div>
                </div>
                
                <button class="btn-primary" onclick="saveMinStaking()">Save Minimum Staking</button>
                <div id="stakingSuccess" class="success-message">Minimum staking amount saved successfully!</div>
            </div>

            <div class="settings-form">
                <h3>💰 Minimum User Holdings</h3>
                <p>Set the minimum tokenA required for user to see a NFT position held in wallet. To prevent spam attacks! Units is Wei</p>
                
                <div class="form-group">
                    <label>Minimum Holdings Required</label>
                    <div class="input-group">
                        <input type="number" id="minUserHoldings" placeholder="0" step="1" min="0">
                        <div class="unit">Tokens</div>
                    </div>
                </div>
                
                <button class="btn-primary" onclick="saveMinUserHoldings()">Save Minimum Holdings</button>
                <div id="holdingsSuccess" class="success-message">Minimum holdings amount saved successfully!</div>
            </div>

        </div>
            </div>

            <!-- Staking Management Page -->
            <div id="staking-management" class="page">
                <div class="info-card">
                    <h3>Staking Management</h3>
                    <p>Manage reward tokens and configure staking reward periods for the platform.</p>
                </div>

                <div class="staking-management">
                    <div class="management-card">
                        <h3>🪙 Add Reward Token</h3>
                        <p>Add new ERC20 tokens to be distributed as staking rewards.</p>
                        
                        <div class="form-group">
                            <label>Reward Token Contract Address</label>
                            <input type="text" id="rewardTokenAddress" class="address-input" 
                                   placeholder="0x742d35Cc6634C0532925a3b8D1C07E8DEa95C7C4" 
                                   pattern="^0x[a-fA-F0-9]{40}$">
                        </div>
                        
                        
                        <button class="btn-success" onclick="addRewardToken()">Add Reward Token</button>
                        
                        <div class="reward-tokens-list" id="rewardTokensList">
                            <h4>Current Reward Tokens:</h4>
                            <div id="rewardTokensContainer">
                                <p style="color: #6c757d; font-style: italic;">No reward tokens added yet.</p>
                            </div>
                        </div>
                    </div>

                    <div class="management-card">
                        <h3>🚀 Start Reward Period</h3>
                        <p>Configure and start a new reward distribution period for stakers.</p>
                        
                        <div class="form-group">
                            <label>Select Reward Token</label>
                            <select id="selectedRewardToken">
                                <option value="">Select a reward token...</option>
                            </select>
                        </div>
                        <button class="btn-primary" onclick="startRewardPeriod()">Start Reward Period</button>
                    </div><br></br>

                    <div class="management-card">
                        <h3>📊 Active Reward Periods</h3>
                        <p>Monitor and manage currently active reward distribution periods.</p>
                        
                        <div id="activePeriodsContainer">
                            <p style="color: #6c757d; font-style: italic;">No active reward periods.</p>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Swap Page -->
            <div id="swap" class="page active">


                <!-- Wallet Balances Display -->
                <div class="wallet-balances">
                    <h3>Wallet Balances</h3>
                    <div id="walletBalancesDisplay3" class="balances-grid">
                        <!-- Will be populated by JavaScript -->
                        <p style="color: #6c757d; font-style: italic;">Loading wallet balances...</p>
                    </div>
                </div>

                <div class="info-card">
                    <h3>Token Swap</h3>
                    <p>Exchange one token for another at current market rates with minimal slippage.</p>
                </div>
                
                <div class="form-group">
                    <label>From Token</label>
                    <div class="token-selector">
                        <div class="token-icon" id="fromTokenIcon">E</div>
                        <select id="fromToken" onchange="updateTokenIcon('fromToken', 'fromTokenIcon')">
                            <option value="B0x">B0x - B Zero X Token</option>
                            <option value="0xBTC">0xBTC - 0xBitcoin Token</option>
                        </select>
                    </div>
                </div>


                <div class="form-group">
                    <label>Amount</label>
                    <input type="number" placeholder="0.0" step="0.000001">
                </div>

                <div class="swap-direction">
                    <button class="swap-arrow" onclick="swapTokens()">⇅</button>
                </div>

                <div class="form-group">
                    <label>To Token</label>
                    <div class="token-selector">
                        <div class="token-icon" id="toTokenIcon">U</div>
                        <select id="toToken" onchange="updateTokenIcon('toToken', 'toTokenIcon')">
                            <option value="0xBTC">0xBTC - 0xBitcoin Token</option>
                            <option value="B0x">B0x - B Zero X Token</option>
                        </select>
                    </div>
                </div>

                <div class="form-group">
                    <label>Estimated Output</label>
                    <input type="text" value="0.0" readonly style="background: #f8f9fa;">
                </div>

                    <div class="form-group">
                        <label>Slippage Tolerance</label>
                        <select id="slippageTolerance"> 
                            <option>0.1%</option>
                            <option>0.5%</option>
                            <option>1.0%</option>
                            <option>2.0%</option>
                        </select>
                    </div>

                <button class="btn-primary" onclick="executeSwap()">Execute Swap</button>
            </div>

            <!-- Staking Page -->
            <div id="staking-main-page" class="page">
                <div class="info-card3">
                    <h2>Token Staking</h2>
                    <p>Stake your Unsiwap NFT tokens to earn rewards and support network security.</p>
                    </div>
                <div class="rewards-card">
                    <h3>Current Rewards</h3>
                    <div class="rewards-amount" id="rewardsAmount">0.01 ETH & 10 TokenA</div>
                    <div class="rewards-usd" id="rewardsUSD">≈ $1.90 USD</div>

                    <button class="btn-primary" onclick="collectRewards()">Collect Rewards</button>
                </div>
                <button onclick="calculateNewRewards()">Calculate New Rewards</button>
                <div class="staking-stats">
                    <div class="stat-card">
                        <div class="stat-value" id="totalStakedT1">1.0120213 ETH </div>
                        <div class="stat-value" id ="totalStakedT2">15,000 TokenA</div>
                        <div class="stat-label">Your Total Staked</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="APYPercentage">8.75%</div>
                        <div class="stat-label">Current APY</div>
                    </div>
                </div>
                <div class="info-card3">
                    <h2>Token Staking</h2>
                    <p>Stake your Unsiwap NFT tokens to earn rewards and support network security.</p>
                    </div>

                <div class="info-card2">
                    <h3>NFT Position Info</h3>
                    <p>Select NFT to get info</p>
                </div>
                <div class="form-group">
                    <label>Select Position</label>
                        <select>
                            <option>STAKE - Staking Token</option>
                            <option>DAI - Dai Stablecoin</option>
                        </select>
                </div>

                <div class="form-group">
                    <label>Estimated Rewards (30 days)</label>
                    <input type="text" id="estimatedRewards" value="9.06 STAKE" readonly style="background: #f8f9fa;">
                </div>

                    <button class="btn-success" onclick="depositStake()">Deposit NFT</button><br></br><br></br>

                <div class="info-card3">
                    <h2>Token Withdrawing</h2>
                    <p>Unstake your Unsiwap NFT tokens below.</p>
                </div>

                       <div class="info-card">
                    <h3>Token Withdrawing</h3>
                    <p>Unstake your Unsiwap NFT tokens below.</p>
                </div>
              <br></br>
                <div class="form-group2">
                    <label>Select NFT to Withdraw</label>
                        <select>
                            <option>UNSTAKE - UNStaking Token</option>
                            <option>UNDAI - UNDai Stablecoin</option>
                        </select>
                </div>
                    <button class="btn-warning" onclick="withdrawStake()">Withdraw</button>


            </div>

            <!-- Create Position Page -->
            <div id="create" class="page">
                <div class="info-card">
                    <h3>Create Liquidity Position</h3>
                    <p>Provide liquidity to earn fees by depositing token pairs into liquidity pools.</p>
                </div>

                <!-- Wallet Balances Display -->
                <div class="wallet-balances">
                    <h3>Wallet Balances</h3>
                    <div id="walletBalancesDisplay4" class="balances-grid">
                        <!-- Will be populated by JavaScript -->
                        <p style="color: #6c757d; font-style: italic;">Loading wallet balances...</p>
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label>Token A</label>
                        <div class="token-selector">

                    <div class="token-icon" id="tokenAIcon">U</div>
                            <select id="tokenA">
                                <option value="0xBTC">0xBTC - 0xBitcoin Token</option>
                                <option value="B0x">B0x - B Zero X Token</option>
                            </select>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Token B</label>
                        <div class="token-selector">
                        <div class="token-icon" id="tokenBIcon">U</div>
                            <select id="tokenB">
                                <option value="0xBTC">0xBTC - 0xBitcoin Token</option>
                                <option value="B0x">B0x - B Zero X Token</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label>Amount A</label>
                        <input type="number" id="amountA" placeholder="0.0" step="0.000001" value="0">          </div>
                    <div class="form-group">
                        <label>Amount B</label>
                        <input type="number" id="amountB" placeholder="0.0" step="0.000001" value="0">        </div>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label>Fee Tier</label>
                        <select>
                            <option>Dynamic Fee - Required For Staking</option>
                           <!-- <option>0.30% - Standard</option>
                            <option>1.00% - Exotic pairs</option>-->
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Price Range</label>
                        <select>
                            <option>Full Range - Required For Staking</option>
                            <!---
                            <option>Narrow (±10%)</option>
                            <option>Wide (±50%)</option>
                            <option>Custom</option>
                            -->
                        </select>
                    </div>

                    <div class="form-group">
                        <label>Hook Address</label>
                        <select>
                            <option>Use Dynamic Fee Hook - Required For Staking</option>
                            <!---
                            <option>Narrow (±10%)</option>
                            <option>Wide (±50%)</option>
                            <option>Custom</option>
                            -->
                        </select>
                    </div>
                </div>

                <div class="form-group">
                    <label>Estimated Pool Share</label>
                    <input type="text" value="0.00%" readonly style="background: #f8f9fa;">
                </div>

                <button class="btn-primary" onclick="getCreatePosition()">Create Position</button>
                <button class="btn-primary" onclick="getRatioCreatePositiontokenA()">getRatioCreatePositiontokenA Position</button>
                <button class="btn-primary" onclick="getRatioCreatePositiontokenB()">getRatioCreatePositiontokenB Position</button>
                <button class="btn-primary" onclick="getMaxCreatePosition()">getMaxCreatePosition Button</button>
                
            </div>


            <!-- Increase Liquidity Page -->
            <div id="increase" class="page">
                <div class="info-card">
                    <h3>Increase Liquidity</h3>
                    <p>Add more funds to your existing liquidity position to earn more fees.</p>
                </div>
                <!-- Wallet Balances Display -->
                <div class="wallet-balances">
                    <h3>Wallet Balances</h3>
                    <div id="walletBalancesDisplay" class="balances-grid">
                        <!-- Will be populated by JavaScript -->
                        <p style="color: #6c757d; font-style: italic;">Loading wallet balances...</p>
                    </div>
                </div>


                <div class="form-group">
                    <label>Select Position</label>
                    <select>
                        <!-- Options will be populated by JavaScript -->
                    </select>
                </div>

                <div class="info-card">
                    <h3>Current Selected Position</h3>
                    <p><strong>Pool:</strong> ETH/USDC (0.30%)</p>
                    <p><strong>Current Liquidity:</strong> $1,250.00</p>
                    <p><strong>Unclaimed Fees:</strong> $12.50</p>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label>Add Total ETH</label>
                        <input type="number" placeholder="0.0" step="0.000001">
                    </div>
                    <div class="form-group">
                        <label>Add Total USDC</label>
                        <input type="number" placeholder="0.0" step="0.000001">
                    </div>
                </div>
                <b>Adding Liquidity Automatically uses your unclaimed fees in the deposit.</b><br></br>

                <div class="form-group">
                    <label>New Total Liquidity</label>
                    <input type="text" value="$1,250.00" readonly style="background: #f8f9fa;">
                </div>

                <button class="btn-primary" onclick="increaseLiquidity()">Increase Liquidity</button>
                <button class="btn-primary" onclick="getTokenIDsOwnedByMetamask()">Get Metamask StakedTokensOwned</button>
                <button class="btn-primary" onclick="getTokenIDsOwnedByStaking()">Get Staking Contracted Owned NFTs</button>
            </div>


            <!-- Decrease Liquidity Page -->
            <div id="decrease" class="page">
                <div class="info-card">
                    <h3>Decrease Liquidity</h3>
                    <p>Remove funds from your liquidity position and claim accumulated fees.</p>
                </div>

                <div class="form-group">
                    <label>Select Position</label>
                    <select onchange="updatePositionInfo()">
                    </select>
                </div>

                <div class="info-card">
                    <h3>Position Details</h3>
                    <p><strong>Pool:</strong> ETH/USDC (0.30%)</p>
                    <p><strong>Total Liquidity:</strong> $1,250.00</p>
                    <p><strong>Unclaimed Fees:</strong> $12.50</p>
                    <p><strong>Position Age:</strong> 15 days</p>
                </div>

                <div class="form-group">
                    <label>Removal Percentage</label>
                    <div class="slider-container">
                        <input type="range" min="0" max="100" value="25" class="slider" onchange="updatePercentage(this.value)">
                        <div class="percentage-display" id="percentageDisplay">25%</div>
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label>ETH to Receive</label>
                        <input type="text" value="0.156 ETH" readonly style="background: #f8f9fa;">
                    </div>
                    <div class="form-group">
                        <label>USDC to Receive</label>
                        <input type="text" value="312.50 USDC" readonly style="background: #f8f9fa;">
                    </div>
                </div>
<b>Remving Liquidity Automatically claims your unclaimed fees.</b><br></br>

                <div class="form-group">
                    <label>Fees to Claim</label>
                    <input type="text" value="$12.50" readonly style="background: #f8f9fa;">
                </div>

                <button class="btn-primary" onclick="decreaseLiquidity()">Remove Liquidity & Claim Fees</button>
            </div>

            <!-- Staking Increase Liquidity Page -->
             <!-- Staking Increase Liquidity Page -->
            <div id="stake-increase" class="page">
                <div class="info-card">
                    <h3>Increase Staking Liquidity</h3>
                    <p>Add more funds to your existing staking position to earn more rewards.</p>
                </div>

                <!-- Wallet Balances Display -->
                <div class="wallet-balances">
                    <h3>Wallet Balances</h3>
                    <div id="walletBalancesDisplay2" class="balances-grid">
                        <!-- Will be populated by JavaScript -->
                        <p style="color: #6c757d; font-style: italic;">Loading wallet balances...</p>
                    </div>
                </div>
                <div class="form-group">
                    <label>Select Position</label>
                    <select>
                        <!-- Options will be populated by JavaScript -->
                    </select>
                </div>

                <div class="info-card">
                    <h3>Current Selected Position</h3>
                    <p><strong>Pool:</strong> ETH/USDC (0.30%)</p>
                    <p><strong>Current Liquidity:</strong> $1,250.00</p>
                  <!--  <p><strong>Unclaimed Rewards:</strong> $12.50</p>--> 
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label>Add ETH</label>
                        <input type="number" placeholder="0.0" step="0.000001">
                    </div>
                    <div class="form-group">
                        <label>Add USDC</label>
                        <input type="number" placeholder="0.0" step="0.000001">
                    </div>
                </div>


                <div class="form-group">
                    <label>New Total Liquidity</label>
                    <input type="text" value="$1,250.00" readonly style="background: #f8f9fa;">
                </div>

                <button class="btn-primary" onclick="increaseStaking()">Increase Staking Position</button>
            </div>

            <!-- Staking Decrease Liquidity Page -->
            <div id="stake-decrease" class="page">
                <div class="info-card">
                    <h3>Decrease Staking Liquidity</h3>
                    <p>Remove funds from your staking position and claim accumulated rewards.</p>
                </div>

                <div class="form-group">
                    <label>Select Position</label>
                    <select>
                        <!-- Options will be populated by JavaScript -->
                    </select>
                </div>

                <div class="info-card">
                    <h3>Position Details</h3>
                    <p><strong>Pool:</strong> ETH/USDC (0.30%)</p>
                    <p><strong>Total Staked:</strong> $1,250.00</p>
                    <p><strong>Unclaimed Rewards:</strong> $12.50</p>
                    <p><strong>APY:</strong> 8.75%</p>
                </div>

                <div class="form-group">
                    <label>Removal Percentage</label>
                    <div class="slider-container">
                        <input type="range" min="0" max="100" value="25" class="slider">
                        <div class="percentage-display" id="stakePercentageDisplay">25%</div>
                    </div>
                </div>

                <div class="form-row">
                    <div class="form-group">
                        <label>ETH to Receive</label>
                        <input type="text" value="0.156 ETH" readonly style="background: #f8f9fa;">
                    </div>
                    <div class="form-group">
                        <label>USDC to Receive</label>
                        <input type="text" value="312.50 USDC" readonly style="background: #f8f9fa;">
                    </div>
                </div>


                    <button class="btn-primary" onclick="decreaseStaking()">Decrease Liquidity on Staked NFT</button>

            </div>
        </div>
    </div>

    <script>













/**
 * Fills in the Current Reward Tokens and Active Reward Periods sections
 */
    var mockRewardTokens = [
        { address: "0x742d35Cc6634C0532925a3b8D1C07E8DEa95C7C4", symbol: "REWARD" },
        { address: "0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984", symbol: "UNI" },
        { address: "0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9", symbol: "AAVE" }
    ];

    var mockActivePeriods = [
        { token: "REWARD", startTime: "2023-05-15", endTime: "2023-06-15", totalRewards: "10,000 REWARD" },
        { token: "UNI", startTime: "2023-05-20", endTime: "2023-07-20", totalRewards: "5,000 UNI" }
    ];

function populateStakingManagementData() {
    // Mock data - replace with actual data from your contract/API

    // Populate Reward Tokens
    const rewardTokensContainer = document.getElementById('rewardTokensContainer');
    const tokenSelect = document.getElementById('selectedRewardToken');
    
    if (mockRewardTokens.length === 0) {
        rewardTokensContainer.innerHTML = '<p style="color: #6c757d; font-style: italic;">No reward tokens added yet.</p>';
    } else {
        rewardTokensContainer.innerHTML = '<ul class="token-list">' + 
            mockRewardTokens.map(token => 
                `<li>
                    <span class="token-symbol">${token.symbol}</span>
                    <span class="token-address">${token.address}</span>
                </li>`
            ).join('') + '</ul>';
        
        // Also populate the select dropdown
        tokenSelect.innerHTML = '<option value="">Select a reward token...</option>' +
            mockRewardTokens.map(token => 
                `<option value="${token.address}">${token.symbol} (${token.address})</option>`
            ).join('');
    }

    // Populate Active Periods
    const activePeriodsContainer = document.getElementById('activePeriodsContainer');
    
    if (mockActivePeriods.length === 0) {
        activePeriodsContainer.innerHTML = '<p style="color: #6c757d; font-style: italic;">No active reward periods.</p>';
    } else {
        activePeriodsContainer.innerHTML = `
            <table class="periods-table">
                <thead>
                    <tr>
                        <th>Token</th>
                        <th>Start Date</th>
                        <th>End Date</th>
                        <th>Total Rewards</th>
                    </tr>
                </thead>
                <tbody>
                    ${mockActivePeriods.map(period => `
                        <tr>
                            <td>${period.token}</td>
                            <td>${period.startTime}</td>
                            <td>${period.endTime}</td>
                            <td>${period.totalRewards}</td>
                        </tr>
                    `).join('')}
                </tbody>
            </table>
        `;
    }
}


        let walletConnected = false;
        let userAddress = null;

        // Check if wallet was previously connected
        async function checkWalletConnection() {
        if (typeof window.ethereum !== 'undefined' && localStorage.getItem('walletConnected') === 'true') {
            try {
            const accounts = await window.ethereum.request({
                method: 'eth_accounts'
            });
            
            if (accounts.length > 0) {
                userAddress = accounts[0];
                walletConnected = true;
                updateWalletUI(userAddress, true);
            }
            } catch (error) {
            console.error('Error checking wallet connection:', error);
            }
        }
        }

        async function connectWallet() {
        if (walletConnected) {
            console.log('Wallet already connected');
            return userAddress;
        }

        if (typeof window.ethereum === 'undefined') {
            alert('Please install MetaMask or Rabby wallet!');
            return null;
        }

        try {
            const accounts = await window.ethereum.request({
            method: 'eth_requestAccounts'
            });

            if (accounts.length > 0) {
            userAddress = accounts[0];
            walletConnected = true;
            
            localStorage.setItem('walletConnected', 'true');
            localStorage.setItem('walletAddress', userAddress);
            
            updateWalletUI(userAddress, true);
            
            // Set up event listeners for account changes
            setupWalletListeners();
            fetchBalances();
            return userAddress;
            }
        } catch (error) {
            handleWalletError(error);
            return null;
        }
        }


        function handleWalletError(error) {
            console.error('Wallet connection error:', error);
            
            switch (error.code) {
                case 4001:
                alert('Please approve the connection request in your wallet');
                break;
                case -32002:
                alert('Connection request is already pending. Please check your wallet');
                break;
                default:
                alert('Failed to connect wallet: ' + error.message);
            }
        }

        function disconnectWallet() {
            walletConnected = false;
            userAddress = null;
            
            localStorage.removeItem('walletConnected');
            localStorage.removeItem('walletAddress');
            
            // Reset UI
            const connectBtn = document.getElementById('connectBtn');
            if (connectBtn) {
                connectBtn.textContent = 'Connect Wallet';
                connectBtn.classList.remove('connected');
            }
            updateWalletUI("",true);


        }

        function setupWalletListeners() {
        if (window.ethereum) {
            // Handle account changes
            window.ethereum.on('accountsChanged', (accounts) => {
            if (accounts.length === 0) {
                disconnectWallet();
            } else {
                userAddress = accounts[0];
                updateWalletUI(userAddress, true);
                fetchBalances();
            }
            });

            // Handle network changes
            window.ethereum.on('chainChanged', (chainId) => {
            console.log('Network changed to:', chainId);
            // Optionally reload the page or update UI
            });
        }
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
        checkWalletConnection();
        });

        function updateWalletUI(userAddress, walletName) {
            // Get the elements
            const connectBtn = document.getElementById('connectBtn');
            const walletInfo = document.getElementById('walletInfo');
            const walletAddressSpan = document.querySelector('#walletInfo #walletAddress');
            
            if (userAddress) {
                // Shorten the address for display (first 6 + last 4 characters)
                const shortAddress = `${userAddress.slice(0, 6)}...${userAddress.slice(-4)}`;
                
                // Update the span with the shortened address
                walletAddressSpan.textContent = shortAddress;
                
                // Show the wallet info div
                walletInfo.style.display = 'block';
                
                // Update connect button
                connectBtn.textContent = `Connected (${walletName || 'Wallet'})`;
                connectBtn.classList.add('connected');
                
                // Optional: Add title attribute for full address on hover
                walletAddressSpan.title = userAddress;
                
            } else {
                // Hide wallet info if no address
                walletInfo.style.display = 'none';
                connectBtn.textContent = 'Connect Wallet';
                connectBtn.classList.remove('connected');
            }
        }





        function updateTokenIcon(selectId, iconId) {
            const select = document.getElementById(selectId);
            const icon = document.getElementById(iconId);
            const selectedValue = select.value;
            
            // Map token symbols to their first letter
            const tokenIcons = {
                'ETH': 'E',
                'USDC': 'U',
                'DAI': 'D',
                'WBTC': 'W'
            };
            
            icon.textContent = tokenIcons[selectedValue] || selectedValue.charAt(0);
        }













































        function switchTab(tabName) {
            // Hide all pages
            const pages = document.querySelectorAll('.page');
            pages.forEach(page => page.classList.remove('active'));
            
            // Remove active class from all tabs
            const tabs = document.querySelectorAll('.nav-tab');
            tabs.forEach(tab => tab.classList.remove('active'));
            
            // Show selected page
            document.getElementById(tabName).classList.add('active');
            
            // Add active class to clicked tab
            event.target.classList.add('active');
        }







            function updateTokenIconCreate() {
                const formGroups = document.querySelectorAll('#create .form-group');
                
                formGroups.forEach(group => {
                    const label = group.querySelector('label');
                    const select = group.querySelector('select');
                    const icon = group.querySelector('.token-icon');
                    
                    if (label && select && icon) {
                        const labelText = label.textContent;
                        if (labelText === 'Token A' || labelText === 'Token B') {
                            const selectedValue = select.value;
                            
                            const tokenIcons = {
                                'ETH': 'E',
                                'USDC': 'U',
                                'DAI': 'D',
                                'WBTC': 'W'
                            };
                            
                            icon.textContent = tokenIcons[selectedValue] || selectedValue.charAt(0);
                        }
                    }
                });

                            filterTokenOptionsCreate();
            }

            // Add event listeners when page loads
            document.addEventListener('DOMContentLoaded', function() {
                const createSelects = document.querySelectorAll('#create .token-selector select');
                createSelects.forEach(select => {
                    select.addEventListener('change', updateTokenIconCreate);
                });
            });












// Position data structure
const positionData = {
    "position_1": {
        id: "position_1",
        pool: "ETH/USDC",
        feeTier: "0.30%",
        tokenA: "ETH",
        tokenB: "USDC",
        currentLiquidity: 1250.00,
        currentTokenA: 1.00,
        currentTokenB: 2000.00,
        unclaimedFeesTokenA: 12.50,
        unclaimedFeesTokenB: 12.50,
        tokenAIcon: "E",
        tokenBIcon: "U"
    },
    "position_2": {
        id: "position_2",
        pool: "DAI/USDC",
        feeTier: "0.05%",
        tokenA: "DAI",
        tokenB: "USDC",
        currentLiquidity: 850.00,
        currentTokenA: 2000.00,
        currentTokenB: 2000.00,
        unclaimedFeesTokenA: 12.50,
        unclaimedFeesTokenB: 12.50,
        tokenAIcon: "D",
        tokenBIcon: "U"
    },
    "position_3": {
        id: "position_3",
        pool: "WBTC/ETH",
        feeTier: "0.30%",
        tokenA: "WBTC",
        tokenB: "ETH",
        currentLiquidity: 2100.00,
        currentTokenA: 1.00,
        currentTokenB: 50.00,
        unclaimedFeesTokenA: 12.50,
        unclaimedFeesTokenB: 12.50,
        tokenAIcon: "W",
        tokenBIcon: "E"
    },
    "position_4": {
        id: "position_4",
        pool: "ETH/B0x",
        feeTier: "0.30%",
        tokenA: "ETH",
        tokenB: "B0x",
        currentLiquidity: 100.00,
        currentTokenA: 1.00,
        currentTokenB: 2000.00,
        unclaimedFeesTokenA: 0.12,
        unclaimedFeesTokenB: 212.50,
        tokenAIcon: "E",
        tokenBIcon: "B"
    }
};

// Staking position data structure
const stakingPositionData = {
    "stake_position_1": {
        id: "stake_position_1",
        pool: "ETH/USDC",
        feeTier: "0.30%",
        tokenA: "ETH",
        tokenB: "USDC",
        currentLiquidity: 1250.00,
        currentTokenA: 1.00,
        currentTokenB: 2000.00,
        unclaimedRewards: 12.50,
        apy: "8.75%",
        tokenAIcon: "E",
        tokenBIcon: "U"
    },
    "stake_position_2": {
        id: "stake_position_2",
        pool: "DAI/USDC",
        feeTier: "0.05%",
        tokenA: "DAI",
        tokenB: "USDC",
        currentLiquidity: 850.00,
        currentTokenA: 2000.00,
        currentTokenB: 2000.00,
        unclaimedRewards: 5.25,
        apy: "12.1%",
        tokenAIcon: "D",
        tokenBIcon: "U"
    },
    "stake_position_3": {
        id: "stake_position_3",
        pool: "WBTC/ETH",
        feeTier: "0.30%",
        tokenA: "WBTC",
        tokenB: "ETH",
        currentLiquidity: 2100.00,
        currentTokenA: 1.00,
        currentTokenB: 50.00,
        unclaimedRewards: 18.75,
        apy: "5.2%",
        tokenAIcon: "W",
        tokenBIcon: "E"
    },
    "stake_position_4": {
        id: "stake_position_3",
        pool: "ETH/B0x",
        feeTier: "0.30%",
        tokenA: "ETH",
        tokenB: "B0x",
        currentLiquidity: 100.00,
        currentTokenA: 1.00,
        currentTokenB: 2000.00,
        unclaimedRewards: 38.75,
        apy: "11.2%",
        tokenAIcon: "E",
        tokenBIcon: "B"
    }
};



function updatePositionInfoMAIN_STAKING() {
    const positionSelect = document.querySelector('#staking-main-page select');
    const selectedPositionId = positionSelect.value;
    const position = positionData[selectedPositionId];
    
    if (!position) return;
    
    
    

document.getElementById('estimatedRewards').value = "12.1231232150 STAKE";


    const infoCard = document.querySelector('#staking-main-page .info-card2');
    infoCard.innerHTML = `<h3>Current Selected Position</h3>
        <p><strong>Pool:</strong> ${position.pool} (${position.feeTier})</p>
        <p><strong>Current Liquidity:</strong> $${position.currentLiquidity.toFixed(2)}</p>
        <p><strong>Total Liquidity:</strong> ${position.currentTokenA.toFixed(4)} ${position.tokenA} & ${position.currentTokenB.toFixed(4)} ${position.tokenB}</p>

    `;
    


}



function updatePositionInfoMAIN_UNSTAKING() {
    console.log('staking-main-page:', document.querySelector('#staking-main-page'));
console.log('form-group2:', document.querySelector('#staking-main-page .form-group2'));
console.log('select:', document.querySelector('#staking-main-page .form-group2 select'));
    const positionSelect = document.querySelector('#staking-main-page .form-group2 select');
    const selectedPositionId = positionSelect.value;
    const position = stakingPositionData[selectedPositionId];
    if (!position) return;


    console.log("Success position: ",position);
    
    
    

document.getElementById('estimatedRewards').value = "12.1231232150 STAKE";


    const infoCard = document.querySelector('#staking-main-page .info-card');

    console.log('Found info-car12313213d2:', infoCard);
    
    infoCard.innerHTML = `<h3>Current Selected Position</h3>
        <p><strong>Pool:</strong> ${position.pool} (${position.feeTier})</p>
        <p><strong>Current Liquidity:</strong> $${position.currentLiquidity.toFixed(2)}</p>
         <p><strong>Total Liquidity:</strong> ${position.currentTokenA.toFixed(4)} ${position.tokenA} & ${position.currentTokenB.toFixed(4)} ${position.tokenB}</p>

        <p><strong>Position Age:</strong> ${position.positionAge}</p>
    `;
    


}

function updatePositionInfo() {
    const positionSelect = document.querySelector('#increase select');
    const selectedPositionId = positionSelect.value;
    const position = positionData[selectedPositionId];
    
    if (!position) return;
    
    // Update current position info card
    const infoCard = document.querySelector('#increase .info-card:nth-child(4)');
    infoCard.innerHTML = `
        <h3>Current Selected Position</h3>
        <p><strong>Pool:</strong> ${position.pool} (${position.feeTier})</p>
        <p><strong>Current Liquidity:</strong> $${position.currentLiquidity.toFixed(2)}</p>
        <p><strong>Total Liquidity:</strong> ${position.currentTokenA.toFixed(4)} ${position.tokenA} & ${position.currentTokenB.toFixed(4)} ${position.tokenB}</p>

        <p><strong>Unclaimed Fees:</strong> ${position.unclaimedFeesTokenA.toFixed(4)} ${position.tokenA} & ${position.unclaimedFeesTokenB.toFixed(4)} ${position.tokenB}</p>

    `;
    // Clear input values when position changes
    const inputs = document.querySelectorAll('#increase input[type="number"]');
    inputs.forEach(input => input.value = '');
    
}
function updateTotalLiqIncrease() {
    const positionSelect = document.querySelector('#increase select');
    const selectedPositionId = positionSelect.value;
    const position = positionData[selectedPositionId];
    if (!position) return;

    let inputTokenA = 0;
    let inputTokenB = 0;

    // Find the two input groups under #increase
    const formGroups = document.querySelectorAll('#increase .form-row .form-group');

    formGroups.forEach(group => {
        const label = group.querySelector('label');
        const input = group.querySelector('input');

        if (!label || !input) return;

        if (label) {
            if (label.textContent.startsWith('Add ')) {
                const isFirstToken = label === formGroups[0].querySelector('label');
                const tokenSymbol = isFirstToken ? position.tokenA : position.tokenB;
                label.textContent = `Add Total ${tokenSymbol}`;
            }
        }
        const labelText = label.textContent.trim().toUpperCase(); // Make case-insensitive

        if (labelText.includes(position.tokenA.toUpperCase())) {
            inputTokenA = parseFloat(input.value) || 0;
        } else if (labelText.includes(position.tokenB.toUpperCase())) {
            inputTokenB = parseFloat(input.value) || 0;
        }

        console.log(`${labelText}: ${input.value}`);
    });

    
    // Update new total liquidity field
    const totalLiquidityInput = document.querySelector('#increase input[readonly]');
    totalLiquidityInput.value = `${(position.currentTokenA+inputTokenA).toFixed(4)} ${position.tokenA} & ${(position.currentTokenB+inputTokenB).toFixed(4)} ${position.tokenB}`;

}

function updateTotalLiqIncreaseSTAKING(){

    const positionSelect = document.querySelector('#stake-increase select');
    const selectedPositionId = positionSelect.value;
    const position = stakingPositionData[selectedPositionId];
    console.log("Postion Staking Udpate Liq: ", position);
    if (!position) return;
    var x=0;
    var inputTokenA = 0;
    var inputTokenB = 0;
    // Update form labels and placeholders
    const formGroups = document.querySelectorAll('#stake-increase .form-row .form-group');
    formGroups.forEach(group => {
        const label = group.querySelector('label');
        const input = group.querySelector('input'); // Get the input element

        if (label) {
            if (label.textContent.startsWith('Add ')) {
                const isFirstToken = label === formGroups[0].querySelector('label');
                const tokenSymbol = isFirstToken ? position.tokenA : position.tokenB;
                label.textContent = `Add ${tokenSymbol}`;
            }
        }
        // Get the input value
        if (input) {
            const inputValue = input.value;
            console.log("input value is: ",inputValue);
            console.log(`${label?.textContent}: ${inputValue}`);
          if(x==0){
                inputTokenA = parseFloat(inputValue) || 0; // Convert to number
            } else {
                inputTokenB = parseFloat(inputValue) || 0; // Convert to number
            }
            // Or do something with the value
            // someFunction(inputValue);
        }
        x = x+1;
    });
    
    // Update new total liquidity field
    const totalLiquidityInput = document.querySelector('#stake-increase input[readonly]');
    totalLiquidityInput.value = `${(position.currentTokenA+inputTokenA).toFixed(4)} ${position.tokenA} & ${(position.currentTokenB+inputTokenB).toFixed(4)} ${position.tokenB}`;

}

function updateStakePositionInfo() {
    const positionSelect = document.querySelector('#stake-increase select');
    const selectedPositionId = positionSelect.value;
    const position = stakingPositionData[selectedPositionId];
    
    if (!position) return;
    
    // Update current position info card
    const infoCard = document.querySelector('#stake-increase .info-card:nth-child(4)');
    infoCard.innerHTML = `
        <h3>Current Selected Position</h3>
        <p><strong>Pool:</strong> ${position.pool} (${position.feeTier})</p>
        <p><strong>Current Liquidity:</strong> $${position.currentLiquidity.toFixed(2)}</p>
        <p><strong>Total Liquidity:</strong> ${position.currentTokenA.toFixed(4)} ${position.tokenA} & ${position.currentTokenB.toFixed(4)} ${position.tokenB}</p>

      <!--  <p><strong>Unclaimed Rewards:</strong> $${position.unclaimedRewards.toFixed(2)}</p> -->
        <p><strong>APY:</strong> ${position.apy}</p>
    `;
    
    // Update form labels and placeholders
    const formGroups = document.querySelectorAll('#stake-increase .form-row .form-group');
    formGroups.forEach(group => {
        const label = group.querySelector('label');
        if (label) {
            if (label.textContent.startsWith('Add ')) {
                const isFirstToken = label === formGroups[0].querySelector('label');
                const tokenSymbol = isFirstToken ? position.tokenA : position.tokenB;
                label.textContent = `Add ${tokenSymbol}`;
            }
        }
    });
    
    // Update new total liquidity field
    const totalLiquidityInput = document.querySelector('#stake-increase input[readonly]');
    totalLiquidityInput.value = `$${position.currentLiquidity.toFixed(2)}`;
    
    // Clear input values when position changes
    const inputs = document.querySelectorAll('#stake-increase input[type="number"]');
    inputs.forEach(input => input.value = '');
}



function updateDecreasePositionInfo() {
    const positionSelect = document.querySelector('#decrease select');
    const selectedPositionId = positionSelect.value;
    const position = positionData[selectedPositionId];
    
    if (!position) return;
    
    // Update position details info card
    const infoCard = document.querySelector('#decrease .info-card:nth-child(3)');
    infoCard.innerHTML = `
        <h3>Position Details</h3>
        <p><strong>Pool:</strong> ${position.pool} (${position.feeTier})</p>
        <p><strong>Total Liquidity:</strong> ${position.currentLiquidity.toFixed(2)}</p>
        <p><strong>Total Liquidity:</strong> ${position.currentTokenA.toFixed(4)} ${position.tokenA} & ${position.currentTokenB.toFixed(4)} ${position.tokenB}</p>
        <p><strong>Unclaimed Fees:</strong> ${position.unclaimedFeesTokenA.toFixed(4)} ${position.tokenA} & ${position.unclaimedFeesTokenB.toFixed(4)} ${position.tokenB}</p>
    `;
    
    // Update form labels for token amounts
    const formGroups = document.querySelectorAll('#decrease .form-row .form-group');
    formGroups.forEach((group, index) => {
        const label = group.querySelector('label');
        if (label && label.textContent.includes('to Receive')) {
            const tokenSymbol = index === 0 ? position.tokenA : position.tokenB;
            label.textContent = `${tokenSymbol} to Receive`;
        }
    });
    
    // Update fees to claim field
const feesInput = Array.from(document.querySelectorAll('#decrease .form-group'))
    .find(group => group.querySelector('label')?.textContent === 'Fees to Claim')
    ?.querySelector('input');    console.log("fees input: ", feesInput);
    if (feesInput) {       
        console.log("changing fee input!");
        feesInput.value = `${position.unclaimedFeesTokenA.toFixed(4)} ${position.tokenA} & ${position.unclaimedFeesTokenB.toFixed(4)} ${position.tokenB}`

        console.log("changing fee input! feeInput.value = ",feesInput.value  );
        //feesInput.value = `${position.unclaimedFees.toFixed(2)}`;
    }
    
    // Force recalculate amounts with current percentage
    const slider = document.querySelector('#decrease .slider');
    if (slider) {
        // Trigger the calculation manually
        const percentage = parseFloat(slider.value) / 100;
        const removeAmount = percentage;
        
        // Calculate token amounts (simplified - in reality would depend on current pool ratios)
        const tokenAAmount = position.currentTokenA * removeAmount;
        const tokenBAmount = position.currentTokenB * removeAmount;
        
        const tokenInputs = document.querySelectorAll('#decrease .form-row input');
        tokenInputs[0].value = `${(tokenAAmount).toFixed(6)} ${position.tokenA}`;
        tokenInputs[1].value = `${(tokenBAmount).toFixed(6)} ${position.tokenB}`;
        console.log("TokenAAmount: ", tokenAAmount);
        /* Update token receive inputs with correct formatting
        const tokenInputs = document.querySelectorAll('#decrease .form-row input');
        if (tokenInputs.length >= 2) {
            // Format TokenA based on token type
            if (position.tokenA === 'ETH' || position.tokenA === 'WBTC') {
                tokenInputs[0].value = `${(tokenAAmount / 2000).toFixed(6)} ${position.tokenA}`;
            } else {
                tokenInputs[0].value = `${tokenAAmount.toFixed(2)} ${position.tokenA}`;
            }
            
            // Format TokenB based on token type
            if (position.tokenB === 'ETH' || position.tokenB === 'WBTC') {
                tokenInputs[1].value = `${(tokenBAmount / 2000).toFixed(6)} ${position.tokenB}`;
            } else {
                tokenInputs[1].value = `${tokenBAmount.toFixed(2)} ${position.tokenB}`;
            }
        }
            */
    }
}


function updateStakeDecreasePositionInfo() {
    const positionSelect = document.querySelector('#stake-decrease select');
    const selectedPositionId = positionSelect.value;
    const position = stakingPositionData[selectedPositionId];
    
    if (!position) return;
    
    // Update position details info card
    const infoCard = document.querySelector('#stake-decrease .info-card:nth-child(3)');
    infoCard.innerHTML = `
        <h3>Position Details</h3>
        <p><strong>Pool:</strong> ${position.pool} (${position.feeTier})</p>
        <p><strong>Total Staked:</strong> $${position.currentLiquidity.toFixed(2)}</p>
        <p><strong>Total Liquidity:</strong> ${position.currentTokenA.toFixed(4)} ${position.tokenA} & ${position.currentTokenB.toFixed(4)} ${position.tokenB}</p>

        <p><strong>APY:</strong> ${position.apy}</p>
        <p><strong>Position Age:</strong> ${position.positionAge}</p>
    `;
    
    // Update form labels for token amounts
    const formGroups = document.querySelectorAll('#stake-decrease .form-row .form-group');
    formGroups.forEach((group, index) => {
        const label = group.querySelector('label');
        if (label && label.textContent.includes('to Receive')) {
            const tokenSymbol = index === 0 ? position.tokenA : position.tokenB;
            label.textContent = `${tokenSymbol} to Receive`;
        }
    });
    
    // Update rewards to claim field
    const rewardsInput = document.querySelector('#stake-decrease .form-group:last-child input');
    if (rewardsInput) {
        rewardsInput.value = `$${position.unclaimedRewards.toFixed(2)}`;
    }
    
    // Recalculate amounts with current percentage
    const slider = document.querySelector('#stake-decrease .slider');
    if (slider) {
        updateStakePercentage(slider.value);
    }
}




function updateStakePercentage(value) {
    const percentageDisplay = document.getElementById('stakePercentageDisplay');
    if (percentageDisplay) {
        percentageDisplay.textContent = value + '%';
    }
    
    // Get current position data
    const positionSelect = document.querySelector('#stake-decrease select');
    if (!positionSelect) return;
    
    const selectedPositionId = positionSelect.value;
    const position = stakingPositionData[selectedPositionId];
    
    if (!position) return;
        console.log("Value = ",value);
    const percentage = parseFloat(value) / 100;
    const removeAmount =  percentage;
    
    // Calculate token amounts (simplified - in reality would depend on current pool ratios)
        // Calculate token amounts (simplified - in reality would depend on current pool ratios)
        const tokenAAmount = position.currentTokenA * removeAmount;
        const tokenBAmount = position.currentTokenB * removeAmount;
    

        
    // Update token receive inputs
    const tokenInputs = document.querySelectorAll('#stake-decrease .form-row input');
    if (tokenInputs.length >= 2) {
      
        tokenInputs[0].value = `${(tokenAAmount).toFixed(6)} ${position.tokenA}`;
        tokenInputs[1].value = `${(tokenBAmount).toFixed(6)} ${position.tokenB}`;
    }
}
















function updatePercentage(value) {
    const percentageDisplay = document.getElementById('percentageDisplay');
    percentageDisplay.textContent = value + '%';
    
    // Get current position data
    const positionSelect = document.querySelector('#decrease select');
    const selectedPositionId = positionSelect.value;
    const position = positionData[selectedPositionId];
    
    if (!position) return;
    console.log("Value = ",value);
    const percentage = parseFloat(value) / 100;
    const removeAmount =  percentage;
    
    // Calculate token amounts (simplified - in reality would depend on current pool ratios)
        // Calculate token amounts (simplified - in reality would depend on current pool ratios)
        const tokenAAmount = position.currentTokenA * removeAmount;
        const tokenBAmount = position.currentTokenB * removeAmount;
    

        
    // Update token receive inputs
    const tokenInputs = document.querySelectorAll('#decrease .form-row input');
    if (tokenInputs.length >= 2) {
      
        tokenInputs[0].value = `${(tokenAAmount).toFixed(6)} ${position.tokenA}`;
        tokenInputs[1].value = `${(tokenBAmount).toFixed(6)} ${position.tokenB}`;
    }
}




function calculateNewTotal() {
    const positionSelect = document.querySelector('#increase select');
    const selectedPositionId = positionSelect.value;
    const position = positionData[selectedPositionId];
    
    console.log("position Data12: ", position);
    if (!position) return;
    console.log("work work");
    const increaseInput = document.querySelector('#increase input[placeholder="Enter USD value"]');
    const totalLiquidityInput = document.querySelector('#increase input[readonly]');
    
    const increaseAmount = parseFloat(increaseInput.value) || 0;
    const newTotal = position.currentLiquidity + increaseAmount;
    
    totalLiquidityInput.value = `$${newTotal.toFixed(2)}`;
}

function calculateNewStakeTotal() {
    const positionSelect = document.querySelector('#stake-increase select');
    const selectedPositionId = positionSelect.value;
    const position = stakingPositionData[selectedPositionId];
    
    if (!position) return;
    
    const increaseInput = document.querySelector('#stake-increase input[placeholder="Enter USD value"]');
    const totalLiquidityInput = document.querySelector('#stake-increase input[readonly]');
    
    const increaseAmount = parseFloat(increaseInput.value) || 0;
    const newTotal = position.currentLiquidity + increaseAmount;
    
    totalLiquidityInput.value = `$${newTotal.toFixed(2)}`;
}








        // Default addresses
        const defaultAddresses = '["0x4200000000000000000000000000000000000006", "0x0000000000000000000000000000000000000000"]';


       // Store current values in memory
        let currentSettingsAddresses = {
            contractAddresses: defaultAddresses
        };

        function saveAddresses() {
            const addresses = document.getElementById('contractAddresses').value;
            try {
                // Validate JSON format
                JSON.parse(addresses);
                currentSettingsAddresses.contractAddresses = addresses;
                showSuccessMessage('addressSuccess');
                console.log('Contract addresses saved:', addresses);

                // Save to localStorage
                localStorage.setItem('stakingRewardAddresses', JSON.stringify(currentSettingsAddresses.contractAddresses));
            } catch (error) {
                alert('Invalid JSON format. Please check your address format.');
            }
        }

        function restoreDefaultAddresses() {
            document.getElementById('contractAddresses').value = defaultAddresses;
            currentSettingsAddresses.contractAddresses = defaultAddresses;
            console.log('Addresses restored to defaults');

        }

        function restoreDefaultAddressesfromContract() {
            /*GET CONTRACT ERC20s to put into list*/
            document.getElementById('contractAddresses').value = defaultAddresses;
            currentSettingsAddresses.contractAddresses = defaultAddresses;
            console.log('Addresses restored to defaults');
        }
        function restoreDefaultAddressesfromGithub() {
            /*GET CONTRACT ERC20s to put into list*/
            document.getElementById('contractAddresses').value = defaultAddresses;
            currentSettingsAddresses.contractAddresses = defaultAddresses;
            console.log('Addresses restored to defaults');
        }

        function showSuccessMessage(elementId) {
            const element = document.getElementById(elementId);
            element.style.display = 'block';
            setTimeout(() => {
                element.style.display = 'none';
            }, 3000);
        }



// Initialize when page loads
document.addEventListener('DOMContentLoaded', function() {
    
    document.getElementById('contractAddresses').value = defaultAddresses;

    // Set up position selector for regular increase
    const positionSelect = document.querySelector('#increase select');
    if (positionSelect) {
        positionSelect.innerHTML = '';
        Object.values(positionData).forEach(position => {
            const option = document.createElement('option');
            option.value = position.id;
            option.textContent = `${position.pool} - ${position.feeTier} - Position #${position.id.split('_')[1]}`;
            positionSelect.appendChild(option);
        });
        
        positionSelect.addEventListener('change', updatePositionInfo);
        positionSelect.addEventListener('change', updateTotalLiqIncrease);
        updatePositionInfo();
    }
    // Add event listeners to both inputs in the form-row
    const ethInput = document.querySelector('#increase .form-row .form-group:first-child input');
    const usdcInput = document.querySelector('#increase .form-row .form-group:last-child input');
    

    if (ethInput) {
        ethInput.addEventListener('input', updateTotalLiqIncrease);
        updateTotalLiqIncrease();
    }
    
    if (usdcInput) {
        usdcInput.addEventListener('input', updateTotalLiqIncrease);
    }


    

    const positionSelect2 = document.querySelector('#staking-main-page select');
    if (positionSelect2) {
        positionSelect2.innerHTML = '';
        Object.values(positionData).forEach(position => {
            const option = document.createElement('option');
            option.value = position.id;
            option.textContent = `${position.pool} - ${position.feeTier} - Position #${position.id.split('_')[1]}`;
            positionSelect2.appendChild(option);
        });
        
        positionSelect2.addEventListener('change', updatePositionInfoMAIN_STAKING);
        updatePositionInfoMAIN_STAKING();
    }
    
    
const positionSelectMainPageWithdrawNFT = document.querySelector('#staking-main-page .form-group2 select');
    if (positionSelectMainPageWithdrawNFT) {
        positionSelectMainPageWithdrawNFT.innerHTML = '';
        Object.values(stakingPositionData).forEach(position => {
            const option = document.createElement('option');
            option.value = position.id;
            option.textContent = `${position.pool} - ${position.feeTier} - Stake Position #${position.id.split('_')[2]}`;
            positionSelectMainPageWithdrawNFT.appendChild(option);
        });
        
        positionSelectMainPageWithdrawNFT.addEventListener('change', updatePositionInfoMAIN_UNSTAKING);
        updatePositionInfoMAIN_UNSTAKING();
    }
    
    // Set up position selector for decrease
    const decreasePositionSelect = document.querySelector('#decrease select');
    if (decreasePositionSelect) {
        decreasePositionSelect.innerHTML = '';
        Object.values(positionData).forEach(position => {
            const option = document.createElement('option');
            option.value = position.id;
            option.textContent = `${position.pool} - ${position.feeTier} - Position #${position.id.split('_')[1]}`;
            decreasePositionSelect.appendChild(option);
        });
        
        decreasePositionSelect.addEventListener('change', updateDecreasePositionInfo);
        updateDecreasePositionInfo();
    }
    
    // Set up position selector for stake increase
    const stakePositionSelect = document.querySelector('#stake-increase select');
    if (stakePositionSelect) {
        stakePositionSelect.innerHTML = '';
        Object.values(stakingPositionData).forEach(position => {
            const option = document.createElement('option');
            option.value = position.id;
            option.textContent = `${position.pool} - ${position.feeTier} - Stake Position #${position.id.split('_')[2]}`;
            stakePositionSelect.appendChild(option);
        });
        
        stakePositionSelect.addEventListener('change', updateStakePositionInfo);
        updateStakePositionInfo();
    }
    
    // Set up position selector for stake decrease
    const stakeDecreasePositionSelect = document.querySelector('#stake-decrease select');
    if (stakeDecreasePositionSelect) {
        stakeDecreasePositionSelect.innerHTML = '';
        Object.values(stakingPositionData).forEach(position => {
            const option = document.createElement('option');
            option.value = position.id;
            option.textContent = `${position.pool} - ${position.feeTier} - Stake Position #${position.id.split('_')[2]}`;
            stakeDecreasePositionSelect.appendChild(option);
        });
        
        stakeDecreasePositionSelect.addEventListener('change', updateStakeDecreasePositionInfo);
        updateStakeDecreasePositionInfo();
    }
    
    // Add event listeners for calculations
    const increaseInput = document.querySelector('#increase input[placeholder="Enter USD value"]');
    console.log("Checking increaseInput: ", increaseInput);
    if (increaseInput) {
        increaseInput.addEventListener('input', calculateNewTotal);
    }
    
    const stakeIncreaseInput = document.querySelector('#stake-increase input[placeholder="Enter USD value"]');
    if (stakeIncreaseInput) {
        stakeIncreaseInput.addEventListener('input', calculateNewStakeTotal);
    }
    
    // Set up slider for decrease section with multiple event types
    const decreaseSlider = document.querySelector('#decrease .slider');
    if (decreaseSlider) {
        decreaseSlider.addEventListener('input', function() {
            updatePercentage(this.value);
        });
        decreaseSlider.addEventListener('change', function() {
            updatePercentage(this.value);
        });
        decreaseSlider.addEventListener('mouseup', function() {
            updatePercentage(this.value);
        });
    }
    
    // Set up slider for stake decrease section with multiple event types
    const stakeDecreaseSlider = document.querySelector('#stake-decrease .slider');
    if (stakeDecreaseSlider) {
        stakeDecreaseSlider.addEventListener('input', function() {
            updateStakePercentage(this.value);
        });
        stakeDecreaseSlider.addEventListener('change', function() {
            updateStakePercentage(this.value);
        });
        stakeDecreaseSlider.addEventListener('mouseup', function() {
            updateStakePercentage(this.value);
        });
    }



    // Add event listeners to both inputs in the form-row
    const ethInput2 = document.querySelector('#stake-increase .form-row .form-group:first-child input');
    const usdcInput2 = document.querySelector('#stake-increase .form-row .form-group:last-child input');
    
    console.log("Eth input2: ", ethInput2);
    if (ethInput2) {
        ethInput2.addEventListener('input', updateTotalLiqIncreaseSTAKING);
        updateTotalLiqIncreaseSTAKING();
    }
    
    if (usdcInput2) {
        usdcInput2.addEventListener('input', updateTotalLiqIncreaseSTAKING);
    }


    populateStakingManagementData();

    displayWalletBalances();
  loadSettings();
  filterTokenOptionsCreate();


// Target the create section
const createSection = document.getElementById('create');
if (createSection) {
    // Get both number inputs in the create section
    const numberInputs = createSection.querySelectorAll('input[type="number"]');
    const amountAInput = numberInputs[0]; // First input (Amount A)
    const amountBInput = numberInputs[1]; // Second input (Amount B)
    
    let isUpdating = false;
    let debounceTimerA;
    let debounceTimerB;
    
    if (amountAInput) {
        amountAInput.addEventListener('input', function() {
            if (isUpdating) return; // Prevent circular updates
            
            console.log('Create section - Amount A typing:', this.value);
            
            // Clear previous timer
            clearTimeout(debounceTimerA);
            
            // Set new timer - only call function after user stops typing for 300ms
            debounceTimerA = setTimeout(() => {
                console.log('Create section - Amount A final value:', this.value);
                isUpdating = true;
                
                if (typeof getRatioCreatePositiontokenA === 'function') {
                    getRatioCreatePositiontokenA();
                } else {
                    console.log('getRatioCreatePositiontokenA function called from create section');
                }
                
                // Reset the updating flag after processing
                setTimeout(() => {
                    isUpdating = false;
                }, 50);
            }, 300); // Wait 300ms after user stops typing
        });
    }
    
    // Similar for the other input
    if (amountBInput) {
        amountBInput.addEventListener('input', function() {
            if (isUpdating) return; // Prevent circular updates
            
            console.log('Create section - Amount B typing:', this.value);
            
            // Clear previous timer
            clearTimeout(debounceTimerB);
            
            // Set new timer - only call function after user stops typing for 300ms
            debounceTimerB = setTimeout(() => {
                console.log('Create section - Amount B final value:', this.value);
                isUpdating = true;
                
                if (typeof getRatioCreatePositiontokenB === 'function') {
                    getRatioCreatePositiontokenB();
                } else {
                    console.log('getRatioCreatePositiontokenB function called from create section');
                }
                
                // Reset the updating flag after processing
                setTimeout(() => {
                    isUpdating = false;
                }, 50);
            }, 300); // Wait 300ms after user stops typing
        });
    }
}






















});



// Helper function to format numbers without rounding
function formatExactNumber(value) {
    // If it's already a string, return as-is
    if (typeof value === 'string') {
        return value;
    }
    
    // If it's a BigInt, convert to string
    if (typeof value === 'bigint') {
        return value.toString();
    }
    
    // If it's a number, use toFixed(0) for integers or check if it needs decimal places
    if (typeof value === 'number') {
        // Check if it's a whole number
        if (Number.isInteger(value)) {
            return value.toFixed(0);
        }
        // For decimals, you might want to preserve more precision
        return value.toString();
    }
    
    return value.toString();
}

// Optional: Format with commas for better readability
function formatExactNumberWithCommas(value) {
    const exactValue = formatExactNumber(value);
    // Add commas to make large numbers more readable (10,999,900)
    return exactValue.replace(/\B(?=(\d{3})+(?!\d))/g, ',');
}

// Solution 1: Define a fixed token order (RECOMMENDED)
const TOKEN_ORDER = ['ETH', 'B0x', '0xBTC', 'USDC', 'DAI', 'WBTC'];

// Updated function with consistent ordering
function displayWalletBalances() {
    const balancesContainer = document.getElementById('walletBalancesDisplay');
    const balancesContainer2 = document.getElementById('walletBalancesDisplay2');
    const balancesContainer3 = document.getElementById('walletBalancesDisplay3');
    const balancesContainer4 = document.getElementById('walletBalancesDisplay4');
    
    if (!balancesContainer) return;
    
    // Create HTML with consistent token order
    let balancesHTML = '';
    
    // Method 1: Use predefined order
    TOKEN_ORDER.forEach(token => {
        if (walletBalances[token] !== undefined) {
            balancesHTML += `
                <div class="balance-item">
                    <span class="token-name">${token}</span>
                    <span class="token-amount">${formatExactNumber(walletBalances[token])}</span>
                </div>
            `;
        }
    });
    
    // Add any tokens not in the predefined order (in case you add new tokens)
    for (const [token, balance] of Object.entries(walletBalances)) {
        if (!TOKEN_ORDER.includes(token)) {
            balancesHTML += `
                <div class="balance-item">
                    <span class="token-name">${token}</span>
                    <span class="token-amount">${formatExactNumber(balance)}</span>
                </div>
            `;
        }
    }
    
    // Update all containers
    balancesContainer.innerHTML = balancesHTML;
    if (balancesContainer2) balancesContainer2.innerHTML = balancesHTML;
    if (balancesContainer3) balancesContainer3.innerHTML = balancesHTML;
    if (balancesContainer4) balancesContainer4.innerHTML = balancesHTML;
}


// Settings object to hold our values
const appSettings = {
  minStaking: 0,
  minUserHoldings: 0
};


/**
 * Saves the minimum staking amount to localStorage
 */
function saveMinStaking() {
  const minStakingInput = document.getElementById('minStaking');
  const value = minStakingInput.value.trim();
  
  if (!value || isNaN(value) || parseFloat(value) < 0) {
    showAlert('Please enter a valid positive number', 'error');
    return;
  }
  
  // Save to our settings object
  appSettings.minStaking = value;
  
  // Save to localStorage
  localStorage.setItem('stakingSettings', JSON.stringify(appSettings));
  
  showAlert(`Minimum staking amount set to ${value} tokens`, 'success');
}

/**
 * Saves the minimum user holdings to localStorage
 */
function saveMinUserHoldings() {
  const minHoldingsInput = document.getElementById('minUserHoldings');
  const value = minHoldingsInput.value.trim();
  
  if (!value || isNaN(value) || parseFloat(value) < 0) {
    showAlert('Please enter a valid positive number', 'error');
    return;
  }
  
  // Save to our settings object
  appSettings.minUserHoldings = value;
  
  // Save to localStorage
  localStorage.setItem('stakingSettings', JSON.stringify(appSettings));
  
  showAlert(`Minimum user holdings set to ${value} tokens`, 'success');
}

/**
 * Loads settings from localStorage and updates the form
 */
function loadSettings() {
  const savedSettings = localStorage.getItem('stakingSettings');
  const savedSettingsRewards = localStorage.getItem('stakingRewardAddresses');
  if(savedSettingsRewards){


      const setting2 = JSON.parse(savedSettingsRewards);
        console.log("setting2: ",setting2);
      // Update our appSettings object
      currentSettingsAddresses.contractAddresses = setting2 || "0xError";

            document.getElementById('contractAddresses').value = currentSettingsAddresses.contractAddresses;
  }
  if (savedSettings) {
    try {
      const settings = JSON.parse(savedSettings);
      
      // Update our appSettings object
      appSettings.minStaking = settings.minStaking || 0;
      appSettings.minUserHoldings = settings.minUserHoldings || 0;
      
      // Update the form inputs
      document.getElementById('minStaking').value = appSettings.minStaking;
      document.getElementById('minUserHoldings').value = appSettings.minUserHoldings;
      
    } catch (e) {
      console.error('Error loading settings:', e);
    }
  }
}

/**
 * Simple alert notification
 */
function showAlert(message, type = 'info') {
  const alertDiv = document.createElement('div');
  alertDiv.className = `alert alert-${type}`;
  alertDiv.textContent = message;
  
  const settingsPage = document.getElementById('settings');
  settingsPage.insertBefore(alertDiv, settingsPage.firstChild);
  
  setTimeout(() => alertDiv.remove(), 5000);
}

















            function increaseLiquidity() {
                const positionSelect = document.querySelector('#increase select');
                const selectedPositionId = positionSelect.value;
                const position = positionData[selectedPositionId];
                
                const increaseAmount = parseFloat(document.querySelector('#increase input[placeholder="Enter USD value"]').value) || 0;
                
                if (increaseAmount <= 0) {
                    alert('Please enter a valid increase amount');
                    return;
                }
                
                // Here you would typically send this data to your backend
                console.log('Increasing liquidity for:', {
                    positionId: selectedPositionId,
                    pool: position.pool,
                    increaseAmount: increaseAmount,
                    newTotal: position.currentLiquidity + increaseAmount
                });
                
                alert(`Liquidity increased by $${increaseAmount.toFixed(2)} for ${position.pool} position`);
            }










// Mock wallet balances - replace with real data from your wallet
var walletBalances = {
    'ETH': 2.5,
    'USDC': 1500.75,
    'DAI': 890.25,
    'WBTC': 0.15,
    '0xBTC': 13.99997,
    'B0x': 5.0000
};














//USE CONTRACT LAUNCH PARAMETERS HERE!//



























const contractAddress_PositionFinderPro = '0x95a19A533eC3824C44E05c6375A090509F1e9e5A'; // Replace with actual contract address
const contractAddress_Swapper = '0x9f44d0b53De0f543682a3810B203d9e607D66d98'; // Replace with actual contract address
const contractAddressLPRewardsStaking = '0x170355fb5A88eFF99E2D57b6D3DCebBdc66Ae669';
const hookAddress = '0xaA1360536838222013413624178F70f5f44c9000';

// Token addresses mapping
const tokenAddresses = {
'ETH': '0x0000000000000000000000000000000000000000', // Example addresses
'USDC': '0xA0b86a33E6441E680B0c8E84dc9aD2cb93Bb1eb4', // Example addresses
'DAI': '0x6B175474E89094C44Da98b954EedeAC495271d0F',
'WBTC': '0x2260FAC5E5542a773Aa44fBCfEdeC0F85eEaf9e5',
'B0x': '0x4b659F188c19e5CB318DA9ffB7dB30132A21389f',
'0xBTC': '0x43e8540C1242f39BC3F28d9CC5090663f21D523C'
};



















        // Token addresses mapping
        const tokenAddressesDecimals = {
            'USDC': '6', // Example addresses
            'ETH': '18', // Example addresses
            'DAI': '18',
            'WBTC': '8',
            'B0x': '18',
            '0xBTC': '8'
        };
        const addressToSymbol = {};
        Object.keys(tokenAddresses).forEach(symbol => {
            const address = tokenAddresses[symbol].toLowerCase(); // Store in lowercase for easier matching
            addressToSymbol[address] = symbol;
        });

        // Function to get symbol from address using reverse mapping
        function getSymbolFromAddress(address) {
            if (!address) return null;
            
            const normalizedAddress = address.toLowerCase();
            return addressToSymbol[normalizedAddress] || null;
        }







        // Declare global variables that should be defined elsewhere in your application
        let tokenSwapper = contractAddress_Swapper;
        let tokenAddress= tokenAddresses["B0x"];
        let Address_ZEROXBTC_TESTNETCONTRACT = tokenAddresses["0xBTC"];

        let HookAddress = hookAddress;
        let MinamountOut; // Declare this variable globally

        async function getSwapOfTwoTokens() {
            if(!walletConnected){
               await connectWallet();
            }

    var selectSlippage = document.getElementById('slippageTolerance');
    var selectSlippageValue = selectSlippage.value; // Returns: "0.1", "0.5", "1.0", or "2.0"
 const numberValueSlippage = parseFloat(selectSlippageValue.replace('%', ''));
    // Divide by 100 to get decimal
    const decimalValueSlippage= numberValueSlippage / 100;
    console.log("selectSlippageValue: ",selectSlippageValue);
    console.log("decimalValueSlippage: ",decimalValueSlippage);

const fromSelect = document.querySelector('#swap .form-group:nth-child(3) select');


// Get the currently selected value
const selectedValue = fromSelect.value;
console.log("Currently selected value:", selectedValue);

// Or get the selected option element itself
const selectedOption = fromSelect.options[fromSelect.selectedIndex];
console.log("Selected option text:", selectedOption.text);
console.log("Selected option value:", selectedOption.value);


const toSelect = document.querySelector('#swap .form-group:nth-child(6) select');


// Get the currently selected value
const toSelectValue = toSelect.value;
console.log("Currently selected value:", toSelectValue);



            var tokenInputAddress = tokenAddresses[selectedValue];
console.log("tokenInputAddresstokenInputAddresstokenInputAddresstokenInputAddress", tokenInputAddress);
            const amountInput = document.querySelector('#swap .form-group:nth-child(4) input');
// Get the currently selected value
const selectedValue2 = amountInput.value;
console.log("Currently amountInput value:", selectedValue2);
            var amountToSwap = ethers.utils.parseUnits(selectedValue2, 18);  // Correctly represents 12 * 10^8
            
            if(selectedValue=="0xBTC"){
                    console.log("LOGGED 0xBTC selected Value");
             amountToSwap = ethers.utils.parseUnits(selectedValue2, 8);  // Correctly represents 12 * 10^8
            }
            let amountOut = 0;
const tokenSwapperABI = [
    // Your existing getOutput function
    {
        "inputs": [
            {"name": "tokenZeroxBTC", "type": "address"},
            {"name": "tokenBZeroX", "type": "address"}, 
            {"name": "tokenIn", "type": "address"},
            {"name": "hookAddress", "type": "address"},
            {"name": "amountIn", "type": "uint128"}
        ],
        "name": "getOutput",
        "outputs": [{"name": "amountOut", "type": "uint256"}],
        "stateMutability": "view",
        "type": "function"
    },
    // Add the swapTokenTWOTOKENS function
    {
        "inputs": [
            {"name": "tokenA", "type": "address"},
            {"name": "tokenB", "type": "address"},
            {"name": "tokenIn", "type": "address"},
            {"name": "tokenOut", "type": "address"},
            {"name": "amountIn", "type": "uint256"},
            {"name": "minAmountOut", "type": "uint256"},
            {"name": "hookAddress", "type": "address"},
            {"name": "WhereToSendFunds", "type": "address"}
        ],
        "name": "swapTokenTWOTOKENS",
        "outputs": [{"name": "", "type": "bool"}],
        "stateMutability": "nonpayable", // This will modify state
        "type": "function"
    }
];

    console.log("Amount to swap: ", amountToSwap.toString());
        await ethereum.request({ method: 'eth_requestAccounts' });
        const provider = new ethers.providers.Web3Provider(window.ethereum);
        const signer = provider.getSigner();

                tokenSwapperContract = new ethers.Contract(
                    contractAddress_Swapper, // your tokenSwapper contract address
                    tokenSwapperABI,
                    signer // Use signer since the function isn't view/pure
                );

            try {
                // Call the view function
                const result = await tokenSwapperContract.callStatic.getOutput(
                    Address_ZEROXBTC_TESTNETCONTRACT, 
                    tokenAddress, 
                    tokenInputAddress, 
                    HookAddress, 
                    amountToSwap
                );

                // First debug what we're getting back
                console.log("Raw result type:", typeof result);
                console.log("Raw result structure:", Object.keys(result).join(", "));
                
                if (typeof result === 'bigint' || typeof result === 'number') {
                    // If it's already a primitive value
                    amountOut = result;
                } else if (result._isBigNumber || result instanceof ethers.BigNumber) {
                    // For ethers v5 BigNumber
                    amountOut = result;
                } else if (typeof result === 'object' && result !== null) {
                    // For objects, try to extract the value
                    // With ethers v6, we might get the value directly
                    if (typeof result.toString === 'function' && result.toString().match(/^[0-9]+$/)) {
                        amountOut = result;
                    } else {
                        // Attempt to extract value based on common patterns
                        amountOut = result[0] || result.amountOut || result._hex || result.value || result;
                    }
                }
                
                console.log(`Found valid amountOut: ${amountOut.toString()}`);
                const formattedResult = ethers.utils.formatEther(result);
                // Format to display as a readable number
                let readableAmountOut2Output = ethers.utils.formatEther(amountOut);
                let readableAmountIN2Input = ethers.utils.formatUnits(amountToSwap, 8);

                if (tokenInputAddress == Address_ZEROXBTC_TESTNETCONTRACT) {
                    // Keep the current formatting
                } else {
                    readableAmountOut2Output = ethers.utils.formatUnits(amountOut, 8);
                    readableAmountIN2Input = ethers.utils.formatEther(amountToSwap);
                }

                // Fix the BigInt arithmetic issue
                if (typeof amountOut === 'bigint') {
                    MinamountOut = amountOut*((1-decimalValueSlippage)*1000n)/10000n; // Use 10n for BigInt
                } else {
                    MinamountOut = amountOut*((1-decimalValueSlippage)*1000)/10000;
                }
                
                    alert(`You will trade `+ readableAmountIN2Input+ ` `+selectedValue+ " for "+ readableAmountOut2Output+ " "+toSelectValue);
                

                console.log(`Predicted amountOut: ${amountToSwap} tokens for ${MinamountOut} tokens input`);
                console.log(`Predicted amountOut: ${readableAmountIN2Input} tokens for ${readableAmountOut2Output} tokens input`);
                
            } catch (error) {
                console.error(`Error finding valid getOutput for swap:`, error);
                return; // Exit early if there's an error
            }

            console.log("\n\n!!!!!!!!!!!!!!!!!!!SWAPTWO TOKENS STUFF INFO BELOW!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
            console.log("TokenAddress: ", tokenAddress);
            console.log("Address_ZEROXBTC_TESTNETCONTRACT: ", Address_ZEROXBTC_TESTNETCONTRACT);
            console.log("TokenIn: ", tokenAddress);
            console.log("TokenOut: ", Address_ZEROXBTC_TESTNETCONTRACT);
            console.log("AmountIn: ", amountToSwap);
            console.log("MinAmountOut: ", MinamountOut);
            console.log("HookAddress: ", HookAddress);
            console.log("WheretoSendFunds: ", userAddress);
            
                console.log(`Found valid amountOut: ${amountOut.toString()}`);
                console.log(`Found valid MinamountOut amountOut: ${MinamountOut.toString()}`);









            if(Address_ZEROXBTC_TESTNETCONTRACT == tokenInputAddress){





const amountToSwapBN = ethers.BigNumber.from(amountToSwap.toString());
const minAmountOutBN = ethers.BigNumber.from(MinamountOut.toString());
            console.log("amountToSwapBN: ", amountToSwapBN);
            console.log("minAmountOutBN: ", minAmountOutBN);
            console.log("tokenAddress: ", tokenAddress);
            console.log("Address_ZEROXBTC_TESTNETCONTRACT: ", Address_ZEROXBTC_TESTNETCONTRACT);
            console.log("HookAddress: ", HookAddress);
            console.log("userAddress: ", userAddress);
            console.log("minAmountOutBN: ", minAmountOutBN);
            try {
                // Call the swap function
                const tx = await tokenSwapperContract.swapTokenTWOTOKENS(
                    tokenAddress, 
                    Address_ZEROXBTC_TESTNETCONTRACT, 
                    Address_ZEROXBTC_TESTNETCONTRACT, 
                    tokenAddress, 
                    amountToSwapBN, 
                    minAmountOutBN, 
                    HookAddress, 
                    userAddress,{
                        gasLimit: 10000000
                    }
                );
                
                console.log("swapTokenTWOTOKENS transaction sent:", tx.hash);
                await tx.wait();
                console.log("Transaction confirmed!");
                alert("Successful Swap!")
                
            } catch (error) {
                console.error(`Error finding swapTokenTWOTOKENS stuff:`, error);
                alert("User rejected request for swap!")
            }




        }else{




const amountToSwapBN = ethers.BigNumber.from(amountToSwap.toString());
const minAmountOutBN = ethers.BigNumber.from(MinamountOut.toFixed(0).toString());
            try {
                // Call the swap function
                const tx = await tokenSwapperContract.swapTokenTWOTOKENS(
                    tokenAddress, 
                    Address_ZEROXBTC_TESTNETCONTRACT, 
                    tokenAddress, 
                    Address_ZEROXBTC_TESTNETCONTRACT, 
                    amountToSwapBN, 
                    minAmountOutBN, 
                    HookAddress, 
                    userAddress
                );
                
                console.log("swapTokenTWOTOKENS transaction sent:", tx.hash);
                await tx.wait();
                console.log("Transaction confirmed!");
                
            } catch (error) {
                console.error(`Error finding swapTokenTWOTOKENS stuff:`, error);
            }
        }





    }

    


 async function getEstimate() {



const fromSelect = document.querySelector('#swap .form-group:nth-child(3) select');


// Get the currently selected value
const selectedValue = fromSelect.value;
console.log("Currently selected value:", selectedValue);

// Or get the selected option element itself
const selectedOption = fromSelect.options[fromSelect.selectedIndex];
console.log("Selected option text:", selectedOption.text);
console.log("Selected option value:", selectedOption.value);


            var tokenInputAddress = tokenAddresses[selectedValue];
console.log("tokenInputAddresstokenInputAddresstokenInputAddresstokenInputAddress", tokenInputAddress);
            const amountInput = document.querySelector('#swap .form-group:nth-child(4) input');
// Get the currently selected value
const selectedValue2 = amountInput.value;
console.log("Currently amountInput value:", selectedValue2);
            var amountToSwap = ethers.utils.parseUnits(selectedValue2, 18);  // Correctly represents 12 * 10^8
            
            if(selectedValue=="0xBTC"){
                    console.log("LOGGED 0xBTC selected Value");
             amountToSwap = ethers.utils.parseUnits(selectedValue2, 8);  // Correctly represents 12 * 10^8
            }
            let amountOut = 0;
const tokenSwapperABI = [
    // Your existing getOutput function
    {
        "inputs": [
            {"name": "tokenZeroxBTC", "type": "address"},
            {"name": "tokenBZeroX", "type": "address"}, 
            {"name": "tokenIn", "type": "address"},
            {"name": "hookAddress", "type": "address"},
            {"name": "amountIn", "type": "uint128"}
        ],
        "name": "getOutput",
        "outputs": [{"name": "amountOut", "type": "uint256"}],
        "stateMutability": "view",
        "type": "function"
    },
    // Add the swapTokenTWOTOKENS function
    {
        "inputs": [
            {"name": "tokenA", "type": "address"},
            {"name": "tokenB", "type": "address"},
            {"name": "tokenIn", "type": "address"},
            {"name": "tokenOut", "type": "address"},
            {"name": "amountIn", "type": "uint256"},
            {"name": "minAmountOut", "type": "uint256"},
            {"name": "hookAddress", "type": "address"},
            {"name": "WhereToSendFunds", "type": "address"}
        ],
        "name": "swapTokenTWOTOKENS",
        "outputs": [{"name": "", "type": "bool"}],
        "stateMutability": "nonpayable", // This will modify state
        "type": "function"
    }
];

    console.log("Amount to swap: ", amountToSwap.toString());
        await ethereum.request({ method: 'eth_requestAccounts' });
        const provider = new ethers.providers.Web3Provider(window.ethereum);
        const signer = provider.getSigner();

                tokenSwapperContract = new ethers.Contract(
                    contractAddress_Swapper, // your tokenSwapper contract address
                    tokenSwapperABI,
                    signer // Use signer since the function isn't view/pure
                );
                

                /*
                console.log("EERRROR HERE");
                console.log("EERRROR Address_ZEROXBTC_TESTNETCONTRACT: ",Address_ZEROXBTC_TESTNETCONTRACT);
                console.log("EERRROR tokenAddress: ",tokenAddress);
                console.log("EERRROR tokenInputAddress: ",tokenInputAddress);
                console.log("EERRROR HookAddress: ",HookAddress);
                console.log("EERRROR amountToSwap: ",amountToSwap);
                console.log("EERRROR amountToSwap: ",amountToSwap);
                console.log("EERRROR contractAddress_Swapper: ",contractAddress_Swapper);
                */

                // Call the view function
                const result = await tokenSwapperContract.callStatic.getOutput(
                    Address_ZEROXBTC_TESTNETCONTRACT, 
                    tokenAddress, 
                    tokenInputAddress, 
                    HookAddress, 
                    amountToSwap
                );

                // First debug what we're getting back
                console.log("Raw result type:", typeof result);
                console.log("Raw result structure:", Object.keys(result).join(", "));
                
                if (typeof result === 'bigint' || typeof result === 'number') {
                    // If it's already a primitive value
                    amountOut = result;
                } else if (result._isBigNumber || result instanceof ethers.BigNumber) {
                    // For ethers v5 BigNumber
                    amountOut = result;
                } else if (typeof result === 'object' && result !== null) {
                    // For objects, try to extract the value
                    // With ethers v6, we might get the value directly
                    if (typeof result.toString === 'function' && result.toString().match(/^[0-9]+$/)) {
                        amountOut = result;
                    } else {
                        // Attempt to extract value based on common patterns
                        amountOut = result[0] || result.amountOut || result._hex || result.value || result;
                    }
                }
                
                console.log(`Found valid amountOut: ${amountOut.toString()}`);
                const formattedResult = ethers.utils.formatEther(result);
                // Format to display as a readable number
                let readableAmountOut2Output = ethers.utils.formatEther(amountOut);
                let readableAmountIN2Input = ethers.utils.formatUnits(amountToSwap, 8);

                if (tokenInputAddress == Address_ZEROXBTC_TESTNETCONTRACT) {
                    // Keep the current formatting
                } else {
                    readableAmountOut2Output = ethers.utils.formatUnits(amountOut, 8);
                    readableAmountIN2Input = ethers.utils.formatEther(amountToSwap);
                }

                // Fix the BigInt arithmetic issue
                if (typeof amountOut === 'bigint') {
                    MinamountOut = amountOut - 10n; // Use 10n for BigInt
                } else {
                    MinamountOut = amountOut - 10;
                }
                
                                // Update the estimated output display
                const estimatedOutputInput = document.querySelector('#swap .form-group:nth-child(7) input');

            
                // Fix 4: Using ethers.js formatUnits (if you're using ethers.js)
                if(selectedValue == "0xBTC"){
                    estimatedOutputInput.value = ethers.utils.formatUnits(amountOut, 18);
                } else {
                    estimatedOutputInput.value = ethers.utils.formatUnits(amountOut, 8);
                }
           }
    

const amountInput = document.querySelector('#swap .form-group:nth-child(4) input');

// Function to handle amount changes
function handleAmountChange() {
    const amount = parseFloat(this.value) || 0;
    console.log("Amount changed:", amount);
    
    // Only call getEstimate if amount > 0
    if (amount > 0) {
        getEstimate();
    }
}

// Listen for both input and change events
amountInput.addEventListener('input', handleAmountChange);
amountInput.addEventListener('change', handleAmountChange);



        function calculateNewRewards() {
            // This would calculate based on additional staking amount
            console.log('Calculating new rewards...');
            // Update the rewards amount
            rewardsAmount.textContent = '15.67 STAKE';
            rewardsUSD.textContent = '≈ $31.34 USD';
            APYPercentage.textContent = '99.99 %';
        }

        // Swap functions
       async function executeSwap() {

    try {
        // Check if wallet is connected
        if (!window.ethereum || !userAddress) {
            alert('Please connect your wallet first!');
            return;
        }

        // Get form values
        const fromToken = document.getElementById('fromToken').value;
        const toToken = document.getElementById('toToken').value;
        const amountInput = document.querySelector('#swap input[type="number"]');
        const amount = amountInput.value;

        // Validation
        if (!amount || parseFloat(amount) <= 0) {
            alert('Please enter a valid amount to swap');
            return;
        }

        if (fromToken === toToken) {
            alert('Cannot swap the same token');
            return;
        }

        // Only support swapping TO ETH for now (based on your contract function)
     
        await getSwapOfTwoTokens();
        alert('Swap completed successfully!');
        
        // Refresh balances
        if (typeof fetchBalances === 'function') {
            fetchBalances();
        }

        // Clear the input
        amountInput.value = '';

    } catch (error) {
        console.error('Swap failed:', error);
        
        // Handle specific error types
        if (error.code === 4001) {
            alert('Transaction cancelled by user');
        } else if (error.code === -32603) {
            alert('Transaction failed. Please check your balance and try again.');
        } else {
            alert('Swap failed: ' + (error.message || error.reason || 'Unknown error'));
        }
    }
}




        



        async function getFacuetTokens(){

                // Check if wallet is connected
                if (!window.ethereum || !userAddress) {
                    alert('Please connect your wallet first!');
                    return;
                }

                const faucetABI_0xBTC = [
            // Your existing getOutput function
            {
                "inputs": [],
                "name": "getFacuetTokens_Testnet_0xBTC",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            }
            
        ];

                const faucetABI_MainToken = [
            // Your existing getOutput function
        {
                "inputs": [],
                "name": "getFacuetTokens_Testnet",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            }

            
        ];



                await ethereum.request({ method: 'eth_requestAccounts' });
                const provider = new ethers.providers.Web3Provider(window.ethereum);
                const signer = provider.getSigner();

                        Address_ZEROXBTC_TESTNETCONTRACT_CONTRACT = new ethers.Contract(
                            Address_ZEROXBTC_TESTNETCONTRACT, // your tokenSwapper contract address
                            faucetABI_0xBTC,
                            signer // Use signer since the function isn't view/pure
                        );
                        
        MAIN_TOKEN_CONTRACT = new ethers.Contract(
                            tokenAddress, // your tokenSwapper contract address
                            faucetABI_MainToken,
                            signer // Use signer since the function isn't view/pure
                        );
                        



        const tx = await Address_ZEROXBTC_TESTNETCONTRACT_CONTRACT.getFacuetTokens_Testnet_0xBTC();


                        console.log("getFacuetTokens_Testnet_0xBTC transaction sent:", tx.hash);
                        await tx.wait();
                        console.log("Transaction confirmed!");


        const tx2 = await MAIN_TOKEN_CONTRACT.getFacuetTokens_Testnet();


                        console.log("getFacuetTokens_Testnet transaction sent:", tx2.hash);
                        await tx2.wait();
                        console.log("Transaction confirmed!");


                    fetchBalances();



        }

























































const erc20ABI = [
    {"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
    {"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},
    {"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
    {"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},
    {"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},
    {"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},
    {"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
    {"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},
    {"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"}
];

async function checkAllowance(tokenToCheck, spenderAddress, requiredAmount) {
    try {
        let tokenContract;
        let tokenName;
        
        await ethereum.request({ method: 'eth_requestAccounts' });
        const provider = new ethers.providers.Web3Provider(window.ethereum);
        const signer = provider.getSigner();

        // Determine which token to check
        if (tokenToCheck === tokenAddress) {
            tokenContract = new ethers.Contract(tokenAddress, erc20ABI, signer);
            tokenName = "B0x";
        } else if (tokenToCheck === Address_ZEROXBTC_TESTNETCONTRACT) {
            tokenContract = new ethers.Contract(Address_ZEROXBTC_TESTNETCONTRACT, erc20ABI, signer);
            tokenName = "0xBTC";
        } else {
            console.error("Unknown token address!");
            return false;
        }
        
        // Get current allowance
        const userAddress = await signer.getAddress();
        const currentAllowance = await tokenContract.allowance(userAddress, spenderAddress);
        
        console.log(`Current ${tokenName} allowance:`, ethers.utils.formatEther(currentAllowance));
        if(tokenName == "0xBTC"){

            console.log(`Required ${tokenName} amount:`, ethers.utils.formatUnits(requiredAmount,8));
        }else{

            console.log(`Required ${tokenName} amount:`, ethers.utils.formatEther(requiredAmount));
        
        }
        
        // Check if allowance is sufficient
        if (currentAllowance.gte(requiredAmount)) {
            alert(`${tokenName} allowance is sufficient. No approval needed.`);
            return true;
        } else {
            alert(`${tokenName} allowance is insufficient. Approval needed.`);
            return false;
        }
        
    } catch (error) {
        console.error("Allowance check failed:", error);
        alert(`Allowance check failed: ${error.message}`);
        return false;
    }
}


// Approve function
async function approveToken(tokenToApprove, spenderAddress, amount) {
    try {
        alert(`Approving ${tokenToApprove} token...`);
        
        let tokenContract;
        
        await ethereum.request({ method: 'eth_requestAccounts' });
        const provider = new ethers.providers.Web3Provider(window.ethereum);
        const signer = provider.getSigner();

        // Determine which token to approve
        if (tokenToApprove === tokenAddress) {
            // B0x token
            tokenContract = new ethers.Contract(tokenAddress, erc20ABI, signer);
            alert("Approving B0x token for spending...");
        } else if (tokenToApprove === Address_ZEROXBTC_TESTNETCONTRACT) {
            // 0xBTC token  
            tokenContract = new ethers.Contract(Address_ZEROXBTC_TESTNETCONTRACT, erc20ABI, signer);
            alert("Approving 0xBTC token for spending...");
        } else {
            alert("Unknown token address!");
            return false;
        }
        
        // Send approval transaction
        const approveTx = await tokenContract.approve(spenderAddress, amount);
        alert("Approval transaction sent! Waiting for confirmation...");
        
        // Wait for confirmation
        await approveTx.wait();
        alert("Token approval confirmed!");
        
        return true;
        
    } catch (error) {
        console.error("Approval failed:", error);
        alert(`Approval failed: ${error.message}`);
        return false;
    }
}

async function approveIfNeeded(tokenToApprove, spenderAddress, requiredAmount) {
    try {
        // First check if approval is needed
        const allowanceSufficient = await checkAllowance(tokenToApprove, spenderAddress, requiredAmount);
        
        if (allowanceSufficient) {
            console.log("Approval not needed - sufficient allowance exists");
            return true;
        }
        
        // If not sufficient, request approval for max amount
        alert("Requesting approval for unlimited amount to avoid future approvals...");
        const approvalSuccess = await approveToken(tokenToApprove, spenderAddress, ethers.constants.MaxUint256);
        
        return approvalSuccess;
        
    } catch (error) {
        console.error("Approve if needed failed:", error);
        alert(`Approval process failed: ${error.message}`);
        return false;
    }
}

// Usage examples:
// Check allowance only:
// checkAllowance(tokenAddress, POOL_MANAGER_ADDRESS, ethers.utils.parseEther("100"));

// Check and approve if needed:














// Helper function for 24-bit sign extension
function signExtend24Bit(value) {
  const SIGN_BIT = 0x800000; // Bit 23 for 24-bit numbers
  const MASK_24BIT = 0xFFFFFF;
  
  if (value & SIGN_BIT) {
    // Negative number - extend with 1s
    return (value | (~MASK_24BIT)) | 0; // | 0 converts to 32-bit signed int
  } else {
    // Positive number
    return value;
  }
}
// Direct JavaScript equivalents of your Solidity functions
function TOtickLower(info) {
  const TICK_LOWER_OFFSET = 8;
  const shifted = Number((BigInt(info) >> BigInt(TICK_LOWER_OFFSET)) & 0xFFFFFFn);
  return signExtend24Bit(shifted);
}

function TOtickUpper(info) {
  const TICK_UPPER_OFFSET = 32;
  const shifted = Number((BigInt(info) >> BigInt(TICK_UPPER_OFFSET)) & 0xFFFFFFn);
  return signExtend24Bit(shifted);
}


  


async function getTokenIDsOwnedByMetamask(){
    await getTokenIDsOwnedByUser(userAddress);

}


async function getTokenIDsOwnedByStaking(){
    await getTokenIDsOwnedByUser(contractAddressLPRewardsStaking);
}


async function getTokenIDsOwnedByUser(ADDRESSTOSEARCHOF){

  console.log("Calling findUserTokenIds for: ", ADDRESSTOSEARCHOF," to find all tokens owned by tokenAddress_Rewards aka Staking Contract");



        await ethereum.request({ method: 'eth_requestAccounts' });
        const provider = new ethers.providers.Web3Provider(window.ethereum);
        const signer = provider.getSigner();
// Compact ABI for findUserTokenIdswithMinimum function

positionFinderABI = [
    {
        "inputs": [
            {"internalType": "address", "name": "user", "type": "address"},
            {"internalType": "uint256", "name": "startId", "type": "uint256"},
            {"internalType": "uint256", "name": "endId", "type": "uint256"},
            {"internalType": "address", "name": "Token0", "type": "address"},
            {"internalType": "address", "name": "Token1", "type": "address"},
            {"internalType": "address", "name": "HookAddress", "type": "address"},
            {"internalType": "uint256", "name": "minTokenA", "type": "uint256"}
        ],
        "name": "findUserTokenIdswithMinimum",
        "outputs": [
            {"internalType": "uint256[]", "name": "ownedTokens", "type": "uint256[]"},
            {"internalType": "uint256[]", "name": "amountTokenA", "type": "uint256[]"},
            {"internalType": "uint256[]", "name": "amountTokenB", "type": "uint256[]"},
            {"internalType": "uint128[]", "name": "positionLiquidity", "type": "uint128[]"},
            {"internalType": "int128[]", "name": "feesOwedTokenA", "type": "int128[]"},
            {"internalType": "int128[]", "name": "feesOwedTokenB", "type": "int128[]"},
            {"internalType": "struct PoolKey[]", "name": "poolKeyz", "type": "tuple[]", 
                "components": [
                    {"internalType": "address", "name": "currency0", "type": "address"},
                    {"internalType": "address", "name": "currency1", "type": "address"},
                    {"internalType": "uint24", "name": "fee", "type": "uint24"},
                    {"internalType": "int24", "name": "tickSpacing", "type": "int24"},
                    {"internalType": "address", "name": "hooks", "type": "address"}
                ]
            },
            {"internalType": "uint256[]", "name": "poolInfo", "type": "uint256[]"}
        ],
        "stateMutability": "view",
        "type": "function"
    },
     {
        "inputs": [],
        "name": "getMaxUniswapIDPossible",
        "outputs": [
            {"internalType": "uint256", "name": "", "type": "uint256"}
        ],
        "stateMutability": "view",
        "type": "function"
    }
];


                        tokenPositionFinderPro = new ethers.Contract(
                    contractAddress_PositionFinderPro, // your tokenSwapper contract address
                    positionFinderABI,
                    signer // Use signer since the function isn't view/pure
                );






console.log("getting getMaxUniswapIDPossible!");
var MAXTOKENPOSSIBLE = 0;
var maxTokenPossible =0;
      try {
        // Call the view function
        const result = await tokenPositionFinderPro.getMaxUniswapIDPossible();



          // First debug what we're getting back
          console.log("Raw result type:", typeof result);
          console.log("Raw result structure:", Object.keys(result).join(", "));
          
          if (typeof result === 'bigint' || typeof result === 'number') {
            // If it's already a primitive value
            MAXTOKENPOSSIBLE = result;
          } else if (result._isBigNumber || result instanceof ethers.BigNumber) {
            // For ethers v5 BigNumber
            MAXTOKENPOSSIBLE = result;
          } else if (typeof result === 'object' && result !== null) {
            // For objects, try to extract the value
            // With ethers v6, we might get the value directly
            if (typeof result.toString === 'function' && result.toString().match(/^[0-9]+$/)) {
              MAXTOKENPOSSIBLE = result;
            } else {
              // Attempt to extract value based on common patterns
              MAXTOKENPOSSIBLE = result[0] || result.amountOut || result._hex || result.value || result;
            }
          }
          
          console.log(`Found valid Uniswap v4 MAXTOKEN POSSIBLE: ${MAXTOKENPOSSIBLE.toString()}`);

        // CONVERT TO REGULAR NUMBER FOR LOOP
        if (typeof MAXTOKENPOSSIBLE === 'bigint') {
          maxTokenPossible = Number(MAXTOKENPOSSIBLE);
        } else if (MAXTOKENPOSSIBLE._isBigNumber || MAXTOKENPOSSIBLE instanceof ethers.BigNumber) {
          // For ethers v5
          maxTokenPossible = MAXTOKENPOSSIBLE.toNumber();
        } else if (typeof MAXTOKENPOSSIBLE.toString === 'function') {
          // For ethers v6 or other BigInt-like objects
          maxTokenPossible = Number(MAXTOKENPOSSIBLE.toString());
        } else {
          maxTokenPossible = Number(MAXTOKENPOSSIBLE);
        }

        console.log(`Converted to number for loop: ${maxTokenPossible}`);
        } catch (error) {
          console.error(`Error finding valid getMaxUniswapIDPossible for swap:`, error);
        }





try {
  const maxLoopLookups = 1000;
  var startSearchAt = 0; // Start searching from token ID 0
  const totalRange = maxTokenPossible - startSearchAt;
  const NumberOfLoops = Math.ceil(totalRange / maxLoopLookups);
  
  // Initialize as empty arrays (not undefined)
  let ownedTokenIds = [];
  let OWNEDtOKEN1 = [];
  let OWNEDtOKEN2 = [];
  let liquidity = [];
  let feesOwedToken1 = [];
  let feesOwedToken2 = [];
  let poolKeyi = [];
  let poolInfoi = [];
  
  for (let x = 0; x < NumberOfLoops; x++) {
    const startId = startSearchAt + (maxLoopLookups * x);
    const endId = Math.min(startId + maxLoopLookups - 1, maxTokenPossible);
    
    console.log("Looking at NFT ids in this search IDS:", startId, "to", endId);
    
    const result = await tokenPositionFinderPro.findUserTokenIdswithMinimum(
      ADDRESSTOSEARCHOF, 
      startId, 
      endId, 
      tokenAddress, 
      Address_ZEROXBTC_TESTNETCONTRACT,
      HookAddress,
      0
    );
    
    // Concatenate arrays properly using spread operator or concat
    ownedTokenIds = ownedTokenIds.concat(result[0]);
    OWNEDtOKEN1 = OWNEDtOKEN1.concat(result[1]);
    OWNEDtOKEN2 = OWNEDtOKEN2.concat(result[2]);
    liquidity = liquidity.concat(result[3]);
    feesOwedToken1 = feesOwedToken1.concat(result[4]);
    feesOwedToken2 = feesOwedToken2.concat(result[5]);
    poolKeyi = poolKeyi.concat(result[6]);
    poolInfoi = poolInfoi.concat(result[7]);

  }




  console.log("Number of tokens owned By rewards Contract:", ownedTokenIds.length);
  console.log("Owned Token IDs by rewards Contract:", ownedTokenIds.map(id => id.toString()));
  
  // Now loop through each token ID to get position details
  for (let i = 0; i < ownedTokenIds.length; i++) {
    const tokenId = ownedTokenIds[i];
    
    try {
        // Get pool and position info using V4 method with corrected types
       // const [poolKey, info2] = await positionManager.getPoolAndPositionInfo(tokenId);
        poolKey = poolKeyi[i];
        info2 = poolInfoi[i];
        console.log(`Token ID ${tokenId.toString()}:`);
        console.log(" Pool Key:");
        console.log("   Currency0:", poolKey.currency0);     // Now properly typed as address
        console.log("   Currency1:", poolKey.currency1);     // Now properly typed as address
        console.log("   Fee:", poolKey.fee.toString());
        console.log("   Tick Spacing:", poolKey.tickSpacing.toString());
        console.log("   Hooks:", poolKey.hooks);             // Now properly typed as address
        console.log(" Position Info (packed):", info2.toString());
        

  
  const decodedInfo = {
    tickLower: TOtickLower(info2.toString()),
    tickUpper: TOtickUpper(info2.toString())
  };




        console.log(" Decoded Position Info:");
        console.log("   Tick Lower:", decodedInfo.tickLower);
        console.log("   Tick Upper:", decodedInfo.tickUpper);
        console.log("   tOKEN 1 AMOUNT:",OWNEDtOKEN1[i].toString());
        console.log("   tOKEN 2 AMOUNT:",OWNEDtOKEN2[i].toString());
        console.log("   Liquidity:", liquidity[i]);
        console.log("   FEES OWED Token 1 AMOUNT:",feesOwedToken1[i].toString());
        console.log("   FEES OWED Token 2 AMOUNT:",feesOwedToken2[i].toString());
      
    } catch (positionError) {
      console.error(`Error getting position details for token ${tokenId}:`, positionError);
    }

  }
  
} catch (error) {
  console.error(`Error findUserTokenIds:`, error);
}

  console.log("Calling getIDSofStakedTokensForUser of tokenAddress_Swapper");
// Get current time in milliseconds since Unix epoch
const currentTime = Date.now();
// If you need it in seconds (like Unix timestamp), divide by 1000
const currentTimeInSeconds = Math.floor(Date.now() / 1000);
console.log("Current Time in seconds since epoch", currentTimeInSeconds); // e.g., 1717974123



      try {
        // Call the view function
        // Call the view function
          const result = await positionFinder.getIDSofStakedTokensForUserwithMinimum(tokenAddress_Swapper, tokenAddress, Address_ZEROXBTC_TESTNETCONTRACT, HookAddress, 0);

                  
  // result is already the array of token IDs
  const ownedTokenIdsOFSwapperOnStaked = result[0]; // This is uint256[] - array of token IDs
  var OWNEDtOKEN1 = result[1];
  var OWNEDtOKEN2 = result[2];
  var liquidity = result[3];
  var timeStakedAT1 = result[4];
  var PenaltyForWithdraw = result[5];
  
  console.log("Calling getIDSofStakedTokensForUser of tokenAddress_Swapper");
  console.log("Calling getIDSofStakedTokensForUser of tokenAddress_Swapper");
  console.log("Number of tokens owned By OUR Contract:", ownedTokenIdsOFSwapperOnStaked.length);
  console.log("Owned NFT by OUR ContraT:", ownedTokenIdsOFSwapperOnStaked.map(id => id.toString()));
  
  // Now loop through each token ID to get position details
  for (let i = 0; i < ownedTokenIdsOFSwapperOnStaked.length; i++) {
    const tokenId = ownedTokenIdsOFSwapperOnStaked[i];
    
    try {
        // Get pool and position info using V4 method with corrected types
        const [poolKey, info2] = await positionManager.getPoolAndPositionInfo(tokenId);
        
        console.log(`Token ID ${tokenId.toString()}:`);
        console.log(" Pool Key:");
        console.log("   Currency0:", poolKey.currency0);     // Now properly typed as address
        console.log("   Currency1:", poolKey.currency1);     // Now properly typed as address
        console.log("   Fee:", poolKey.fee.toString());
        console.log("   Tick Spacing:", poolKey.tickSpacing.toString());
        console.log("   Hooks:", poolKey.hooks);             // Now properly typed as address
        console.log(" Time Staked AT:", timeStakedAT1[i].toString());
        console.log(" Position Info (packed):", info2.toString());
        
//just add function decodePositionInfo(packedInfo) { and return the decodedInfo if u want standalone function

 
  
  const decodedInfo = {
    tickLower: TOtickLower(info2.toString()),
    tickUpper: TOtickUpper(info2.toString())
  };



        console.log(" Decoded Position Info:");
        console.log("   Tick Lower:", decodedInfo.tickLower);
        console.log("   Tick Upper:", decodedInfo.tickUpper);
        console.log("   Liquidity:", liquidity[i]);
        console.log("   tOKEN 1 AMOUNT Staked:",OWNEDtOKEN1[i].toString());
        console.log("   tOKEN 2 AMOUNT Staked:",OWNEDtOKEN2[i].toString());
        console.log(" Time Staked AT:", timeStakedAT1[i].toString());
        const timetotal = currentTimeInSeconds - Number(timeStakedAT1[i]);
        console.log(" total staked position time", timetotal.toString());
        console.log("Penalty for withdraw = ", PenaltyForWithdraw);
        console.log("Penalty withdraw % = ", (PenaltyForWithdraw/1000*100)," %");
      
    } catch (positionError) {
      console.error(`Error getting position details for token ${tokenId}:`, positionError);
    }


  }
  
} catch (error) {
  console.error(`Error findUserTokenIds:`, error);
}




      console.log("sleep for 100seconds we did everything then we do some some reward collecting");


}





async function getRatioCreatePositiontokenB(){


            if(!walletConnected){
               await connectWallet();
            }

    var selectSlippage = document.getElementById('slippageTolerance');
    var selectSlippageValue = selectSlippage.value; // Returns: "0.1", "0.5", "1.0", or "2.0"
 const numberValueSlippage = parseFloat(selectSlippageValue.replace('%', ''));
    // Divide by 100 to get decimal
    const decimalValueSlippage= numberValueSlippage / 100;
    console.log("selectSlippageValue: ",selectSlippageValue);
    console.log("decimalValueSlippage: ",decimalValueSlippage);

const tokenASelect = document.querySelector('#create .form-group:nth-child(1) select');


// Get the currently selected value
const tokenAValue = tokenASelect.value;
console.log("Currently selected value TokenA:", tokenAValue);


const tokenBSelect = document.querySelector('#create .form-group:nth-child(2) select');


// Get the currently selected value
const tokenBvalue = tokenBSelect.value;
console.log("Currently selected value TokenB:", tokenBvalue);

// Or get the selected option element itself
const selectedOptionA = tokenASelect.options[tokenASelect.selectedIndex];
const selectedOptionB= tokenBSelect.options[tokenBSelect.selectedIndex];
console.log("selectedOptionA option text:", selectedOptionA.text);
console.log("selectedOptionA option value:", selectedOptionA.value);
console.log("selectedOptionB option text:", selectedOptionB.text);
console.log("selectedOptionB option value:", selectedOptionB.value);

            var tokenAinputAddress = tokenAddresses[selectedOptionA.value];
            var tokenBinputAddress = tokenAddresses[selectedOptionB.value];
console.log("tokenA InputAddresstoken", tokenAinputAddress);
console.log("tokenB InputAddresstoken", tokenBinputAddress);

// Simple and reliable approach - select all number inputs in create page
const createInputs = document.querySelectorAll('#create input[type="number"]');
const amountInputA = createInputs[0]; // First number input (Amount A)
const amountInputB = createInputs[1]; // Second number input (Amount B)

// Add null checks to prevent errors
if (!amountInputA || !amountInputB) {
    console.error("Could not find amount input fields");
    return;
}

// Get the currently selected values
const tokenAInput = amountInputA.value;
const tokenBInput = amountInputB.value;

console.log("Currently amountInputA value:", tokenAInput);
console.log("Currently amountInputB value:", tokenBInput);


            var amountAtoCreate = ethers.utils.parseUnits(tokenAInput, 18);  // Correctly represents 12 * 10^8
            
            if( selectedOptionA.value=="0xBTC"){
                    console.log("LOGGED 0xBTC selected A Value");
             amountAtoCreate = ethers.utils.parseUnits(tokenAInput, 8);  // Correctly represents 12 * 10^8
            }

console.log("Currently amountInputB value:", tokenBInput);
            var amountBtoCreate = ethers.utils.parseUnits(tokenBInput, 18);  // Correctly represents 12 * 10^8
            
            if( selectedOptionB.value=="0xBTC"){
                    console.log("LOGGED 0xBTC selected B Value");
             amountBtoCreate = ethers.utils.parseUnits(tokenBInput, 8);  // Correctly represents 12 * 10^8
            }


            let amountOut = 0;
const tokenSwapperABI = [
    // Your existing createPosition function
   {"inputs":[{"name":"token","type":"address"},{"name":"token2","type":"address"},{"name":"amountIn","type":"uint256"},{"name":"amountIn2","type":"uint256"},{"name":"currentx96","type":"uint256"},{"name":"slippage","type":"uint256"},{"name":"hookAddress","type":"address"},{"name":"toSendNFTto","type":"address"}],"name":"createPositionWith2Tokens","outputs":[{"name":"","type":"bool"}],"stateMutability":"payable","type":"function"},
    //get sqrtx96price for us
,{"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"address","name":"token2","type":"address"},{"internalType":"address","name":"hookAddress","type":"address"}],"name":"getsqrtPricex96","outputs":[{"internalType":"uint160","name":"","type":"uint160"}],"stateMutability":"view","type":"function"}

   ,{"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"address","name":"token2","type":"address"},{"internalType":"address","name":"hookAddress","type":"address"}],"name":"getPriceRatio","outputs":[{"internalType":"uint256","name":"ratio","type":"uint256"},{"internalType":"address","name":"token0z","type":"address"},{"internalType":"address","name":"token1z","type":"address"},{"internalType":"uint8","name":"token0decimals","type":"uint8"},{"internalType":"uint8","name":"token1decimals","type":"uint8"}],"stateMutability":"view","type":"function"}
];

        await ethereum.request({ method: 'eth_requestAccounts' });
        const provider = new ethers.providers.Web3Provider(window.ethereum);
        const signer = provider.getSigner();

                tokenSwapperContract = new ethers.Contract(
                    contractAddress_Swapper, // your tokenSwapper contract address
                    tokenSwapperABI,
                    signer // Use signer since the function isn't view/pure
                );


    let ratioz = 0;
            try {
                // Call the view function
                const result = await tokenSwapperContract.callStatic.getPriceRatio(tokenAddress, Address_ZEROXBTC_TESTNETCONTRACT, HookAddress);




          // First debug what we're getting back
          console.log("Raw result type:", typeof result);
          console.log("Raw result structure:", Object.keys(result).join(", "));
          ratioz = result[0];

          
          
          console.log(`Found valid Ratio x10**18: ${ratioz.toString()}`);
          // Format to display as a readable number
          readableAmountOut = ethers.utils.formatEther(ratioz);
          ratioAsWei = ethers.utils.parseEther(readableAmountOut);
          console.log(`Found valid Ratio x10**18: ${readableAmountOut} mutliplier`);
        } catch (error) {
          console.error(`Error finding valid getPriceRatio for swap:`, error);
        }




        let amountToDeposit = ethers.utils.parseEther("200");  // 200 * 10^18 for B0x token
        var amountToDepositOfZer0X = ethers.utils.parseUnits("100", 8); // 0.01 * 10^8 for 0xBTC
        var amountWith8Decimals0xBTC = 0n;
        let liquiditySalt = 0; // Declare once outside the if/else

            if(tokenAinputAddress != Address_ZEROXBTC_TESTNETCONTRACT) {
            console.log(`Found valid Ratio: ${ratioz.toString()}`);
            console.log("TokenA == zer0x Token (0xBTC is token0, B0x is token1)");
            

            calculatedPriceRatio = BigInt(ratioz);


            amountWith8Decimals0xBTC = amountBtoCreate;
            console.log("amountWith8Decimals0xBTCamountWith8Decimals0xBTC: ",amountWith8Decimals0xBTC.toString());
            // Your calculatedPriceRatio = 200000000000000000000000000000n represents 20 in 29-decimal format
            // Method 1: Direct conversion to get the economic price (20)

            const priceIn18Decimals = calculatedPriceRatio / (10n**10n); // Remove 11 decimals (29-18=11)

            console.log("Price in 18-decimal format:", priceIn18Decimals.toString()); // Should be 20000000000000000000 (20 * 10^18)
            
            // Method 2: Calculate B0x amount needed
            // Formula: B0x_amount = 0xBTC_amount * price
            // We need: (amountToDepositOfZer0X in 18-decimal) * (price in 18-decimal) / 10^18
            
            const amountZer0XIn18Decimals = BigInt(amountBtoCreate) * 10n**10n; // Convert 8-decimal to 18-decimal
            amountToDeposit = (amountZer0XIn18Decimals * priceIn18Decimals) / (10n**18n);
            
            // Alternative simpler method:
            // const economicAmountZer0X = Number(ethers.formatUnits(amountToDepositOfZer0X, 8)); // 0.01
            // const economicAmountB0x = economicAmountZer0X * 20; // 0.01 * 20 = 0.2
            // const amountToDeposit = ethers.parseEther(economicAmountB0x.toString());

            console.log(`Estimated Deposit B0x amount: ${ethers.utils.formatEther(amountToDeposit)}`); // Should be 0.2
            console.log(`Estimated Deposit 0xBTC amount: ${ethers.utils.formatUnits(amountWith8Decimals0xBTC, 8)}`); // Should be 0.01
                console.log(`amountWith8Decimals0xBTC: ${amountWith8Decimals0xBTC}`);
                        console.log(`amountToDeposit: ${amountToDeposit}`);


        } else { 
                    
              // Start with 0xBTC amount (this could be user input or calculated value)
            var amountB0x = BigInt(amountBtoCreate); // Your 0xBTC input
            
            console.log("Amount B0x input: ", amountB0x.toString());
            const priceRatio2 = BigInt(ratioz);
            console.log(`priceRatio: ${priceRatio2}`);
            
            // Reverse calculation to get B0x amount
            amountAtoCreate = (amountB0x * (10n**18n)) / priceRatio2;
            
            var temp = amountB0x;
            amountB0x = amountAtoCreate;
            amountAtoCreate = temp;


            console.log(`Estimated Deposit 0xBTC amount: ${amountB0x}`);
            console.log(`Estimated Deposit B0x amount: ${amountAtoCreate}`);
            console.log(`Estimated Deposit 0xBTC amount: ${ethers.utils.formatUnits(amountB0x, 8)}`);
            console.log(`Estimated Deposit B0x amount: ${ethers.utils.formatEther(amountAtoCreate)}`);
            var temp = amountAtoCreate;
            amountWith8Decimals0xBTC = amountB0x;
            amountToDeposit = temp;

    
            
        }

        
        console.log("walletBalances: ",walletBalances['0xBTC']);
        var zeroxbtcdecimal = amountWith8Decimals0xBTC.toString();
        var wallet_zeroxbtc = ethers.utils.parseUnits(walletBalances['0xBTC'], 8).toString();
        console.log("amountWith8Decimals0xBTC: ",zeroxbtcdecimal);
        console.log("wallet_zeroxbtc: ",wallet_zeroxbtc);
        if(parseFloat(zeroxbtcdecimal)>parseFloat(wallet_zeroxbtc)){
            alert("too much 0xbtc u dont have lower it!.")
        }
        
        var b0xdecimal = amountToDeposit.toString();
        var wallet_b0x = ethers.utils.parseUnits(walletBalances['B0x'], 18).toString();
        console.log("amountWith b0xdecimal:  ",b0xdecimal);
        console.log("wallet_b0x: ",wallet_b0x);
        
        if(parseFloat(b0xdecimal)>parseFloat(wallet_b0x)){
            alert("too much b0x u dont have lower it!.")
        }
/*

    function createPositionWith2Tokens(
        address token,
        address token2,
        uint256 amountIn,
        uint256 amountIn2,
        uint currentx96,        // Expected sqrtPriceX96 when user initiated tx
        uint256 slippage,       // Slippage tolerance in basis points (e.g., 100 = 1%)
        address hookAddress,
        address toSendNFTto) public payable returns (bool)
            {
*/

const amountToDepositBN = ethers.BigNumber.from(amountToDeposit.toString());
const amountToDepositBN2 = ethers.BigNumber.from(amountWith8Decimals0xBTC.toString());


let Current_getsqrtPricex96=0;

      try {
        // Call the view function
        const result = await tokenSwapperContract.getsqrtPricex96(tokenAddress, Address_ZEROXBTC_TESTNETCONTRACT, HookAddress);



          // First debug what we're getting back
          console.log("Raw result type:", typeof result);
          console.log("Raw result structure:", Object.keys(result).join(", "));
          
          if (typeof result === 'bigint' || typeof result === 'number') {
            // If it's already a primitive value
            Current_getsqrtPricex96 = result;
          } else if (result._isBigNumber || result instanceof ethers.BigNumber) {
            // For ethers v5 BigNumber
            Current_getsqrtPricex96 = result;
          } else if (typeof result === 'object' && result !== null) {
            // For objects, try to extract the value
            // With ethers v6, we might get the value directly
            if (typeof result.toString === 'function' && result.toString().match(/^[0-9]+$/)) {
              Current_getsqrtPricex96 = result;
            } else {
              // Attempt to extract value based on common patterns
              Current_getsqrtPricex96 = result[0] || result.amountOut || result._hex || result.value || result;
            }
          }
          
          console.log(`Found valid Current_getsqrtPricex96 x10**18: ${Current_getsqrtPricex96.toString()}`);
          // Format to display as a readable number
        } catch (error) {
          console.error(`Error finding valid Current_getsqrtPricex96 for swap:`, error);
        }
try{

                console.log("tokenAddress: ", tokenAddress);

                console.log("Address_ZEROXBTC_TESTNETCONTRACT: ", Address_ZEROXBTC_TESTNETCONTRACT.toString());

                console.log("amountToDepositBN: ", amountToDepositBN.toString());
                console.log("amountToDepositBN2: ", amountToDepositBN2.toString());
                console.log("Current_getsqrtPricex96: ", Current_getsqrtPricex96.toString());
                console.log("HookAddress: ", HookAddress.toString());

/*

const amountToSwapBN = ethers.BigNumber.from(amountToSwap.toString());
const minAmountOutBN = ethers.BigNumber.from(MinamountOut.toFixed(0).toString());



            try {
                // Call the swap function
                const tx = await tokenSwapperContract.swapTokenTWOTOKENS(
                    tokenAddress, 
                    Address_ZEROXBTC_TESTNETCONTRACT, 
                    tokenAddress, 
                    Address_ZEROXBTC_TESTNETCONTRACT, 
                    amountToSwapBN, 
                    minAmountOutBN, 
                    HookAddress, 
                    userAddress
                );
                */

                if(tokenAinputAddress == Address_ZEROXBTC_TESTNETCONTRACT) {
                    amountInputB.value = ethers.utils.formatUnits(amountToDeposit, 18);
                    amountInputA.value = ethers.utils.formatUnits(amountWith8Decimals0xBTC, 8);
                } else {
                    amountInputB.value = ethers.utils.formatUnits(amountWith8Decimals0xBTC, 8);
                    amountInputA.value = ethers.utils.formatUnits(amountToDeposit, 18);
                }

            ratiozToSave = 10000*amountToDepositBN / amountToDepositBN2;

            fetchBalances();
                
            } catch (error) {
                console.error(`Error  create Position :`, error);
            }
        }












var ratiozToSave  = 0;





async function getRatioCreatePositiontokenA(){


            if(!walletConnected){
               await connectWallet();
            }

    var selectSlippage = document.getElementById('slippageTolerance');
    var selectSlippageValue = selectSlippage.value; // Returns: "0.1", "0.5", "1.0", or "2.0"
 const numberValueSlippage = parseFloat(selectSlippageValue.replace('%', ''));
    // Divide by 100 to get decimal
    const decimalValueSlippage= numberValueSlippage / 100;
    console.log("selectSlippageValue: ",selectSlippageValue);
    console.log("decimalValueSlippage: ",decimalValueSlippage);

const tokenASelect = document.querySelector('#create .form-group:nth-child(1) select');


// Get the currently selected value
const tokenAValue = tokenASelect.value;
console.log("Currently selected value TokenA:", tokenAValue);


const tokenBSelect = document.querySelector('#create .form-group:nth-child(2) select');


// Get the currently selected value
const tokenBvalue = tokenBSelect.value;
console.log("Currently selected value TokenB:", tokenBvalue);

// Or get the selected option element itself
const selectedOptionA = tokenASelect.options[tokenASelect.selectedIndex];
const selectedOptionB= tokenBSelect.options[tokenBSelect.selectedIndex];
console.log("selectedOptionA option text:", selectedOptionA.text);
console.log("selectedOptionA option value:", selectedOptionA.value);
console.log("selectedOptionB option text:", selectedOptionB.text);
console.log("selectedOptionB option value:", selectedOptionB.value);

            var tokenAinputAddress = tokenAddresses[selectedOptionA.value];
            var tokenBinputAddress = tokenAddresses[selectedOptionB.value];
console.log("tokenA InputAddresstoken", tokenAinputAddress);
console.log("tokenB InputAddresstoken", tokenBinputAddress);

// Simple and reliable approach - select all number inputs in create page
const createInputs = document.querySelectorAll('#create input[type="number"]');
const amountInputA = createInputs[0]; // First number input (Amount A)
const amountInputB = createInputs[1]; // Second number input (Amount B)

// Add null checks to prevent errors
if (!amountInputA || !amountInputB) {
    console.error("Could not find amount input fields");
    return;
}

// Get the currently selected values
const tokenAInput = amountInputA.value;
const tokenBInput = amountInputB.value;

console.log("Currently amountInputA value:", tokenAInput);
console.log("Currently amountInputB value:", tokenBInput);


            var amountAtoCreate = ethers.utils.parseUnits(tokenAInput, 18);  // Correctly represents 12 * 10^8
            
            if( selectedOptionA.value=="0xBTC"){
                    console.log("LOGGED 0xBTC selected A Value");
             amountAtoCreate = ethers.utils.parseUnits(tokenAInput, 8);  // Correctly represents 12 * 10^8
            }

console.log("Currently amountInputB value:", tokenBInput);
            var amountBtoCreate = ethers.utils.parseUnits(tokenBInput, 18);  // Correctly represents 12 * 10^8
            
            if( selectedOptionB.value=="0xBTC"){
                    console.log("LOGGED 0xBTC selected B Value");
             amountBtoCreate = ethers.utils.parseUnits(tokenBInput, 8);  // Correctly represents 12 * 10^8
            }


            let amountOut = 0;
const tokenSwapperABI = [
    // Your existing createPosition function
   {"inputs":[{"name":"token","type":"address"},{"name":"token2","type":"address"},{"name":"amountIn","type":"uint256"},{"name":"amountIn2","type":"uint256"},{"name":"currentx96","type":"uint256"},{"name":"slippage","type":"uint256"},{"name":"hookAddress","type":"address"},{"name":"toSendNFTto","type":"address"}],"name":"createPositionWith2Tokens","outputs":[{"name":"","type":"bool"}],"stateMutability":"payable","type":"function"},
    //get sqrtx96price for us
,{"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"address","name":"token2","type":"address"},{"internalType":"address","name":"hookAddress","type":"address"}],"name":"getsqrtPricex96","outputs":[{"internalType":"uint160","name":"","type":"uint160"}],"stateMutability":"view","type":"function"}

   ,{"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"address","name":"token2","type":"address"},{"internalType":"address","name":"hookAddress","type":"address"}],"name":"getPriceRatio","outputs":[{"internalType":"uint256","name":"ratio","type":"uint256"},{"internalType":"address","name":"token0z","type":"address"},{"internalType":"address","name":"token1z","type":"address"},{"internalType":"uint8","name":"token0decimals","type":"uint8"},{"internalType":"uint8","name":"token1decimals","type":"uint8"}],"stateMutability":"view","type":"function"}
];

        await ethereum.request({ method: 'eth_requestAccounts' });
        const provider = new ethers.providers.Web3Provider(window.ethereum);
        const signer = provider.getSigner();

                tokenSwapperContract = new ethers.Contract(
                    contractAddress_Swapper, // your tokenSwapper contract address
                    tokenSwapperABI,
                    signer // Use signer since the function isn't view/pure
                );


    let ratioz = 0;
            try {
                // Call the view function
                const result = await tokenSwapperContract.callStatic.getPriceRatio(tokenAddress, Address_ZEROXBTC_TESTNETCONTRACT, HookAddress);




          // First debug what we're getting back
          console.log("Raw result type:", typeof result);
          console.log("Raw result structure:", Object.keys(result).join(", "));
          ratioz = result[0];

          
          
          console.log(`Found valid Ratio x10**18: ${ratioz.toString()}`);
          // Format to display as a readable number
          readableAmountOut = ethers.utils.formatEther(ratioz);
          ratioAsWei = ethers.utils.parseEther(readableAmountOut);
          console.log(`Found valid Ratio x10**18: ${readableAmountOut} mutliplier`);
        } catch (error) {
          console.error(`Error finding valid getPriceRatio for swap:`, error);
        }




        let amountToDeposit = ethers.utils.parseEther("200");  // 200 * 10^18 for B0x token
        var amountToDepositOfZer0X = ethers.utils.parseUnits("100", 8); // 0.01 * 10^8 for 0xBTC
        var amountWith8Decimals0xBTC = 0n;
        let liquiditySalt = 0; // Declare once outside the if/else

            if(tokenAinputAddress == Address_ZEROXBTC_TESTNETCONTRACT) {
            console.log(`Found valid Ratio: ${ratioz.toString()}`);
            console.log("TokenA == zer0x Token (0xBTC is token0, B0x is token1)");
            

            calculatedPriceRatio = BigInt(ratioz);


            amountWith8Decimals0xBTC = amountAtoCreate;
            console.log("amountWith8Decimals0xBTCamountWith8Decimals0xBTC: ",amountWith8Decimals0xBTC.toString());
            // Your calculatedPriceRatio = 200000000000000000000000000000n represents 20 in 29-decimal format
            // Method 1: Direct conversion to get the economic price (20)

            const priceIn18Decimals = calculatedPriceRatio / (10n**10n); // Remove 11 decimals (29-18=11)

            console.log("Price in 18-decimal format:", priceIn18Decimals.toString()); // Should be 20000000000000000000 (20 * 10^18)
            
            // Method 2: Calculate B0x amount needed
            // Formula: B0x_amount = 0xBTC_amount * price
            // We need: (amountToDepositOfZer0X in 18-decimal) * (price in 18-decimal) / 10^18
            
            const amountZer0XIn18Decimals = BigInt(amountAtoCreate) * 10n**10n; // Convert 8-decimal to 18-decimal
            amountToDeposit = (amountZer0XIn18Decimals * priceIn18Decimals) / (10n**18n);
            
            // Alternative simpler method:
            // const economicAmountZer0X = Number(ethers.formatUnits(amountToDepositOfZer0X, 8)); // 0.01
            // const economicAmountB0x = economicAmountZer0X * 20; // 0.01 * 20 = 0.2
            // const amountToDeposit = ethers.parseEther(economicAmountB0x.toString());

            console.log(`Estimated Deposit B0x amount: ${ethers.utils.formatEther(amountToDeposit)}`); // Should be 0.2
            console.log(`Estimated Deposit 0xBTC amount: ${ethers.utils.formatUnits(amountWith8Decimals0xBTC, 8)}`); // Should be 0.01
                console.log(`amountWith8Decimals0xBTC: ${amountWith8Decimals0xBTC}`);
                        console.log(`amountToDeposit: ${amountToDeposit}`);


        } else { 
                    
              // Start with 0xBTC amount (this could be user input or calculated value)
            var amountB0x = BigInt(amountAtoCreate); // Your 0xBTC input
            
            console.log("Amount B0x input: ", amountB0x.toString());
            const priceRatio2 = BigInt(ratioz);
            console.log(`priceRatio: ${priceRatio2}`);
            
            // Reverse calculation to get B0x amount
            amountAtoCreate = (amountB0x * (10n**18n)) / priceRatio2;
            
            var temp = amountB0x;
            amountB0x = amountAtoCreate;
            amountAtoCreate = temp;


            console.log(`Estimated Deposit 0xBTC amount: ${amountB0x}`);
            console.log(`Estimated Deposit B0x amount: ${amountAtoCreate}`);
            console.log(`Estimated Deposit 0xBTC amount: ${ethers.utils.formatUnits(amountB0x, 8)}`);
            console.log(`Estimated Deposit B0x amount: ${ethers.utils.formatEther(amountAtoCreate)}`);
            var temp = amountAtoCreate;
            amountWith8Decimals0xBTC = amountB0x;
            amountToDeposit = temp;

    
            
        }

        
        console.log("walletBalances: ",walletBalances['0xBTC']);
        var zeroxbtcdecimal = amountWith8Decimals0xBTC.toString();
        var wallet_zeroxbtc = ethers.utils.parseUnits(walletBalances['0xBTC'], 8).toString();
        console.log("amountWith8Decimals0xBTC: ",zeroxbtcdecimal);
        console.log("wallet_zeroxbtc: ",wallet_zeroxbtc);
        if(parseFloat(zeroxbtcdecimal)>parseFloat(wallet_zeroxbtc)){
            alert("too much 0xbtc u dont have lower it!.")
        }
        
        var b0xdecimal = amountToDeposit.toString();
        var wallet_b0x = ethers.utils.parseUnits(walletBalances['B0x'], 18).toString();
        console.log("amountWith b0xdecimal:  ",b0xdecimal);
        console.log("wallet_b0x: ",wallet_b0x);
        
        if(parseFloat(b0xdecimal)>parseFloat(wallet_b0x)){
            alert("too much b0x u dont have lower it!.")
        }
/*

    function createPositionWith2Tokens(
        address token,
        address token2,
        uint256 amountIn,
        uint256 amountIn2,
        uint currentx96,        // Expected sqrtPriceX96 when user initiated tx
        uint256 slippage,       // Slippage tolerance in basis points (e.g., 100 = 1%)
        address hookAddress,
        address toSendNFTto) public payable returns (bool)
            {
*/

const amountToDepositBN = ethers.BigNumber.from(amountToDeposit.toString());
const amountToDepositBN2 = ethers.BigNumber.from(amountWith8Decimals0xBTC.toString());


let Current_getsqrtPricex96=0;

      try {
        // Call the view function
        const result = await tokenSwapperContract.getsqrtPricex96(tokenAddress, Address_ZEROXBTC_TESTNETCONTRACT, HookAddress);



          // First debug what we're getting back
          console.log("Raw result type:", typeof result);
          console.log("Raw result structure:", Object.keys(result).join(", "));
          
          if (typeof result === 'bigint' || typeof result === 'number') {
            // If it's already a primitive value
            Current_getsqrtPricex96 = result;
          } else if (result._isBigNumber || result instanceof ethers.BigNumber) {
            // For ethers v5 BigNumber
            Current_getsqrtPricex96 = result;
          } else if (typeof result === 'object' && result !== null) {
            // For objects, try to extract the value
            // With ethers v6, we might get the value directly
            if (typeof result.toString === 'function' && result.toString().match(/^[0-9]+$/)) {
              Current_getsqrtPricex96 = result;
            } else {
              // Attempt to extract value based on common patterns
              Current_getsqrtPricex96 = result[0] || result.amountOut || result._hex || result.value || result;
            }
          }
          
          console.log(`Found valid Current_getsqrtPricex96 x10**18: ${Current_getsqrtPricex96.toString()}`);
          // Format to display as a readable number
        } catch (error) {
          console.error(`Error finding valid Current_getsqrtPricex96 for swap:`, error);
        }
try{

                console.log("tokenAddress: ", tokenAddress);

                console.log("Address_ZEROXBTC_TESTNETCONTRACT: ", Address_ZEROXBTC_TESTNETCONTRACT.toString());

                console.log("amountToDepositBN: ", amountToDepositBN.toString());
                console.log("amountToDepositBN2: ", amountToDepositBN2.toString());
                console.log("Current_getsqrtPricex96: ", Current_getsqrtPricex96.toString());
                console.log("HookAddress: ", HookAddress.toString());

/*

const amountToSwapBN = ethers.BigNumber.from(amountToSwap.toString());
const minAmountOutBN = ethers.BigNumber.from(MinamountOut.toFixed(0).toString());



            try {
                // Call the swap function
                const tx = await tokenSwapperContract.swapTokenTWOTOKENS(
                    tokenAddress, 
                    Address_ZEROXBTC_TESTNETCONTRACT, 
                    tokenAddress, 
                    Address_ZEROXBTC_TESTNETCONTRACT, 
                    amountToSwapBN, 
                    minAmountOutBN, 
                    HookAddress, 
                    userAddress
                );
                */

                if(tokenAinputAddress == Address_ZEROXBTC_TESTNETCONTRACT) {
                    amountInputB.value = ethers.utils.formatUnits(amountToDeposit, 18);
                    amountInputA.value = ethers.utils.formatUnits(amountWith8Decimals0xBTC, 8);
                } else {
                    amountInputB.value = ethers.utils.formatUnits(amountWith8Decimals0xBTC, 8);
                    amountInputA.value = ethers.utils.formatUnits(amountToDeposit, 18);
                }

            ratiozToSave = 10000*amountToDepositBN / amountToDepositBN2;

            fetchBalances();
                
            } catch (error) {
                console.error(`Error  create Position :`, error);
            }
        }







        async function getCreatePosition() {
            if(!walletConnected){
               await connectWallet();
            }

    var selectSlippage = document.getElementById('slippageTolerance');
    var selectSlippageValue = selectSlippage.value; // Returns: "0.1", "0.5", "1.0", or "2.0"
 const numberValueSlippage = parseFloat(selectSlippageValue.replace('%', ''));
    // Divide by 100 to get decimal
    const decimalValueSlippage= numberValueSlippage / 100;
    console.log("selectSlippageValue: ",selectSlippageValue);
    console.log("decimalValueSlippage: ",decimalValueSlippage);

const tokenASelect = document.querySelector('#create .form-group:nth-child(1) select');


// Get the currently selected value
const tokenAValue = tokenASelect.value;
console.log("Currently selected value TokenA:", tokenAValue);


const tokenBSelect = document.querySelector('#create .form-group:nth-child(2) select');


// Get the currently selected value
const tokenBvalue = tokenBSelect.value;
console.log("Currently selected value TokenB:", tokenBvalue);

// Or get the selected option element itself
const selectedOptionA = tokenASelect.options[tokenASelect.selectedIndex];
const selectedOptionB= tokenBSelect.options[tokenBSelect.selectedIndex];
console.log("selectedOptionA option text:", selectedOptionA.text);
console.log("selectedOptionA option value:", selectedOptionA.value);
console.log("selectedOptionB option text:", selectedOptionB.text);
console.log("selectedOptionB option value:", selectedOptionB.value);

            var tokenAinputAddress = tokenAddresses[selectedOptionA.value];
            var tokenBinputAddress = tokenAddresses[selectedOptionB.value];
console.log("tokenA InputAddresstoken", tokenAinputAddress);
console.log("tokenB InputAddresstoken", tokenBinputAddress);

// Simple and reliable approach - select all number inputs in create page
const createInputs = document.querySelectorAll('#create input[type="number"]');
const amountInputA = createInputs[0]; // First number input (Amount A)
const amountInputB = createInputs[1]; // Second number input (Amount B)

// Add null checks to prevent errors
if (!amountInputA || !amountInputB) {
    console.error("Could not find amount input fields");
    return;
}

// Get the currently selected values
const tokenAInput = amountInputA.value;
const tokenBInput = amountInputB.value;

console.log("Currently amountInputA value:", tokenAInput);
console.log("Currently amountInputB value:", tokenBInput);


            var amountAtoCreate = ethers.utils.parseUnits(tokenAInput, 18);  // Correctly represents 12 * 10^8
            
            if( selectedOptionA.value=="0xBTC"){
                    console.log("LOGGED 0xBTC selected A Value");
             amountAtoCreate = ethers.utils.parseUnits(tokenAInput, 8);  // Correctly represents 12 * 10^8
            }

console.log("Currently amountInputB value:", tokenBInput);
            var amountBtoCreate = ethers.utils.parseUnits(tokenBInput, 18);  // Correctly represents 12 * 10^8
            
            if( selectedOptionB.value=="0xBTC"){
                    console.log("LOGGED 0xBTC selected B Value");
             amountBtoCreate = ethers.utils.parseUnits(tokenBInput, 8);  // Correctly represents 12 * 10^8
            }


            let amountOut = 0;
const tokenSwapperABI = [
    // Your existing createPosition function
   {"inputs":[{"name":"token","type":"address"},{"name":"token2","type":"address"},{"name":"amountIn","type":"uint256"},{"name":"amountIn2","type":"uint256"},{"name":"currentx96","type":"uint256"},{"name":"slippage","type":"uint256"},{"name":"hookAddress","type":"address"},{"name":"toSendNFTto","type":"address"}],"name":"createPositionWith2Tokens","outputs":[{"name":"","type":"bool"}],"stateMutability":"payable","type":"function"},
    //get sqrtx96price for us
,{"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"address","name":"token2","type":"address"},{"internalType":"address","name":"hookAddress","type":"address"}],"name":"getsqrtPricex96","outputs":[{"internalType":"uint160","name":"","type":"uint160"}],"stateMutability":"view","type":"function"}

   ,{"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"address","name":"token2","type":"address"},{"internalType":"address","name":"hookAddress","type":"address"}],"name":"getPriceRatio","outputs":[{"internalType":"uint256","name":"ratio","type":"uint256"},{"internalType":"address","name":"token0z","type":"address"},{"internalType":"address","name":"token1z","type":"address"},{"internalType":"uint8","name":"token0decimals","type":"uint8"},{"internalType":"uint8","name":"token1decimals","type":"uint8"}],"stateMutability":"view","type":"function"}
];

        await ethereum.request({ method: 'eth_requestAccounts' });
        const provider = new ethers.providers.Web3Provider(window.ethereum);
        const signer = provider.getSigner();

                tokenSwapperContract = new ethers.Contract(
                    contractAddress_Swapper, // your tokenSwapper contract address
                    tokenSwapperABI,
                    signer // Use signer since the function isn't view/pure
                );


    let ratioz = 0;
            try {
                // Call the view function
                const result = await tokenSwapperContract.callStatic.getPriceRatio(tokenAddress, Address_ZEROXBTC_TESTNETCONTRACT, HookAddress);




          // First debug what we're getting back
          console.log("Raw result type:", typeof result);
          console.log("Raw result structure:", Object.keys(result).join(", "));
          ratioz = result[0];

          
          
          console.log(`Found valid Ratio x10**18: ${ratioz.toString()}`);
          // Format to display as a readable number
          readableAmountOut = ethers.utils.formatEther(ratioz);
          ratioAsWei = ethers.utils.parseEther(readableAmountOut);
          console.log(`Found valid Ratio x10**18: ${readableAmountOut} mutliplier`);
        } catch (error) {
          console.error(`Error finding valid getPriceRatio for swap:`, error);
        }




        let amountToDeposit = ethers.utils.parseEther("200");  // 200 * 10^18 for B0x token
        var amountToDepositOfZer0X = ethers.utils.parseUnits("100", 8); // 0.01 * 10^8 for 0xBTC
        var amountWith8Decimals0xBTC = 0n;
        let liquiditySalt = 0; // Declare once outside the if/else

            if(tokenAinputAddress == Address_ZEROXBTC_TESTNETCONTRACT) {
            console.log(`Found valid Ratio: ${ratioz.toString()}`);
            console.log("TokenA == zer0x Token (0xBTC is token0, B0x is token1)");
            

            calculatedPriceRatio = BigInt(ratioz);


            amountWith8Decimals0xBTC = amountAtoCreate;
            console.log("amountWith8Decimals0xBTCamountWith8Decimals0xBTC: ",amountWith8Decimals0xBTC.toString());
            // Your calculatedPriceRatio = 200000000000000000000000000000n represents 20 in 29-decimal format
            // Method 1: Direct conversion to get the economic price (20)

            const priceIn18Decimals = calculatedPriceRatio / (10n**10n); // Remove 11 decimals (29-18=11)

            console.log("Price in 18-decimal format:", priceIn18Decimals.toString()); // Should be 20000000000000000000 (20 * 10^18)
            
            // Method 2: Calculate B0x amount needed
            // Formula: B0x_amount = 0xBTC_amount * price
            // We need: (amountToDepositOfZer0X in 18-decimal) * (price in 18-decimal) / 10^18
            
            const amountZer0XIn18Decimals = BigInt(amountAtoCreate) * 10n**10n; // Convert 8-decimal to 18-decimal
            amountToDeposit = (amountZer0XIn18Decimals * priceIn18Decimals) / (10n**18n);
            
            // Alternative simpler method:
            // const economicAmountZer0X = Number(ethers.formatUnits(amountToDepositOfZer0X, 8)); // 0.01
            // const economicAmountB0x = economicAmountZer0X * 20; // 0.01 * 20 = 0.2
            // const amountToDeposit = ethers.parseEther(economicAmountB0x.toString());

            console.log(`Estimated Deposit B0x amount: ${ethers.utils.formatEther(amountToDeposit)}`); // Should be 0.2
            console.log(`Estimated Deposit 0xBTC amount: ${ethers.utils.formatUnits(amountWith8Decimals0xBTC, 8)}`); // Should be 0.01
                console.log(`amountWith8Decimals0xBTC: ${amountWith8Decimals0xBTC}`);
                        console.log(`amountToDeposit: ${amountToDeposit}`);


        } else { 
            
            
                    
            amountToDeposit = BigInt(amountBtoCreate); // Fixed B0x amount
            console.log("Amount B to create: ",amountToDeposit.toString());
            const priceRatio = BigInt(ratioz); // This ratio is in different format than Case 1
            console.log(`priceRatio: ${priceRatio}`);
            console.log(`Price ratio: ${priceRatio}`);
            
            // Direct multiplication - ratio is already in correct format
            amountWith8Decimals0xBTC = (amountToDeposit * priceRatio) / (10n**18n);
            
            console.log(`Estimated Deposit B0x amount: ${ethers.utils.formatEther(amountWith8Decimals0xBTC)}`);
            console.log(`Estimated Deposit 0xBTC amount: ${ethers.utils.formatUnits(amountToDeposit, 8)}`);
            var temp = amountToDeposit;
            amountToDeposit = amountWith8Decimals0xBTC;
            amountWith8Decimals0xBTC = temp;
            
        }

        
        console.log("walletBalances: ",walletBalances['0xBTC']);
        var zeroxbtcdecimal = amountWith8Decimals0xBTC.toString();
        var wallet_zeroxbtc = ethers.utils.parseUnits(walletBalances['0xBTC'], 8).toString();
        console.log("amountWith8Decimals0xBTC: ",zeroxbtcdecimal);
        console.log("wallet_zeroxbtc: ",wallet_zeroxbtc);
        if(parseFloat(zeroxbtcdecimal)>parseFloat(wallet_zeroxbtc)){
            alert("too much 0xbtc u dont have lower it!.")
        }
        
        var b0xdecimal = amountToDeposit.toString();
        var wallet_b0x = ethers.utils.parseUnits(walletBalances['B0x'], 18).toString();
        console.log("amountWith b0xdecimal:  ",b0xdecimal);
        console.log("wallet_b0x: ",wallet_b0x);
        
        if(parseFloat(b0xdecimal)>parseFloat(wallet_b0x)){
            alert("too much b0x u dont have lower it!.")
        }
/*

    function createPositionWith2Tokens(
        address token,
        address token2,
        uint256 amountIn,
        uint256 amountIn2,
        uint currentx96,        // Expected sqrtPriceX96 when user initiated tx
        uint256 slippage,       // Slippage tolerance in basis points (e.g., 100 = 1%)
        address hookAddress,
        address toSendNFTto) public payable returns (bool)
            {
*/

const amountToDepositBN = ethers.BigNumber.from(amountToDeposit.toString());
const amountToDepositBN2 = ethers.BigNumber.from(amountWith8Decimals0xBTC.toString());


let Current_getsqrtPricex96=0;

      try {
        // Call the view function
        const result = await tokenSwapperContract.getsqrtPricex96(tokenAddress, Address_ZEROXBTC_TESTNETCONTRACT, HookAddress);



          // First debug what we're getting back
          console.log("Raw result type:", typeof result);
          console.log("Raw result structure:", Object.keys(result).join(", "));
          
          if (typeof result === 'bigint' || typeof result === 'number') {
            // If it's already a primitive value
            Current_getsqrtPricex96 = result;
          } else if (result._isBigNumber || result instanceof ethers.BigNumber) {
            // For ethers v5 BigNumber
            Current_getsqrtPricex96 = result;
          } else if (typeof result === 'object' && result !== null) {
            // For objects, try to extract the value
            // With ethers v6, we might get the value directly
            if (typeof result.toString === 'function' && result.toString().match(/^[0-9]+$/)) {
              Current_getsqrtPricex96 = result;
            } else {
              // Attempt to extract value based on common patterns
              Current_getsqrtPricex96 = result[0] || result.amountOut || result._hex || result.value || result;
            }
          }
          
          console.log(`Found valid Current_getsqrtPricex96 x10**18: ${Current_getsqrtPricex96.toString()}`);
          // Format to display as a readable number
        } catch (error) {
          console.error(`Error finding valid Current_getsqrtPricex96 for swap:`, error);
        }
try{

                console.log("tokenAddress: ", tokenAddress);

                console.log("Address_ZEROXBTC_TESTNETCONTRACT: ", Address_ZEROXBTC_TESTNETCONTRACT.toString());

                console.log("amountToDepositBN: ", amountToDepositBN.toString());
                console.log("amountToDepositBN2: ", amountToDepositBN2.toString());
                console.log("Current_getsqrtPricex96: ", Current_getsqrtPricex96.toString());
                console.log("HookAddress: ", HookAddress.toString());
                alert("approving tokens for create position!");
                await approveIfNeeded(tokenAddress, contractAddress_Swapper, amountToDepositBN);
                await approveIfNeeded(Address_ZEROXBTC_TESTNETCONTRACT, contractAddress_Swapper, amountToDepositBN2);
                
                var slippage = 10000n;
                const tx = await tokenSwapperContract.createPositionWith2Tokens(
                    tokenAddress, 
                    Address_ZEROXBTC_TESTNETCONTRACT, 
                    amountToDepositBN, 
                    amountToDepositBN2,
                    Current_getsqrtPricex96,
                    slippage,
                    HookAddress, 
                    userAddress
                );

/*

const amountToSwapBN = ethers.BigNumber.from(amountToSwap.toString());
const minAmountOutBN = ethers.BigNumber.from(MinamountOut.toFixed(0).toString());



            try {
                // Call the swap function
                const tx = await tokenSwapperContract.swapTokenTWOTOKENS(
                    tokenAddress, 
                    Address_ZEROXBTC_TESTNETCONTRACT, 
                    tokenAddress, 
                    Address_ZEROXBTC_TESTNETCONTRACT, 
                    amountToSwapBN, 
                    minAmountOutBN, 
                    HookAddress, 
                    userAddress
                );
                */

                if(tokenAinputAddress == Address_ZEROXBTC_TESTNETCONTRACT) {
                    amountInputB.value = ethers.utils.formatUnits(amountToDeposit, 18);
                    amountInputA.value = ethers.utils.formatUnits(amountWith8Decimals0xBTC, 8);
                } else {
                    amountInputB.value = ethers.utils.formatUnits(amountWith8Decimals0xBTC, 8);
                    amountInputA.value = ethers.utils.formatUnits(amountToDeposit, 18);
                }

            ratiozToSave = 10000*amountToDepositBN / amountToDepositBN2;

                console.log("create Position transaction sent:", tx.hash);
                await tx.wait();
                console.log("Transaction confirmed!");
            fetchBalances();
                
            } catch (error) {
                console.error(`Error  create Position :`, error);
            }
        }





    
            let maxCreatedWhen = Date.now() - 5000;



        async function getMaxCreatePosition() {
            maxCreatedWhen = Date.now(); // Save current timestamp in milliseconds
     
          if(!walletConnected){
               await connectWallet();
            }

    var selectSlippage = document.getElementById('slippageTolerance');
    var selectSlippageValue = selectSlippage.value; // Returns: "0.1", "0.5", "1.0", or "2.0"
 const numberValueSlippage = parseFloat(selectSlippageValue.replace('%', ''));
    // Divide by 100 to get decimal
    const decimalValueSlippage= numberValueSlippage / 100;
    console.log("selectSlippageValue: ",selectSlippageValue);
    console.log("decimalValueSlippage: ",decimalValueSlippage);

const tokenASelect = document.querySelector('#create .form-group:nth-child(1) select');


// Get the currently selected value
const tokenAValue = tokenASelect.value;
console.log("Currently selected value TokenA:", tokenAValue);


const tokenBSelect = document.querySelector('#create .form-group:nth-child(2) select');


// Get the currently selected value
const tokenBvalue = tokenBSelect.value;
console.log("Currently selected value TokenB:", tokenBvalue);

// Or get the selected option element itself
const selectedOptionA = tokenASelect.options[tokenASelect.selectedIndex];
const selectedOptionB= tokenBSelect.options[tokenBSelect.selectedIndex];
console.log("selectedOptionA option text:", selectedOptionA.text);
console.log("selectedOptionA option value:", selectedOptionA.value);
console.log("selectedOptionB option text:", selectedOptionB.text);
console.log("selectedOptionB option value:", selectedOptionB.value);

            var tokenAinputAddress = tokenAddresses[selectedOptionA.value];
            var tokenBinputAddress = tokenAddresses[selectedOptionB.value];
console.log("tokenA InputAddresstoken", tokenAinputAddress);
console.log("tokenB InputAddresstoken", tokenBinputAddress);

// Simple and reliable approach - select all number inputs in create page
const createInputs = document.querySelectorAll('#create input[type="number"]');
const amountInputA = createInputs[0]; // First number input (Amount A)
const amountInputB = createInputs[1]; // Second number input (Amount B)

// Add null checks to prevent errors
if (!amountInputA || !amountInputB) {
    console.error("Could not find amount input fields");
    return;
}

// Get the currently selected values
const tokenAInput = amountInputA.value;
const tokenBInput = amountInputB.value;

console.log("Currently amountInputA value:", tokenAInput);
console.log("Currently amountInputB value:", tokenBInput);


            var amountAtoCreate = 0;  // Correctly represents 12 * 10^8
            
            if( selectedOptionA.value=="0xBTC"){
                    console.log("LOGGED 0xBTC selected A Value");
             amountAtoCreate = ethers.utils.parseUnits(walletBalances['0xBTC'], 8);  // Correctly represents 12 * 10^8
            }else{
                amountAtoCreate =ethers.utils.parseUnits(walletBalances['B0x'], 18);  // Correctly represents 12 * 10^8

            }

//console.log("Currently amountInputB value:", tokenBInput);
            var amountBtoCreate = 0;  // Correctly represents 12 * 10^8
            
            if( selectedOptionB.value=="0xBTC"){
                    console.log("LOGGED 0xBTC selected B Value");
             amountBtoCreate = ethers.utils.parseUnits(walletBalances['0xBTC'], 8);  // Correctly represents 12 * 10^8
            }else{ 
                
                
                amountBtoCreate = ethers.utils.parseUnits(walletBalances['B0x'], 18);  // Correctly represents 12 * 10^8
           

            }


            let amountOut = 0;
const tokenSwapperABI = [
    // Your existing createPosition function
   {"inputs":[{"name":"token","type":"address"},{"name":"token2","type":"address"},{"name":"amountIn","type":"uint256"},{"name":"amountIn2","type":"uint256"},{"name":"currentx96","type":"uint256"},{"name":"slippage","type":"uint256"},{"name":"hookAddress","type":"address"},{"name":"toSendNFTto","type":"address"}],"name":"createPositionWith2Tokens","outputs":[{"name":"","type":"bool"}],"stateMutability":"payable","type":"function"},
    //get sqrtx96price for us
,{"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"address","name":"token2","type":"address"},{"internalType":"address","name":"hookAddress","type":"address"}],"name":"getsqrtPricex96","outputs":[{"internalType":"uint160","name":"","type":"uint160"}],"stateMutability":"view","type":"function"}

   ,{"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"address","name":"token2","type":"address"},{"internalType":"address","name":"hookAddress","type":"address"}],"name":"getPriceRatio","outputs":[{"internalType":"uint256","name":"ratio","type":"uint256"},{"internalType":"address","name":"token0z","type":"address"},{"internalType":"address","name":"token1z","type":"address"},{"internalType":"uint8","name":"token0decimals","type":"uint8"},{"internalType":"uint8","name":"token1decimals","type":"uint8"}],"stateMutability":"view","type":"function"}
];

        await ethereum.request({ method: 'eth_requestAccounts' });
        const provider = new ethers.providers.Web3Provider(window.ethereum);
        const signer = provider.getSigner();

                tokenSwapperContract = new ethers.Contract(
                    contractAddress_Swapper, // your tokenSwapper contract address
                    tokenSwapperABI,
                    signer // Use signer since the function isn't view/pure
                );


    let ratioz = 0;
            try {
                // Call the view function
                const result = await tokenSwapperContract.callStatic.getPriceRatio(tokenAddress, Address_ZEROXBTC_TESTNETCONTRACT, HookAddress);




          // First debug what we're getting back
          console.log("Raw result type:", typeof result);
          console.log("Raw result structure:", Object.keys(result).join(", "));
          ratioz = result[0];

          
          
          console.log(`Found valid Ratio x10**18: ${ratioz.toString()}`);
          // Format to display as a readable number
          readableAmountOut = ethers.utils.formatEther(ratioz);
          ratioAsWei = ethers.utils.parseEther(readableAmountOut);
          console.log(`Found valid Ratio x10**18: ${readableAmountOut} mutliplier`);
        } catch (error) {
          console.error(`Error finding valid getPriceRatio for swap:`, error);
        }




        let amountToDeposit = ethers.utils.parseEther("200");  // 200 * 10^18 for B0x token
        var amountToDepositOfZer0X = ethers.utils.parseUnits("100", 8); // 0.01 * 10^8 for 0xBTC
        var amountWith8Decimals0xBTC = 0n;
        let liquiditySalt = 0; // Declare once outside the if/else

            if(tokenAinputAddress == Address_ZEROXBTC_TESTNETCONTRACT) {
            console.log(`Found valid Ratio: ${ratioz.toString()}`);
            console.log("TokenA == zer0x Token (0xBTC is token0, B0x is token1)");
            

            calculatedPriceRatio = BigInt(ratioz);


            amountWith8Decimals0xBTC = amountAtoCreate;
            console.log("amountWith8Decimals0xBTCamountWith8Decimals0xBTC: ",amountWith8Decimals0xBTC.toString());
            // Your calculatedPriceRatio = 200000000000000000000000000000n represents 20 in 29-decimal format
            // Method 1: Direct conversion to get the economic price (20)

            const priceIn18Decimals = calculatedPriceRatio / (10n**10n); // Remove 11 decimals (29-18=11)

            console.log("Price in 18-decimal format:", priceIn18Decimals.toString()); // Should be 20000000000000000000 (20 * 10^18)
            
            // Method 2: Calculate B0x amount needed
            // Formula: B0x_amount = 0xBTC_amount * price
            // We need: (amountToDepositOfZer0X in 18-decimal) * (price in 18-decimal) / 10^18
            
            const amountZer0XIn18Decimals = BigInt(amountAtoCreate) * 10n**10n; // Convert 8-decimal to 18-decimal
            amountToDeposit = (amountZer0XIn18Decimals * priceIn18Decimals) / (10n**18n);
            
            // Alternative simpler method:
            // const economicAmountZer0X = Number(ethers.formatUnits(amountToDepositOfZer0X, 8)); // 0.01
            // const economicAmountB0x = economicAmountZer0X * 20; // 0.01 * 20 = 0.2
            // const amountToDeposit = ethers.parseEther(economicAmountB0x.toString());

            console.log(`Estimated Deposit B0x amount: ${ethers.utils.formatEther(amountToDeposit)}`); // Should be 0.2
            console.log(`Estimated Deposit 0xBTC amount: ${ethers.utils.formatUnits(amountWith8Decimals0xBTC, 8)}`); // Should be 0.01
                console.log(`amountWith8Decimals0xBTC: ${amountWith8Decimals0xBTC}`);
                        console.log(`amountToDeposit: ${amountToDeposit}`);


        } else { 
            
            
                    
            amountToDeposit = BigInt(amountBtoCreate); // Fixed B0x amount
            console.log("Amount B to create: ",amountToDeposit.toString());
            const priceRatio = BigInt(ratioz); // This ratio is in different format than Case 1
            console.log(`priceRatio: ${priceRatio}`);
            console.log(`Price ratio: ${priceRatio}`);
            
            // Direct multiplication - ratio is already in correct format
            amountWith8Decimals0xBTC = (amountToDeposit * priceRatio) / (10n**18n);
            
            console.log(`Estimated Deposit B0x amount: ${ethers.utils.formatEther(amountWith8Decimals0xBTC)}`);
            console.log(`Estimated Deposit 0xBTC amount: ${ethers.utils.formatUnits(amountToDeposit, 8)}`);
            var temp = amountToDeposit;
            amountToDeposit = amountWith8Decimals0xBTC;
            amountWith8Decimals0xBTC = temp;
            
        }

        
        console.log("walletBalances: ",walletBalances['0xBTC']);
        var zeroxbtcdecimal = amountWith8Decimals0xBTC.toString();
        var wallet_zeroxbtc = ethers.utils.parseUnits(walletBalances['0xBTC'], 8).toString();
        console.log("amountWith8Decimals0xBTC: ",zeroxbtcdecimal);
        console.log("wallet_zeroxbtc: ",wallet_zeroxbtc);
        if(parseFloat(zeroxbtcdecimal)>parseFloat(wallet_zeroxbtc)){
            alert("too much 0xbtc u dont have lower it!.")
        }
        
        var b0xdecimal = amountToDeposit.toString();
        var wallet_b0x = ethers.utils.parseUnits(walletBalances['B0x'], 18).toString();
        console.log("amountWith b0xdecimal:  ",b0xdecimal);
        console.log("wallet_b0x: ",wallet_b0x);
        
        if(parseFloat(b0xdecimal)>parseFloat(wallet_b0x)){
            alert("too much b0x u dont have lower it!.");
                        
            console.log("too much b0x u dont have lower it!.");
               
    // Case 2: B0x first - FIXED CALCULATION
    console.log(`Found valid Ratio: ${ratioz.toString()}`);
    console.log("TokenA == B0x Token (B0x is token0, 0xBTC is token1)");
    
            if(tokenAinputAddress != Address_ZEROXBTC_TESTNETCONTRACT) {

        amountToDeposit = BigInt(amountAtoCreate); // B0x amount (18 decimals)
            }else{

    amountToDeposit = BigInt(amountBtoCreate); // B0x amount (18 decimals)
            }

    console.log("Amount B to create: ", amountToDeposit.toString());
    
    // FIXED: Use the same ratio format as Case 1, but calculate inverse
    const calculatedPriceRatio = BigInt(ratioz); // Same 29-decimal format
    const priceIn18Decimals = calculatedPriceRatio / (10n**10n); // Convert to 18-decimal
    
    console.log(`calculatedPriceRatio: ${calculatedPriceRatio}`);
    console.log(`priceIn18Decimals: ${priceIn18Decimals}`);
    
    // Calculate 0xBTC needed: B0x / ratio (inverse calculation)
    // Formula: 0xBTC_amount = B0x_amount / price_ratio
    const amountB0xIn18Decimals = amountToDeposit; // Already in 18 decimals
    const amountZer0XIn18Decimals = (amountB0xIn18Decimals * (10n**18n)) / priceIn18Decimals;
    amountWith8Decimals0xBTC = amountZer0XIn18Decimals / (10n**10n); // Convert 18→8 decimals
    
            if(tokenAinputAddress != Address_ZEROXBTC_TESTNETCONTRACT) {

            }
    console.log(`Estimated Deposit B0x amount: ${ethers.utils.formatEther(amountToDeposit)}`);
    console.log(`Estimated Deposit 0xBTC amount: ${ethers.utils.formatUnits(amountWith8Decimals0xBTC, 8)}`);
    console.log(`amountWith8Decimals0xBTC: ${amountWith8Decimals0xBTC}`);
    console.log(`amountToDeposit: ${amountToDeposit}`);
    


        }
/*

    function createPositionWith2Tokens(
        address token,
        address token2,
        uint256 amountIn,
        uint256 amountIn2,
        uint currentx96,        // Expected sqrtPriceX96 when user initiated tx
        uint256 slippage,       // Slippage tolerance in basis points (e.g., 100 = 1%)
        address hookAddress,
        address toSendNFTto) public payable returns (bool)
            {
*/

const amountToDepositBN = ethers.BigNumber.from(amountToDeposit.toString());
const amountToDepositBN2 = ethers.BigNumber.from(amountWith8Decimals0xBTC.toString());


let Current_getsqrtPricex96=0;

      try {
        // Call the view function
        const result = await tokenSwapperContract.getsqrtPricex96(tokenAddress, Address_ZEROXBTC_TESTNETCONTRACT, HookAddress);



          // First debug what we're getting back
          console.log("Raw result type:", typeof result);
          console.log("Raw result structure:", Object.keys(result).join(", "));
          
          if (typeof result === 'bigint' || typeof result === 'number') {
            // If it's already a primitive value
            Current_getsqrtPricex96 = result;
          } else if (result._isBigNumber || result instanceof ethers.BigNumber) {
            // For ethers v5 BigNumber
            Current_getsqrtPricex96 = result;
          } else if (typeof result === 'object' && result !== null) {
            // For objects, try to extract the value
            // With ethers v6, we might get the value directly
            if (typeof result.toString === 'function' && result.toString().match(/^[0-9]+$/)) {
              Current_getsqrtPricex96 = result;
            } else {
              // Attempt to extract value based on common patterns
              Current_getsqrtPricex96 = result[0] || result.amountOut || result._hex || result.value || result;
            }
          }
          
          console.log(`Found valid Current_getsqrtPricex96 x10**18: ${Current_getsqrtPricex96.toString()}`);
          // Format to display as a readable number
        } catch (error) {
          console.error(`Error finding valid Current_getsqrtPricex96 for swap:`, error);
        }
try{

                console.log("tokenAddress: ", tokenAddress);

                console.log("Address_ZEROXBTC_TESTNETCONTRACT: ", Address_ZEROXBTC_TESTNETCONTRACT.toString());

                console.log("amountToDepositBN: ", amountToDepositBN.toString());
                console.log("amountToDepositBN2: ", amountToDepositBN2.toString());
                console.log("Current_getsqrtPricex96: ", Current_getsqrtPricex96.toString());
                console.log("HookAddress: ", HookAddress.toString());
               

/*

const amountToSwapBN = ethers.BigNumber.from(amountToSwap.toString());
const minAmountOutBN = ethers.BigNumber.from(MinamountOut.toFixed(0).toString());



            try {
                // Call the swap function
                const tx = await tokenSwapperContract.swapTokenTWOTOKENS(
                    tokenAddress, 
                    Address_ZEROXBTC_TESTNETCONTRACT, 
                    tokenAddress, 
                    Address_ZEROXBTC_TESTNETCONTRACT, 
                    amountToSwapBN, 
                    minAmountOutBN, 
                    HookAddress, 
                    userAddress
                );
                */

                if(tokenAinputAddress == Address_ZEROXBTC_TESTNETCONTRACT) {
                    console.log("Check this out: ");
                    console.log("Check this out amountToDeposit: ",amountToDeposit);
                    console.log("Check this out amountWith8Decimals0xBTC: ",amountWith8Decimals0xBTC);
                    amountInputB.value = ethers.utils.formatUnits(amountToDeposit, 18);
                    amountInputA.value = ethers.utils.formatUnits(amountWith8Decimals0xBTC, 8);
                    console.log("THISRIGHT HUR");
                    ratiozToSave = 10**16*amountInputB.value / amountInputA.value;
                } else {
                    amountInputB.value = ethers.utils.formatUnits(amountWith8Decimals0xBTC, 8);
                    amountInputA.value = ethers.utils.formatUnits(amountToDeposit, 18);
                    ratiozToSave = 10**16/ amountInputB.value / amountInputA.value;
                }
                
                
            } catch (error) {
                console.error(`Error  create Position :`, error);
            }
        }





    













        // Staking functions
        function depositStake() {
            const amount = document.getElementById('stakeAmount').value;
            if (!amount || amount <= 0) {
                alert('Please enter a valid amount to stake.');
                return;
            }
            alert(`Depositing ${amount} tokens for staking! Please confirm in your wallet.`);
        }

        function withdrawStake() {
            const amount = document.getElementById('stakeAmount').value;
            if (!amount || amount <= 0) {
                alert('Please enter a valid amount to withdraw.');
                return;
            }
        }
    




















async function fetchTokenBalanceWithEthers(tokenAddress, decimals) {
    console.log("Fetching token Address: ", tokenAddress);
    if (!window.ethereum) {
        console.error("MetaMask not detected");
        return '0';
    }
    
    try {
        await ethereum.request({ method: 'eth_requestAccounts' });
        const provider = new ethers.providers.Web3Provider(window.ethereum);
        const signer = provider.getSigner();
        const walletAddress = await signer.getAddress();
        
        if (tokenAddress === '0x0000000000000000000000000000000000000000') {
            const balance = await provider.getBalance(walletAddress);
            return formatBalanceExact(balance, 18);
        }
        
        const abi = ["function balanceOf(address) view returns (uint256)"];
        const tokenContract = new ethers.Contract(tokenAddress, abi, provider);
        const balance = await tokenContract.balanceOf(walletAddress);
        console.log("Token balance 4, ", tokenAddress, " = ", balance.toString());
        return formatBalanceExact(balance, decimals);
    } catch (error) {
        console.error(`Error fetching token balance for ${tokenAddress}:`, error);
        return '0';
    }
}

// NEW: Exact formatting function that preserves precision
function formatBalanceExact(balance, decimals) {
    // Convert BigNumber to string to avoid precision loss
    const balanceString = balance.toString();
    
    // If decimals is 0, return the raw value
    if (decimals === 0) {
        return balanceString;
    }
    
    // For tokens with decimals, we need to handle the decimal point
    if (balanceString.length <= decimals) {
        // If the balance is smaller than the decimal places, pad with zeros
        const padded = balanceString.padStart(decimals, '0');
        return '0.' + padded;
    } else {
        // Insert decimal point at the right position
        const integerPart = balanceString.slice(0, balanceString.length - decimals);
        const decimalPart = balanceString.slice(balanceString.length - decimals);
        
        // Remove trailing zeros from decimal part for cleaner display
        const trimmedDecimal = decimalPart.replace(/0+$/, '');
        
        if (trimmedDecimal === '') {
            return integerPart;
        } else {
            return integerPart + '.' + trimmedDecimal;
        }
    }
}


        async function fetchBalances() {

            const walletAddress = userAddress;
            if (!walletAddress) {
                showStatus('Please enter a wallet address', 'error');
                return;
            }

            if (!walletAddress.match(/^0x[a-fA-F0-9]{40}$/)) {
                showStatus('Please enter a valid Ethereum address', 'error');
                return;
            }

           // const fetchBtn = document.getElementById('fetchBtn');
            //fetchBtn.disabled = true;
            //fetchBtn.textContent = 'Fetching...';
            
           // showStatus('Fetching balances from blockchain...', 'loading');
            walletBalances = {};
            console.log("test");

            try {
                const promises = Object.entries(tokenAddresses).map(async ([symbol, address]) => {
                    const balance = await fetchTokenBalanceWithEthers(address, tokenAddressesDecimals[symbol]);
                    walletBalances[symbol] = balance;
                    
                });

                await Promise.all(promises);
 displayWalletBalances();
               // showStatus('Balances fetched successfully!', 'success');
            } catch (error) {
                console.log("Error is : ", error);
               // showStatus(`Error fetching balances: ${error.message}`, 'error');
            } finally {
                //fetchBtn.disabled = false;
               // fetchBtn.textContent = 'Check Balances';
            }
        }







function addMaxButtonToField(inputElement, tokenSymbol) {
    // Create MAX button
    const maxButton = document.createElement('button');
    maxButton.type = 'button';
    maxButton.textContent = 'MAX';
    maxButton.className = 'max-button';
    maxButton.style.cssText = `
        position: absolute;
        right: 2px;
        top: 2px;
        bottom: 2px;
        background: #007bff;
        color: white;
        border: none;
        padding: 0 12px;
        border-radius: 0 2px 2px 0;
        font-size: 12px;
        cursor: pointer;
        z-index: 10;
        display: flex;
        align-items: center;
        justify-content: center;
    `;
    
    // Add hover effect
    maxButton.addEventListener('mouseenter', () => {
        maxButton.style.background = '#0056b3';
    });
    maxButton.addEventListener('mouseleave', () => {
        maxButton.style.background = '#007bff';
    });
    
    // Add click handler with proper context
    maxButton.addEventListener('click', function() {
        const positionSelect = document.querySelector('#stake-increase select');
        const selectedPositionId = positionSelect.value;
        const position = stakingPositionData[selectedPositionId];
        
    const swapSection = document.getElementById('stake-increase');
    if (!swapSection || !swapSection.contains(inputElement)) {
        console.log("Not in stake-increase section, returning early");
        return;
    }

        if (!position) return;
        
        // Determine which token we're working with
        const label = inputElement.closest('.form-group').querySelector('label');
        let currentTokenSymbol = tokenSymbol;
        let maxAmount = 0;
        
        if (label && label.textContent.includes(position.tokenA)) {
            currentTokenSymbol = position.tokenA;
            maxAmount = getMaxAmountForToken(position, currentTokenSymbol);
        } else if (label && label.textContent.includes(position.tokenB)) {
            currentTokenSymbol = position.tokenB;
            maxAmount = getMaxAmountForToken(position, currentTokenSymbol);
        } else {
            maxAmount = getMaxAmountForToken(position, currentTokenSymbol);
        }
        
        setMaxAmount(inputElement, currentTokenSymbol, maxAmount);
    });
    

    // Add click handler with proper context
    maxButton.addEventListener('click', function() {
        const positionSelect = document.querySelector('#increase select');

    const swapSection = document.getElementById('increase');
    if (!swapSection || !swapSection.contains(inputElement)) {
        console.log("Not in increase section, returning early");
        return;
    }
        const selectedPositionId = positionSelect.value;
        const position = positionData[selectedPositionId];
        if (!position) return;
        
        // Determine which token we're working with
        const label = inputElement.closest('.form-group').querySelector('label');
        let currentTokenSymbol = tokenSymbol;
        let maxAmount = 0;
        if (label && label.textContent.includes(position.tokenA)) {
            currentTokenSymbol = position.tokenA;
            maxAmount = getMaxAmountForToken(position, currentTokenSymbol) + position.unclaimedFeesTokenA;
        } else if (label && label.textContent.includes(position.tokenB)) {
            currentTokenSymbol = position.tokenB;
            maxAmount = getMaxAmountForToken(position, currentTokenSymbol) + position.unclaimedFeesTokenB;
        } else {
            maxAmount = getMaxAmountForToken(position, currentTokenSymbol);
        }
        
        setMaxAmount(inputElement, currentTokenSymbol, maxAmount);
    });

    // Add click handler with proper context
    maxButton.addEventListener('click', function() {

    const swapSection = document.getElementById('swap');
    if (!swapSection || !swapSection.contains(inputElement)) {
        console.log("Not in swap section, returning early");
        return;
    }
        console.log("this!")
        // Get the currently selected token from the dropdown
        const fromTokenSelect = document.getElementById('fromToken');
        const tokenSelected = fromTokenSelect.value; // This will be 'ETH', 'USDC', etc.
        
        // Get the wallet balance for the selected token
        const maxAmount = getMaxAmountForTokenList(tokenSelected);
        
        // Set the max amount in the input field
        setMaxAmount2(inputElement, tokenSelected, maxAmount);

        console.log("this! !: ", maxAmount);
    });



    // Add click handler for MAX button
    maxButton.addEventListener('click', function() {


    const createSection = document.getElementById('create');
    if (!createSection || !createSection.contains(inputElement)) {
        console.log("Not in create section, returning early");
        return;
    }

    // Get the Token A select element specifically inside the #create page
    const tokenSelect = document.querySelector('#create .form-row .form-group:nth-child(1) select');
//const label = inputElement.closest('form-group').querySelector('label');
const label = inputElement.closest('.form-group').querySelector('label');
                // Extract the text from the label element
            const labelText = label.textContent;

            // Now split the string
            const token = labelText.split(' ').pop();

    // Now tokenSelect is the correct <select> element for Token A or Token B
    console.log('Selected token:', tokenSelect.value);

        const selectedToken = tokenSelect.value.split(' - ')[0]; // Gets "ETH" from "ETH - Ethereum"
        const walletBalance = walletBalances[selectedToken] || 0;
        
        // Format based on token type
        const formattedValue = ['ETH', 'WBTC'].includes(selectedToken) 
            ? parseFloat(walletBalance).toFixed(6)
            : parseFloat(walletBalance).toFixed(2);
        
        const maxAmount = getMaxAmountForTokenList(selectedToken);

        if (label && label.textContent.trim() === 'Amount A') {
            console.log("Amount A Activated!");
        // Set the max amount in the input field
        //setMaxAmount2(inputElement, selectedToken, maxAmount);
        getMaxCreatePosition();
        }
    });



 maxButton.addEventListener('click', function() {



    const createSection = document.getElementById('create');
    if (!createSection || !createSection.contains(inputElement)) {
        console.log("Not in create section, returning early");
        return;
    }



    // Get the Token A select element specifically inside the #create page
    const tokenSelect = document.querySelector('#create .form-row .form-group:nth-child(2) select');

const label = inputElement.closest('.form-group').querySelector('label');
    // Now tokenSelect is the correct <select> element for Token A or Token B
    console.log('Selected token:', tokenSelect.value);

        const selectedToken = tokenSelect.value.split(' - ')[0]; // Gets "ETH" from "ETH - Ethereum"
        const walletBalance = walletBalances[selectedToken] || 0;
        
        // Format based on token type
        const formattedValue = ['ETH', 'WBTC'].includes(selectedToken) 
            ? parseFloat(walletBalance).toFixed(6)
            : parseFloat(walletBalance).toFixed(2);
        
        const maxAmount = getMaxAmountForTokenList(selectedToken);

        if (label && label.textContent.trim() === 'Amount B') {
            console.log("Amount B Activated!");
        // Set the max amount in the input field
        //setMaxAmount2(inputElement, selectedToken, maxAmount);

        getMaxCreatePosition();
        }
        // Set the max amount in the input field
    });


    // Make input element relative positioned
    inputElement.style.position = 'relative';
    
    // Create wrapper just for input and button
    const wrapper = document.createElement('div');
    wrapper.style.cssText = 'position: relative; display: inline-block; width: 100%;';
    
    // Insert wrapper before input
    inputElement.parentNode.insertBefore(wrapper, inputElement);
    
    // Move input into wrapper
    wrapper.appendChild(inputElement);
    
    // Add padding to input to make room for button and remove input's border radius on right
    inputElement.style.paddingRight = '60px';
    inputElement.style.borderTopRightRadius = '0';
    inputElement.style.borderBottomRightRadius = '0';
    
    // Append button to wrapper (not the form-group container)
    wrapper.appendChild(maxButton);
}


// Helper function to get max amount for different token types
// Simplified function to get max amount based on selected token
function getMaxAmountForTokenList(tokenSymbol) {
    // Return the wallet balance for the selected token
    return walletBalances[tokenSymbol] || 0;
}



// Modified setMaxAmount function
function setMaxAmount2(inputElement, tokenSymbol, amount) {
    if (!inputElement) return;
    
    // Format amount based on token type
    let formattedAmount = amount;
    
    inputElement.value = formattedAmount;
    inputElement.dispatchEvent(new Event('input')); // Trigger any calculations
}



// Helper function to get max amount for different token types
function getMaxAmountForToken(position, tokenSymbol) {
    // Check wallet balances first (from your earlier implementation)
    const walletBalance = walletBalances[tokenSymbol] || 0;
    
    // Check if we need to consider other factors
    if (position.tokenA === tokenSymbol) {
        return Math.min(walletBalance, position.maxTokenA || Infinity);
    } else if (position.tokenB === tokenSymbol) {
        return Math.min(walletBalance, position.maxTokenB || Infinity);
    }
    
    // Default case (for ETH or other tokens)
    return walletBalance;
}

// Modified setMaxAmount function
function setMaxAmount(inputElement, tokenSymbol, amount) {
    if (!inputElement) return;
    
    // Format amount based on token type
    let formattedAmount;
    if (['WBTC', 'ETH'].includes(tokenSymbol)) {
        formattedAmount = parseFloat(amount).toFixed(6);
    } else {
        formattedAmount = parseFloat(amount).toFixed(2);
    }
    
    inputElement.value = formattedAmount;
    inputElement.dispatchEvent(new Event('input'));
}

function initializeMaxButtons() {
    // SWAP PAGE - Amount field
    const swapAmountInput = document.querySelector('#swap input[type="number"][placeholder="0.0"]');
    if (swapAmountInput) {
        // Get the selected token from From Token dropdown
        const getSwapToken = () => {
            const fromSelect = document.querySelector('#swap .form-group:nth-child(2) select');
            return fromSelect ? fromSelect.value : 'ETH';
        };
        
        addMaxButtonToField(swapAmountInput, getSwapToken());
        
        // Update when From Token changes
        const fromSelect = document.querySelector('#swap .form-group:nth-child(2) select');
        if (fromSelect) {
            fromSelect.addEventListener('change', () => {
                // Remove old button
                const oldButton = swapAmountInput.parentElement.querySelector('.max-button');
                if (oldButton) oldButton.remove();
                
                // Add new button with updated token
                addMaxButtonToField(swapAmountInput, getSwapToken());
            });
        }
    }
    
    // CREATE POSITION PAGE - Amount A and Amount B
    const createAmountInputs = document.querySelectorAll('#create input[type="number"][placeholder="0.0"]');
    createAmountInputs.forEach((input, index) => {
        const getCreateToken = (inputIndex) => {
            const selects = document.querySelectorAll('#create .token-selector select');
            return selects[inputIndex] ? selects[inputIndex].value : (inputIndex === 0 ? 'ETH' : 'USDC');
        };
        
        addMaxButtonToField(input, getCreateToken(index));
        
        // Update when token selection changes
        const tokenSelect = document.querySelectorAll('#create .token-selector select')[index];
        if (tokenSelect) {
            tokenSelect.addEventListener('change', () => {
                // Remove old button
                const oldButton = input.parentElement.querySelector('.max-button');
                if (oldButton) oldButton.remove();
                
                // Add new button with updated token
                addMaxButtonToField(input, getCreateToken(index));
            });
        }
    });
    
    // INCREASE LIQUIDITY PAGE - The two token amount fields
    const increaseInputs = document.querySelectorAll('#increase .form-row input[type="number"]');
    increaseInputs.forEach((input, index) => {
        const getIncreaseToken = (inputIndex) => {
            const labels = document.querySelectorAll('#increase .form-row label');
            if (labels[inputIndex]) {
                const labelText = labels[inputIndex].textContent;
                return labelText.replace('Add ', '');
            }
            return inputIndex === 0 ? 'ETH' : 'USDC';
        };
        
        addMaxButtonToField(input, getIncreaseToken(index));
        
        // Update when position changes (since tokens change based on selected position)
        const positionSelect = document.querySelector('#increase select');
        if (positionSelect) {
            positionSelect.addEventListener('change', () => {
                // Small delay to let the labels update first
                setTimeout(() => {
                    // Remove old button
                    const oldButton = input.parentElement.querySelector('.max-button');
                    if (oldButton) oldButton.remove();
                    
                    // Add new button with updated token
                    addMaxButtonToField(input, getIncreaseToken(index));
                }, 100);
            });
        }
    });



    
    // INCREASE LIQUIDITY PAGE - The two token amount fields
    const increaseInputsStaking = document.querySelectorAll('#stake-increase .form-row input[type="number"]');
    increaseInputsStaking.forEach((input, index) => {
        const getIncreaseToken = (inputIndex) => {
            const labels = document.querySelectorAll('#stake-increase .form-row label');
            if (labels[inputIndex]) {
                const labelText = labels[inputIndex].textContent;
                return labelText.replace('Add ', '');
            }
            return inputIndex === 0 ? 'ETH' : 'USDC';
        };
        
        addMaxButtonToField(input, getIncreaseToken(index));
        
        // Update when position changes (since tokens change based on selected position)
        const positionSelect = document.querySelector('#stake-increase select');
        if (positionSelect) {
            positionSelect.addEventListener('change', () => {
                // Small delay to let the labels update first
                setTimeout(() => {
                    // Remove old button
                    const oldButton = input.parentElement.querySelector('.max-button');
                    if (oldButton) oldButton.remove();
                    
                    // Add new button with updated token
                    addMaxButtonToField(input, getIncreaseToken(index));
                }, 100);
            });
        }
    });







    // INCREASE LIQUIDITY PAGE - The two token amount fields
    const createPositionField = document.querySelectorAll('#create .form-row input[type="number"]');
    createPositionField.forEach((input, index) => {
        const getIncreaseToken = (inputIndex) => {
            const labels = document.querySelectorAll('#create .form-row label');
            if (labels[inputIndex]) {
                const labelText = labels[inputIndex].textContent;
                return labelText.replace('Add ', '');
            }
            return inputIndex === 0 ? 'ETH' : 'USDC';
        };
        
        addMaxButtonToField(input, getIncreaseToken(index));
        
        // Update when position changes (since tokens change based on selected position)
        const positionSelect = document.querySelector('#create select');
        if (positionSelect) {
            positionSelect.addEventListener('change', () => {
                // Small delay to let the labels update first
                setTimeout(() => {
                    // Remove old button
                    const oldButton = input.parentElement.querySelector('.max-button');
                    if (oldButton) oldButton.remove();
                    
                    // Add new button with updated token
                    addMaxButtonToField(input, getIncreaseToken(index));
                }, 100);
            });
        }
    });
    
}






















// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    filterTokenOptionsSwap();
    // Small delay to ensure other scripts have run first
    setTimeout(initializeMaxButtons, 200);
});

// Also run when called manually (in case DOM is already loaded)
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeMaxButtons);
} else {
    setTimeout(initializeMaxButtons, 200);
}


       // Update token icon and handle dropdown filtering
        function updateTokenSelection(selectId, iconId) {
            const select = document.getElementById(selectId);
            const icon = document.getElementById(iconId);
            const selectedValue = select.value;
            
                            const tokenIcons = {
                                'ETH': 'E',
                                'USDC': 'U',
                                'DAI': 'D',
                                'WBTC': 'W'
                            };
            // Update icon
            icon.textContent = tokenIcons[selectedValue] || selectedValue.charAt(0);
            
        }

        // Filter options to hide selected tokenA in tokenB dropdown only
        function filterTokenOptionsCreate() {
            const tokenA = document.getElementById('tokenA');
            const tokenB = document.getElementById('tokenB');
            const tokenAValue = tokenA.value;
            const tokenBValue = tokenB.value;
            
            // Reset all tokenB options to visible first
            Array.from(tokenB.options).forEach(option => {
                option.style.display = '';
                option.disabled = false;
            });
            
            // Hide the selected tokenA option in tokenB dropdown only
            Array.from(tokenB.options).forEach(option => {
                if (option.value === tokenAValue) {
                    option.style.display = 'none';
                    option.disabled = true;
                }
            });
            
            // If current tokenB selection matches tokenA, change it to first available option
            if (tokenBValue === tokenAValue) {
                const availableOptions = Array.from(tokenB.options).filter(option => 
                    option.value !== tokenAValue && option.style.display !== 'none'
                );
                if (availableOptions.length > 0) {
                    tokenB.value = availableOptions[0].value;
                    updateTokenSelection('tokenB', 'tokenBIcon');
                }
            }
        }


        // Filter options to hide selected fromToken in toToken dropdown only
        function filterTokenOptionsSwap() {
            const fromToken = document.getElementById('fromToken');
            const toToken = document.getElementById('toToken');
            const fromValue = fromToken.value;
            const toValue = toToken.value;
            
            // Reset all toToken options to visible first
            Array.from(toToken.options).forEach(option => {
                option.style.display = '';
                option.disabled = false;
            });
            
            // Hide the selected fromToken option in toToken dropdown only
            Array.from(toToken.options).forEach(option => {
                if (option.value === fromValue) {
                    option.style.display = 'none';
                    option.disabled = true;
                }
            });
            
            // If current toToken selection matches fromToken, change it to first available option
            if (toValue === fromValue) {
                const availableOptions = Array.from(toToken.options).filter(option => 
                    option.value !== fromValue && option.style.display !== 'none'
                );
                if (availableOptions.length > 0) {
                    toToken.value = availableOptions[0].value;
                    updateTokenIcon('toToken', 'toTokenIcon');
                }
            }
        }

// Function to update token icon and clear amount field
function updateTokenIcon(selectId, iconId) {
    // Get the selected token
    const select = document.getElementById(selectId);
    const token = select.value;
    
    // Update the icon (your existing code)
    const icon = document.getElementById(iconId);
    icon.textContent = token.charAt(0); // First letter of token
    
    // Clear the amount input field in the same form group
    const formGroup = select.closest('.form-group').nextElementSibling;
    if (formGroup && formGroup.classList.contains('form-group')) {
        const amountInput = formGroup.querySelector('input[type="number"]');
        if (amountInput) {
            amountInput.value = '0.0';
        }
    }
                filterTokenOptionsSwap();
}

// Add event listener to token selector
document.getElementById('fromToken').addEventListener('change', function() {
    updateTokenIcon('fromToken', 'fromTokenIcon');
});


        




            function swapTokens() {
                const formGroups = document.querySelectorAll('#swap .form-group');
                let fromSelect, toSelect, fromIcon, toIcon;
                
                formGroups.forEach(group => {
                    const label = group.querySelector('label');
                    if (label && label.textContent === 'From Token') {
                        fromSelect = group.querySelector('select');
                        fromIcon = group.querySelector('.token-icon');
                    } else if (label && label.textContent === 'To Token') {
                        toSelect = group.querySelector('select');
                        toIcon = group.querySelector('.token-icon');
                    }
                });
                
                if (fromSelect && toSelect && fromIcon && toIcon) {
                    // Swap the select values
                    const fromValue = fromSelect.value;
                    const toValue = toSelect.value;
                    
                    fromSelect.value = toValue;
                    toSelect.value = fromValue;
                    
                    // Update icons based on new values using the token mapping
                    const tokenIcons = {
                        'ETH': 'E',
                        'USDC': 'U',
                        'DAI': 'D',
                        'WBTC': 'W'
                    };
                    
                    fromIcon.textContent = tokenIcons[fromSelect.value] || fromSelect.value.charAt(0);
                    toIcon.textContent = tokenIcons[toSelect.value] || toSelect.value.charAt(0);


                }
                getEstimate();
            }



const createSection = document.getElementById('create');

if (createSection) {
    const tokenASelect = createSection.querySelector('#tokenA');
    const tokenBSelect = createSection.querySelector('#tokenB');
    const amountAInput = createSection.querySelector('#amountA');
    const amountBInput = createSection.querySelector('#amountB');

    if (tokenASelect && tokenBSelect && amountAInput && amountBInput) {
        // Function to swap amount values
        function swapAmounts() {
            const currentAmountA = amountAInput.value;
            const currentAmountB = amountBInput.value;
            
            amountAInput.value = currentAmountB;
            amountBInput.value = currentAmountA;
            
            console.log('Swapped amounts - A:', currentAmountB, 'B:', currentAmountA);
        }
        
        // Listen for Token A changes
        tokenASelect.addEventListener('change', function() {
            console.log('Token A changed to:', this.value);
            swapAmounts();
        });
        
    } else {
        console.log('Could not find token selects or amount inputs in create section');
    }
} else {
    console.log('Create section not found');
}






    </script>
    </body></html>
